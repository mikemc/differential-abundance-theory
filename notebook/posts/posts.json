[
  {
    "path": "posts/2022-01-08-leopold2020host-case-study/",
    "title": "Analysis of Leopold and Busby (2020) for manuscript case study",
    "description": "This document performs analysis of the data from @leopold2020host to support the fungal case study in the manuscript.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-08",
    "categories": [
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\n\nContents\nSetup\nBias estimation\n\nT1 samples\nSetup\nVariation in mean efficiency\nVariation in proportions vs mean efficiency\n\nChange in commensals due to infection\nSetup\nVariation in mean efficiency\nSimple linear regression of log proportion\n\nSession info\n\nSetup\n\n\nlibrary(here)\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(ggdist)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal)\n\n# library(rstanarm)\n# options(mc.cores = 4)\n\n\n\n\n\n# color pallets from leopold2020host\npal_treatment <- c(\"#2F4F4F\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\")\npal_region <- c(\"#A2CD5A\",\"#6E8B3D\")\npal_genotype <- c(\"#800000FF\", \"#767676FF\", \"#CC8214FF\", \"#616530FF\",\n  \"#0F425CFF\", \"#9A5324FF\", \"#3E3E23FF\", \"#D6D6CEFF\", \"#FFB547FF\", \"#ADB17DFF\",\n  \"#5B8FA8FF\", \"#D49464FF\")\n\n\n\n\n\nShow code\n\n## From the metacal 2.0 tutorial\n# Download data from https://zenodo.org/record/3872145\ndata_path <- here::here(\"notebook/_data\", \"leopold2020host\")\n# To use a temporary directory:\n# data_path <- file.path(tempdir(), \"leopold2020\")\nif (!dir.exists(data_path)) {\n  dir.create(data_path, recursive = TRUE)\n  download.file(\n    \"https://zenodo.org/record/3872145/files/dleopold/Populus_priorityEffects-v1.2.zip\",\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\")\n  )\n  unzip(\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\"), \n    exdir = data_path\n  )\n}\n\nmock_actual <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/data/MockCommunities.csv\") %>%\n  read.csv(row.names = 1) %>%\n  select(-Sym4) %>%\n  as(\"matrix\") %>%\n  otu_table(taxa_are_rows = FALSE) %>%\n  transform_sample_counts(function(x) close_elts(1 / x))\nmock_taxa <- taxa_names(mock_actual)\ncommensal_taxa <- setdiff(mock_taxa, 'Melampsora')\n\n# Rust severity\nrust <- file.path(data_path, 'dleopold-Populus_priorityEffects-8594f7c',\n  'data/rust_measurements.csv'\n) %>%\n  read_csv %>%\n  select(-1)\n# summarize following approach from leopold \nrust_summary <- rust %>%\n  janitor::clean_names() %>%\n  rename(plant_id = samp_id) %>%\n  with_groups(plant_id, summarize, \n    # across(ends_with('cm2'), mean)\n    rust_pct = sum(rust_cm2)/sum(leaf_cm2),\n    lesion_pct = sum(lesion_cm2) / sum(leaf_cm2),\n    leaf_area = sum(leaf_cm2),\n    leaf_n = n()\n  )\n\n#> The microbiome data is stored in a phyloseq object,\nps_raw <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/output/compiled/phy.rds\") %>%\n  readRDS %>%\n  filter_tax_table(.otu %in% mock_taxa) %>%\n  mutate_sample_data(., \n    Timepoint = factor(Timepoint),\n    sample_sum = sample_sums(.)\n  ) %>%\n  mutate_sample_data(\n    plant_id = str_extract(.sample, 'G[0-9]+\\\\.T[0-9]+\\\\.R[0-9]+')\n  ) %>%\n  left_join_sample_data(\n    rust_summary, by = 'plant_id'\n  ) %>%\n  rename_with_sample_data(janitor::make_clean_names)\n\nps_mock <- ps_raw %>% \n  subset_samples(samp_type == \"Mock\") %>%\n  prune_taxa(mock_taxa, .)\n\n\n\nCheck sample sums,\n\n\nsam <- ps_raw %>% sample_data %>% as_tibble\nsam %>%\n  as_tibble %>%\n  ggplot(aes(sample_sum, fill = samp_type)) +\n  scale_x_log10() +\n  geom_histogram() +\n  scale_fill_brewer(type = 'qual')\n\n\n\n\n\n\nsam %>%\n  filter(sample_sum < 3e3) %>%\n  select(.sample, timepoint, treatment, sample_sum)\n\n\n# A tibble: 1 × 4\n  .sample       timepoint treatment sample_sum\n  <chr>         <fct>     <chr>          <dbl>\n1 G12.T6.R4.TP1 1         Negative        1366\n\nThe sample with less than 3000 reads is in the ‘Negative’ treatment group and so will be ignored in our analysis of the T1 samples.\nLet’s check the distribution of proportions of the mock taxa across samples.\n\n\nps_raw %>% \n  filter_sample_data(samp_type == \"Experiment\", treatment != 'Negative') %>%\n  filter_tax_table(.otu %in% mock_taxa) %>%\n  transform_sample_counts(close_elts) %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance + 1e-5)) +\n  facet_wrap(~timepoint) +\n  scale_x_log10() +\n  stat_slab()\n\n\n\n\nT1 samples have reads of Melampsora, which may be contamination. For our analysis, let’s subset to the mock taxa and just the experimental samples, and set Melampsora in T1 to zero.\n\n\notu_new <- ps_raw %>% \n  filter_tax_table(.otu %in% mock_taxa) %>%\n  filter_sample_data(samp_type == \"Experiment\", treatment != 'Negative') %>%\n  as_tibble %>%\n  mutate(.abundance = ifelse(\n      timepoint == 1 & .otu == 'Melampsora', 0, .abundance\n  )) %>%\n  select(.sample, .otu, .abundance) %>%\n  pivot_wider(names_from = .otu, values_from = .abundance) %>%\n  otu_table(taxa_are_rows = FALSE)\nps <- ps_raw\notu_table(ps) <- otu_new\nrm(otu_new)\n\n\n\nConfirm that Mel is zero’d in the t1 samples,\n\n\nps %>% \n  prune_taxa('Melampsora', .) %>%\n  as_tibble %>%\n  with_groups(timepoint, summarize,\n    across(.abundance, list(median = median, perc_pos = ~mean(. > 0) ))\n  )\n\n\n# A tibble: 2 × 3\n  timepoint .abundance_median .abundance_perc_pos\n  <fct>                 <dbl>               <dbl>\n1 1                         0                   0\n2 2                     12175                   1\n\nBias estimation\nWe estimate bias using metacal::estimate_bias(); see the metacal tutorial for more information. Leopold and Busby (2020) identified the sample Mock.5 as an outlier sample and excluded it when estimating bias. One taxon in this sample, Epicoccum, was undetected, and including it leads to a larger standard error especially for this taxon (as seen in the metacal tutorial). We could improve our bias estimates by setting this taxon’s nominal abundance to 0 in this sample; however, let’s just drop this sample to maintain consistent bias estimates with those used in the original study.\n\n\ncontrol_samples <- ps_mock %>% sample_names %>% setdiff('Mock.5')\nmc_fit <- estimate_bias(\n  ps_mock %>% prune_samples(control_samples, .), \n  mock_actual %>% prune_samples(control_samples, .), \n  boot = TRUE\n)\nbias <- coef(mc_fit) %>% print(digits = 2)\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n         8.57          0.28          1.57          2.79          0.21 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n         0.86          0.54          1.46          0.67 \n\n\n\nmc_fit_summary <- summary(mc_fit)\ncoef_tb <- mc_fit_summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\nT1 samples\nFrom our previous analyses, we know that there is little impact of bias correction on the primary analyses done on these samples, and also that there is fairly little variation in the mean efficiency in the T1 samples. Here we further explore the variation in both the species proportions and the mean efficiency to more fully understand why bias has little impact on DA analysis.\nSetup\nHere we subset to the T1 experimental samples and the commensal taxa. The analysis of T1 samples by Leopold and Busby (2020) first subsets to just the 8 commensal (non-pathogenic) inoculum taxa, and we follow suit here. It excludes Melampsora and OTUs not identified with the 9 inoculum taxa. In addition, we add the sample sums and mean efficiency to the sample data, after subsetting to the commensals.\n\n\n# Bias among the commensals; for convenience, set relative to max\nbias_t1 <- bias[names(bias) != 'Melampsora']\nbias_t1 <- bias_t1 / max(bias_t1)\nmost_efficient_taxon <- which.max(bias_t1) %>% names\nstopifnot(most_efficient_taxon == 'Fusarium')\n\nps_t1 <- ps %>%\n  filter_sample_data(timepoint == 1) %>%\n  filter_tax_table(.otu %in% commensal_taxa) %>%\n  mutate_sample_data(., \n    sample_sum = sample_sums(.),\n    mean_efficiency = calibrate(., bias_t1, norm = 'close') %>%\n      perturb(bias_t1, norm = 'none') %>% \n      sample_sums,\n  )\nsam_t1 <- ps_t1 %>% sample_data %>% as_tibble\n\n\n\nA small fraction (0.0328) of the observed counts are zero. For calculations that ignore the counting error, we want to ensure there are only positive abundances. We will replace zeros using zCompositions::cmultRepl() following Leopold and Busby (2020), then recompute the mean efficiency (which should only change very slightly).\n\n\nstopifnot(taxa_are_rows(ps_t1) == FALSE)\notu_new <- ps_t1 %>% \n  otu_table %>% \n  as('matrix') %>%\n  zCompositions::cmultRepl(\n    method = 'GBM', \n    output = 'p-counts', \n    suppress.print = TRUE\n  )\nps_t1_repl <- ps_t1\notu_table(ps_t1_repl) <- otu_table(otu_new, taxa_are_rows = FALSE)\nrm(otu_new)\nps_t1_repl <- ps_t1_repl %>%\n  mutate_sample_data(., \n    mean_efficiency_initial = mean_efficiency,\n    mean_efficiency = calibrate(., bias_t1, norm = 'close') %>%\n      perturb(bias_t1, norm = 'none') %>% \n      sample_sums,\n  )\n\n\n\nLet’s create a data frame with the observed and calibrated proportions of each species, with their efficiencies added in.\n\n\nprops <- ps_t1_repl %>%\n  as_tibble %>%\n  left_join(bias_t1 %>% enframe('.otu', 'efficiency'),\n    by = '.otu'\n  ) %>%\n  with_groups(.sample, mutate, \n    prop_obs = close_elts(.abundance),\n    prop_cal = close_elts(.abundance / efficiency),\n  ) %>%\n  mutate(\n    .otu_fct = fct_reorder(.otu, efficiency)\n  )\n\n\n\nVariation in mean efficiency\nLet’s examine the variation in mean efficiency\n\n\nlyrs <- list(\n  geom_histogram(),\n  scale_x_log10(),\n  expand_limits(x = 1.2),\n  scale_fill_brewer(type = \"qual\"),\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    # fill = ''\n  )\n)\n\np1 <- sam_t1 %>%\n  ggplot(aes(mean_efficiency, fill = region)) +\n  lyrs\np2 <- sam_t1 %>%\n  ggplot(aes(mean_efficiency, fill = treatment)) +\n  lyrs\np1 / p2\n\n\n\n\nThe relative efficiency has a geometric range of 13-fold and a geometric standard deviation of 2.41-fold. But the mean efficiency’s geometric range is only 1.62-fold and its geometric standard deviation is just 1.05-fold.\nVariation in proportions vs mean efficiency\nFirst let’s create some summary statistics of the calibrated proportions, to compare to those of the mean efficiency.\n\n\nprops %>%\n  with_groups(.otu_fct, summarize,\n    across(prop_cal, \n      list(gm_mean = gm_mean, gm_sd = gm_sd, gm_range = gm_range),\n      .names = '{.fn}'\n    )\n  ) %>%\n  arrange(desc(.otu_fct)) %>%\n  mutate(across(-.otu_fct, signif, 3)) %>%\n  knitr::kable()\n\n\n.otu_fct\ngm_mean\ngm_sd\ngm_range\nFusarium\n0.12400\n1.49\n13.10\nEpicoccum\n0.19800\n1.46\n20.60\nAlternaria\n0.55700\n1.18\n2.79\nCladosporium\n0.02820\n1.76\n43.30\nAureobasidium\n0.00944\n1.99\n1700.00\nTrichoderma\n0.00368\n3.40\n8190.00\nDioszegia\n0.02650\n1.85\n30.30\nPenicillium\n0.00189\n9.45\n8990.00\n\nNow let’s create the main figure showing the variation in taxa proportions against that in the mean efficiency, with the individual taxa efficiencies also shown for more context.\nCaption: In the pre-infection samples from Leopold and Busby (2020), multiplicative variation in taxa proportions is much larger than that in the mean efficiency. Panel A shows the distribution of the proportions of each commensal isolate (denoted by its genus) across all samples collected prior to pathogen inoculation; Panel C shows the distribution of the (estimated) sample mean efficiency across these same samples on the same scale; and Panel B shows the efficiency of each taxon estimated from DNA mock communities as point estimates and 90% bootstrap percentile confidence intervals. Efficiencies are shown relative to the most efficiently measured taxon (Fusarium).\n\n\nrng <- props %>% pull(prop_cal) %>% range\n## species proportions\np_props <- props %>%\n  ggplot(aes(y = .otu_fct, x = prop_cal)) +\n  scale_x_log10() +\n  stat_slab() +\n  labs(x = 'Proportion', y = NULL)\n## mean efficiency\np_me <- sam_t1 %>%\n  ggplot(aes(y = 'Mean efficiency', x = mean_efficiency)) +\n  scale_x_log10() +\n  expand_limits(x = rng) +\n  stat_slab() +\n  labs(x = 'Efficiency relative to Fusarium', y = NULL)\n# p_me / p_props + plot_layout(heights = c(0.1, 1))\n## Estimated efficiency with bootstrap CIs\nx <- mc_fit$bootreps %>%\n  data.table::as.data.table(keep.rownames = '.id') %>%\n  select(.id, all_of(commensal_taxa)) %>%\n  mutate(across(-.id, ~. / Fusarium)) %>%\n  pivot_longer(-.id, names_to = 'taxon', values_to = 'efficiency') \np_eff <- x %>%\n  mutate(taxon = fct_reorder(taxon, efficiency)) %>%\n  ggplot(aes(y = taxon, x = efficiency)) +\n  stat_pointinterval(.width = 0.9) +\n  scale_x_log10() +\n  labs(x = str_glue('Efficiency relative to Fusarium'), y = NULL)\n\n\n\n\n\np_props + p_eff + p_me + plot_spacer() + \n  plot_layout(heights = c(1, 0.15), widths = c(1, 0.8), ncol = 2) +\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nChange in commensals due to infection\nGoal: Do a linear regression analysis of change in log proportion following pathogen colonization (from T1 to T2).\nNote, I am keeping in the pathogen Melampsora for this analysis. The increase in Mel proportion post infection is a major driver of the impact of bias, since it causes the mean efficiency to increase. If we instead considered the proportions among just the commensals, then we would get different results. The results here, with Mel included, are the most informative for what would happen if we were performing absolute-abundance analysis using total-community normalization.\nSetup\nFor doing simple linear regression, we must replace zeros with positive values. I will use zCompositions::cmultRepl() as in Leopold and Busby (2020) for simplicity and consistency with our other analyses in this case study. I will recompute the mean efficiency with these new compositions; however, aero replacement will have a minimal impact on the mean efficiency.\n\n\nbias_inf <- bias/bias['Fusarium']\nps_inf <- ps\nstopifnot(taxa_are_rows(ps_inf) == FALSE)\notu_new <- ps_inf %>% \n  otu_table %>% \n  as('matrix') %>%\n  zCompositions::cmultRepl(\n    method = 'GBM', \n    output = 'p-counts', \n    suppress.print = TRUE\n  )\nps_inf_repl <- ps_inf\notu_table(ps_inf_repl) <- otu_table(otu_new, taxa_are_rows = FALSE)\nrm(otu_new)\nps_inf_repl <- ps_inf_repl %>%\n  mutate_sample_data(., \n    mean_efficiency = calibrate(., bias_inf, norm = 'close') %>%\n      perturb(bias_inf, norm = 'none') %>% \n      sample_sums,\n  )\n\n\n\nVariation in mean efficiency\nFrom our previous explorations, we know that the mean efficiency tends to increase post infection due to the higher proportion of Melampsora.\nLet’s see this again,\n\n\nmel <- ps_inf %>% \n  calibrate(bias = bias_inf) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  otu_table %>%\n  as_tibble %>%\n  select(.sample, melampsora_prop = .abundance)\nsam <- ps_inf_repl %>% sample_data %>% as_tibble %>%\n  left_join(mel, by = '.sample')\np_hist <- sam %>%\n  ggplot(aes(fill = timepoint, x = mean_efficiency)) +\n  scale_x_log10() +\n  geom_histogram() +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = 'Timepoint'\n  )\np_mel <- sam %>%\n  ggplot(aes(y = melampsora_prop, x = mean_efficiency, color = timepoint)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Pathogen proportion\",\n    x = \"Mean efficiency\",\n    color = 'Timepoint'\n  )\n\n\n\n\n\np_hist / p_mel +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nLet’s visualize the pre and post infection mean eff’s by host genotype.\n\n\nps_inf_repl %>%\n  sample_data %>%\n  as_tibble %>%\n  ggplot(aes(y = genotype, x = mean_efficiency, \n      color = timepoint)) +\n  scale_x_log10() +\n  geom_boxplot() +\n  geom_quasirandom(groupOnX = FALSE) +\n  scale_color_brewer(type = 'qual', palette = 3)\n\n\n\n\nThe mean efficiency generally increases by a similar factor in each genotype.\nLet’s measure the average fold increase in each genotype.\n\n\nmean_eff_reg <- ps_inf_repl %>%\n  sample_data %>%\n  as_tibble %>%\n  group_by(genotype) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log(mean_efficiency) ~ timepoint, data = .x))\n  ) %>%\n  select(-data) %>% \n  mutate(across(starts_with('fit'), map, tidy)) %>%\n  unnest(fit)\n\n\n\n\n\nx <- mean_eff_reg %>%\n  filter(term == 'timepoint2') %>%\n  mutate(across(c(estimate, std.error), exp))\nx %>% select(genotype:std.error) %>% arrange(genotype) %>% \n  knitr::kable(digits = 3)\n\n\ngenotype\nterm\nestimate\nstd.error\nEast-1\ntimepoint2\n4.974\n1.022\nEast-2\ntimepoint2\n5.244\n1.020\nEast-3\ntimepoint2\n4.466\n1.035\nEast-4\ntimepoint2\n4.352\n1.073\nEast-5\ntimepoint2\n4.299\n1.061\nWest-1\ntimepoint2\n3.952\n1.049\nWest-2\ntimepoint2\n2.490\n1.088\nWest-3\ntimepoint2\n3.226\n1.076\nWest-4\ntimepoint2\n3.447\n1.071\nWest-5\ntimepoint2\n4.222\n1.048\nWest-6\ntimepoint2\n2.620\n1.109\nWest-7\ntimepoint2\n3.212\n1.106\n\nx %>%\n  ggplot(aes(y = genotype, x = estimate)) +\n  expand_limits(x = c(1, 6)) +\n  scale_x_log10() +\n  geom_vline(xintercept = 1, color = 'grey') +\n  geom_point() +\n  geom_linerange(\n    aes(\n      xmin = estimate * std.error^2,\n      xmax = estimate / std.error^2\n    )\n  )\n\n\n\n\nThe FC in mean efficiency ranges from 2.49 to 5.24.\nSimple linear regression of log proportion\n\n\nx <- ps_inf_repl %>% \n  as_tibble %>%\n  left_join(bias_inf %>% enframe('.otu', 'efficiency'), by = '.otu')\n\n\n\nRun a simple linear regression with lm on log proportion,\n\n\nx_reg <- x %>%\n  with_groups(.sample, mutate,\n    log_prop = log(close_elts(.abundance))\n  ) %>%\n  filter(.otu %in% commensal_taxa) %>%\n  mutate(\n    offset_obs = 0,\n    offset_cal = log(efficiency / mean_efficiency),\n  ) %>%\n  group_by(.otu, genotype) %>%\n  nest() %>%\n  mutate(\n    fit_obs = map(data, \n      ~lm(\n        log_prop ~ timepoint + offset(offset_obs), \n        data = .x,\n      )),\n    fit_cal = map(data, \n      ~lm(\n        log_prop ~ timepoint + offset(offset_cal), \n        data = .x,\n      )),\n  )\n\n\n\n\n\nz <- x_reg %>%\n  select(-data) %>% \n  mutate(across(starts_with('fit'), map, tidy, conf.int = TRUE)) %>%\n  pivot_longer(starts_with('fit'), names_to = 'type', values_to = 'fit', \n    names_prefix = 'fit_') %>%\n  unnest(fit) %>%\n  ungroup %>%\n  left_join(enframe(bias, '.otu', 'efficiency'), by = '.otu')\n\n\n\n\n\nz1 <- z %>%\n  filter(term == 'timepoint2') %>%\n  select(.otu, genotype, type, estimate, std.error) %>%\n  pivot_wider(names_from = type, values_from = c(estimate, std.error)) %>%\n  glimpse\n\n\nRows: 96\nColumns: 6\n$ .otu          <chr> \"Aureobasidium\", \"Aureobasidium\", \"Aureobasidi…\n$ genotype      <chr> \"West-7\", \"East-1\", \"East-2\", \"West-5\", \"West-…\n$ estimate_obs  <dbl> -2.320913, -4.649869, -5.158821, -3.690699, -1…\n$ estimate_cal  <dbl> -1.1540542, -3.0456064, -3.5016735, -2.2503328…\n$ std.error_obs <dbl> 0.5799465, 0.3149781, 0.3133921, 0.4267797, 0.…\n$ std.error_cal <dbl> 0.5161804, 0.3025285, 0.3088991, 0.4121072, 0.…\n\nCheck that the corrections are the same for each taxon within a genotype, but differ by genotype.\n\n\nz1 %>%\n  ggplot(aes(y = .otu, x = estimate_cal - estimate_obs, color = .otu)) +\n  scale_color_manual(values = pal_genotype, guide = NULL) +\n  facet_wrap(~genotype) +\n  stat_pointinterval()\n\n\n\n\nThe corrections are the same within genotypes, as expected, and vary to a small degree between genotypes. They tend to be larger for Eastern genotypes; this matches with the finding that Eastern genotypes are more susceptible to rust, and so we should expect the Melampsora proportions to be larger.\nLet’s visualize the impact of bias correction on the coefficients, in a couple ways. First, let’s plot the uncorrected against the corrected estimates.\n\n\nz1 %>%\n  ggplot(aes(estimate_cal, estimate_obs, color = .otu)) +\n  scale_color_manual(values = pal_genotype) +\n  facet_wrap(~genotype, ncol = 4) +\n  theme_minimal_grid() +\n  theme() +\n  coord_fixed() +\n  scale_x_continuous(breaks = seq(-6, 2, 2)) +\n  labs(\n    x = 'Estimate with bias correction',\n    y = 'Estimate without bias correction',\n    color = 'Taxon'\n  ) +\n  geom_hline(yintercept = 0, color = 'black') +\n  geom_vline(xintercept = 0, color = 'black') +\n  geom_abline(color = 'darkred') +\n  geom_linerange(\n    aes(\n      xmin = estimate_cal - 2 * std.error_cal,\n      xmax = estimate_cal + 2 * std.error_cal,\n    )\n  ) +\n  geom_linerange(\n    aes(\n      ymin = estimate_obs - 2 * std.error_obs,\n      ymax = estimate_obs + 2 * std.error_obs\n    )\n  ) +\n  geom_point(size = 2)\n\n\n\n\nThis figure makes it clear how the constant shift maintains a perfect correlation between estimates. But it is perhaps easier to see the biological impact on the results if we plot the two estimate types in a straight line,\n\n\nz %>%\n  filter(term == 'timepoint2') %>%\n  mutate(\n    across(.otu, fct_reorder, estimate),\n    across(type, fct_recode, Corrected = 'cal', Uncorrected = 'obs')\n  ) %>%\n  ggplot(aes(y =.otu, color = type,\n      x = estimate, \n      xmin = estimate - 2 * std.error,\n      xmax = estimate + 2 * std.error\n  )) +\n  # theme_minimal_hgrid() +\n  theme(\n    axis.line.y = element_blank()\n  ) +\n  colorblindr::scale_color_OkabeIto() +\n  facet_wrap(~genotype, ncol = 4) +\n  labs(\n    x = 'Estimated LFC',\n    y = 'Taxon',\n    color = 'Type'\n  ) +\n  geom_vline(xintercept = 0, size = 0.5, color = 'grey') +\n  geom_pointrange(fatten = 2)\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-12\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.1     2021-06-06 [1] Bioconductor\n bit                4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64              4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom            * 0.7.10     2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.0      2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorblindr        0.1.0      2021-08-27 [1] Github (clauswilke/colorblindr@e6730be)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional     0.2.2      2021-02-02 [1] CRAN (R 4.0.4)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist           * 3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.5.1      2021-11-30 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9      2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n janitor            2.1.0      2021-01-05 [1] CRAN (R 4.0.4)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9008 2021-10-30 [1] Github (mikemc/metacal@c1f21db)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n NADA               1.6-1.1    2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n snakecase          0.11.0     2019-05-25 [1] CRAN (R 4.0.0)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8      2018-02-27 [1] CRAN (R 4.0.1)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom              1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28       2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)\n zCompositions      1.3.4      2020-03-04 [1] CRAN (R 4.0.1)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-08-leopold2020host-case-study/leopold2020host-case-study_files/figure-html5/variation-in-proportions-and-mean-efficiency-1.svg",
    "last_modified": "2022-01-12T20:19:50-05:00",
    "input_file": "leopold2020host-case-study.knit.md"
  },
  {
    "path": "posts/2022-01-08-lloyd2020evi-case-study/",
    "title": "Analysis of Lloyd et al (2020) for manuscript case study",
    "description": "Perform calculations for the Lloyd et al (2020) case study.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-08",
    "categories": [
      "ref:lloyd2020evid",
      "differential abundance"
    ],
    "contents": "\n\nContents\nSetup\nAnalysis\nSession info\n\nSetup\nLoad libraries,\n\n\nlibrary(here)\nlibrary(tidyverse)\n# library(tidyxl)\nlibrary(unpivotr)\n\n\n\nOur source data is Table 1 from Lloyd et al. (2020), which I’ve manually input into a CSV file. This table has the form of a ‘pivot table’ with nested headers; we can properly read it in and create a ‘tidy’ version table using the unpivotr package, following this example. First we’ll read it in with one row per spreadsheet cell,\n\n\nall_cells <- here('notebook/_data/lloyd2020evid/table1.csv') %>%\n  read_csv(col_names = FALSE) %>%\n  as_cells %>%\n  # filter(!is.na(hr), chr != 'Clade') %>%\n  glimpse\n\n\nRows: 56\nColumns: 4\n$ row       <int> 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1,…\n$ col       <int> 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,…\n$ data_type <chr> \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"…\n$ chr       <chr> NA, NA, \"Clade\", \"Bathyarchaeota, or MCG\", \"Group …\n\nConfirm that this data matches Table 1,\n\n\nall_cells %>% rectify %>% knitr::kable()\n\n\nrow/col\n1(A)\n2(B)\n3(C)\n4(D)\n5(E)\n6(F)\n7(G)\n1\nNA\nWOR marine sediment\nNA\nNA\nNA\nCLB marine sediment\nNA\n2\nNA\nCore 30\nNA\nCore 32\nNA\nIncubation 2\nIncubation 3\n3\nClade\nFRAxC\nqPCR\nFRAxC\nqPCR\nFRAxC\nFRAxC\n4\nBathyarchaeota, or MCG\n10.1\n10.3\n8.9\n10\n6.4\n6.3\n5\nGroup C3, MCG-related\n16.2\nNA\n14.9\nNA\n2.1\n1.8\n6\nThermoprofundales (MBG-D)\n4.6\nNA\n3.4\n4.8\n3.4\n4.4\n7\nThermoprofundales (MG-III)\n3.7\nNA\n2.8\nNA\n1.4\n1.5\n8\nThermoprofundales (20a-9)\n7.1\nNA\n3.7\nNA\n0.8\n0.7\n\nNote, the values of the table are doubling times.\nNow, munge the data into tidy form, with one row per measurement. Additionally, compute the doubling rate as the reciprocal of the doubling time.\n\n\n# abbreviations: exp for experiment, meas for measurement\nx <- all_cells %>%\n  behead(\"up-left\", exp_type) %>%\n  behead(\"up-left\", exp_name) %>%\n  behead(\"up\", meas_type) %>%\n  behead(\"left\", clade) %>%\n  select(clade, starts_with('exp'), meas_type, doubling_time = chr) %>%\n  mutate(\n    across(doubling_time, as.numeric),\n    doubling_rate = 1 / doubling_time,\n  ) %>%\n  arrange(clade, exp_type, exp_name, meas_type) %>%\n  glimpse\n\n\nRows: 30\nColumns: 6\n$ clade         <chr> \"Bathyarchaeota, or MCG\", \"Bathyarchaeota, or …\n$ exp_type      <chr> \"CLB marine sediment\", \"CLB marine sediment\", …\n$ exp_name      <chr> \"Incubation 2\", \"Incubation 3\", \"Core 30\", \"Co…\n$ meas_type     <chr> \"FRAxC\", \"FRAxC\", \"FRAxC\", \"qPCR\", \"FRAxC\", \"q…\n$ doubling_time <dbl> 6.4, 6.3, 10.1, 10.3, 8.9, 10.0, 2.1, 1.8, 16.…\n$ doubling_rate <dbl> 0.15625000, 0.15873016, 0.09900990, 0.09708738…\n\ndir.create('_output')\nsaveRDS(x, '_output/table1-tidy.rds')\n\n\n\nAnalysis\nLet’s compute the error in doubling rate, assuming that the qPCR rate is accurate.\n\n\ny <- x %>%\n  select(-doubling_time) %>%\n  pivot_wider(names_from = meas_type, values_from = doubling_rate) %>%\n  mutate(error = FRAxC - qPCR)\n\n\n\n\n\ny %>% \n  filter(!is.na(qPCR)) %>%\n  select(-exp_type) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nexp_name\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\nCore 30\n0.0990\n0.0971\n0.0019\nBathyarchaeota, or MCG\nCore 32\n0.1124\n0.1000\n0.0124\nThermoprofundales (MBG-D)\nCore 32\n0.2941\n0.2083\n0.0858\n\nCore 30\n\n\ny %>% \n  # filter(str_detect(exp_type, 'WOR')) %>%\n  filter(exp_name == 'Core 30') %>%\n  select(-exp_type, -exp_name) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\n0.0990\n0.0971\n0.0019\nGroup C3, MCG-related\n0.0617\nNA\nNA\nThermoprofundales (20a-9)\n0.1408\nNA\nNA\nThermoprofundales (MBG-D)\n0.2174\nNA\nNA\nThermoprofundales (MG-III)\n0.2703\nNA\nNA\n\nCore 32\n\n\ny %>% \n  filter(exp_name == 'Core 32') %>%\n  select(-exp_type, -exp_name) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\n0.1124\n0.1000\n0.0124\nGroup C3, MCG-related\n0.0671\nNA\nNA\nThermoprofundales (20a-9)\n0.2703\nNA\nNA\nThermoprofundales (MBG-D)\n0.2941\n0.2083\n0.0858\nThermoprofundales (MG-III)\n0.3571\nNA\nNA\n\nCompute the calculations for the manuscript text,\n\n\nbathy_core30_fraxc <- x %>%\n  filter(exp_name == 'Core 30', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nbathy_core30_qpcr <- x %>%\n  filter(exp_name == 'Core 30', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\nbathy_core32_fraxc <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nbathy_core32_qpcr <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\nmbgd_core32_fraxc <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'MBG-D'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nmbgd_core32_qpcr <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'MBG-D'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\n\n\n\nDraft manuscript text:\nOur aim is to compare the growth rates for taxa with both FRAxC and qPCR values for the two sediment cores, as reported in Table 1. The first soil core included qPCR measurements of a single archaeal clade, Bathyarchaeota, for which growth rates by qPCR and FRAxC were nearly identical (doubling rates of 0.099/yr by FRAxC and 0.097/yr by qPCR). The second soil core included qPCR measurements of Bathyarchaeota and a second clade, Thermoprofundales/MBG-D. In this core, FRAxC and qPCR growth rates differed more substantially, with growth rates from FRAxC being larger by 0.012/yr for Bathyarchaeota (0.112/yr by FRAxC and 0.1/yr by qPCR) and by 0.086/yr for Thermoprofundales/MBG-D (0.294/yr by FRAxC and 0.208/yr by qPCR). A low number of experimental samples and noise in both the FRAxC and qPCR measurements place significant uncertainty in these measurements; however, the fact that FRAxC-derived growth rates are larger than qPCR-derived rates in all three cases is consistent with our hypothesis that mean efficiency decreases with depth in a manner that systematically biases FRAxC-derived rates to higher values. The differences in growth rate are small in absolute terms; however, the maximum observed difference of 0.086/yr suggests an error large enough to impact results for some taxa classified as positive growers by Lloyd et al. (2020), for which growth rates ranged between 0.04/yr and 0.5/yr. Overall, the comparison between FRAxC and qPCR measurements gives support to the study conclusions, but suggest that species at the lower end of this range of positive FRAxC-derived rates may in fact be merely persisting or even slowly declining in abundance.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-10\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n backports     1.4.1   2021-12-13 [1] CRAN (R 4.1.2)\n bit           4.0.4   2020-08-04 [1] CRAN (R 4.0.2)\n bit64         4.0.5   2020-08-30 [1] CRAN (R 4.0.2)\n bookdown      0.24    2021-09-02 [1] CRAN (R 4.1.1)\n broom         0.7.10  2021-10-31 [1] CRAN (R 4.1.2)\n bslib         0.3.1   2021-10-06 [1] CRAN (R 4.1.1)\n cachem        1.0.6   2021-08-19 [1] CRAN (R 4.1.1)\n cellranger    1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n cli           3.1.0   2021-10-27 [1] CRAN (R 4.1.1)\n colorspace    2.0-2   2021-08-11 [1] R-Forge (R 4.1.1)\n crayon        1.4.2   2021-10-29 [1] CRAN (R 4.1.1)\n DBI           1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr        2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n digest        0.6.29  2021-12-01 [1] CRAN (R 4.1.2)\n distill       1.3     2021-10-13 [1] CRAN (R 4.1.1)\n downlit       0.4.0   2021-10-29 [1] CRAN (R 4.1.2)\n dplyr       * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n evaluate      0.14    2019-05-28 [1] CRAN (R 4.0.0)\n fansi         0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.0.4)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n fs            1.5.2   2021-12-08 [1] CRAN (R 4.1.2)\n generics      0.1.1   2021-10-25 [1] CRAN (R 4.1.1)\n ggplot2     * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n glue          1.5.1   2021-11-30 [1] CRAN (R 4.1.2)\n gtable        0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n haven         2.4.3   2021-08-04 [1] CRAN (R 4.1.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n highr         0.9     2021-04-16 [1] CRAN (R 4.1.0)\n hms           1.1.1   2021-09-26 [1] CRAN (R 4.1.1)\n htmltools     0.5.2   2021-08-25 [1] CRAN (R 4.1.1)\n httr          1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite      1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n knitr         1.36    2021-09-29 [1] CRAN (R 4.1.1)\n lifecycle     1.0.1   2021-09-24 [1] CRAN (R 4.1.1)\n lubridate     1.8.0   2021-10-07 [1] CRAN (R 4.1.1)\n magrittr      2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n memoise       2.0.1   2021-11-26 [1] CRAN (R 4.1.2)\n modelr        0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n nvimcom     * 0.9-102 2021-11-12 [1] local\n pillar        1.6.4   2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp          1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n readr       * 2.1.1   2021-11-30 [1] CRAN (R 4.1.2)\n readxl        1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n reprex        2.0.1   2021-08-05 [1] CRAN (R 4.1.1)\n rlang         0.4.12  2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown   * 2.11    2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi    0.13    2020-11-12 [1] CRAN (R 4.0.3)\n rvest         1.0.2   2021-10-16 [1] CRAN (R 4.1.1)\n sass          0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n scales        1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.2)\n stringi       1.7.6   2021-11-29 [1] CRAN (R 4.1.2)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n tibble      * 3.1.6   2021-11-07 [1] CRAN (R 4.1.2)\n tidyr       * 1.1.4   2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect    1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n tzdb          0.2.0   2021-10-27 [1] CRAN (R 4.1.2)\n unpivotr    * 0.6.2   2021-08-22 [1] CRAN (R 4.1.2)\n utf8          1.2.2   2021-07-24 [1] CRAN (R 4.1.0)\n vctrs         0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n vroom         1.5.7   2021-11-30 [1] CRAN (R 4.1.2)\n withr         2.4.3   2021-11-30 [1] CRAN (R 4.1.2)\n xfun          0.28    2021-11-04 [1] CRAN (R 4.1.2)\n xml2          1.3.3   2021-11-30 [1] CRAN (R 4.1.2)\n yaml          2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLloyd, Karen G., Jordan T. Bird, Joy Buongiorno, Emily Deas, Richard Kevorkian, Talor Noordhoek, Jacob Rosalsky, and Taylor Roy. 2020. “Evidence for a Growth Zone for Deep-Subsurface Microbial Clades in Near-Surface Anoxic Sediments.” Appl. Environ. Microbiol. 86 (19): 1–15. https://doi.org/10.1128/AEM.00877-20.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-10T08:52:08-05:00",
    "input_file": "lloyd2020evi-case-study.knit.md"
  },
  {
    "path": "posts/2022-01-06-leopold2020host-original-regression-analysis/",
    "title": "Perform Leopold and Busby (2020) regression analysis with and without bias correction",
    "description": "We perform the regression analysis of Leopold and Busby (2020) with and without bias correction, finding that there is negligible impact of bias correction on the results.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-06",
    "categories": [
      "ref:leopold2020host",
      "differential abundance",
      "bias sensitivity"
    ],
    "contents": "\n\nContents\nRun analyses with and without bias correction\nCompute offsets with and without bias correction\nRun analysis with each set of offsets\n\nCompare results\nANOVA summary tables\nFull model\nRegion model\n\nSession info\n\nThis document asks whether bias correction has a significant impact on the regression analysis of Leopold and Busby (2020).\nRun analyses with and without bias correction\n\n\nlibrary(here)\n\nset.seed(42)\n\n\n\nThis script follows the analysis of code/jsdModels.R in https://github.com/dleopold/Populus_priorityEffects.\nWe start by running the setup of libraries and loading the phyloseq object and bias estimate. The code is modified from jsdModels.R to adjust working directories for reading files.\n\n\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(phyloseq)\nlibrary(mvabund)\nlibrary(gt)\n\nthis_dir <- getwd()\nsetwd(here('notebook/_data/leopold2020host/dleopold-Populus_priorityEffects-8594f7c/'))\n\nsource(\"code/Rfunctions.R\")\n\n# load phyloseq data\n(phy <- loadPhyloseq())\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 8 taxa and 247 samples ]\nsample_data() Sample Data:       [ 247 samples by 16 sample variables ]\ntax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]\nrefseq()      DNAStringSet:      [ 8 reference sequences ]\n\n# load bias correction factors - estimated from mock communities\nbias <- read.csv(\"output/tabs/bias.csv\")\n\nsetwd(this_dir)\n\n\n\nCompute offsets with and without bias correction\nBias is accounted for in the original regression analysis through the use of taxon and sample-specific offsets, stored in a matrix effort. These offsets also account for the variation in read depth across samples. To perform the analysis with and without bias correction, we therefore compute two versions of the offsets, using the estimated bias vector and a dummy bias vector where the efficiencies are all set to 1.\n\n\nbias_list <- list(\n  'Corrected' = bias, \n  'Uncorrected' = bias %>% mutate(Bhat = 1)\n)\n\n# 'effort' (offset) is calculated following jsdModels.R\neffort_fun <- function(bias, phy) {\n  (sample_sums(unbias(phy, bias)) %*% \n    t(bias$Bhat[match(taxa_names(phy), bias$Taxon)])\n  ) %>% log \n}\n\neffort_list <- bias_list %>%\n  map(effort_fun, phy = phy)\n\n\n\nThe offset calculation is done as in jsdModels.R. In section ‘Quantification and statistical analysis’), Leopold and Busby (2020) explain\n\nWe accounted for 2 sources of unequal sampling effort, variable sampling depth and the species-specific sequencing biases, by including an offset term (\\(effort\\)) for each species \\(i\\) in each sample \\(j\\), in the form: \\(effort_{ij} = \\log(bias_{i} \\times depth_{j})\\), where \\(bias_i\\) is the sequencing bias correction factor for species \\(i\\), estimated from our mock communities (see above, Estimating Sequencing Bias), and \\(depth_j\\) is the total sum of all species in sample \\(j\\), after dividing each by their species-specific sequencing bias correction factor.\n\nThe call to sample_sums(unbias(phy, bias)) returns the \\(depth_{j}\\) terms as described in this paragraph.\nTo understand why this calculation yields the correct offset, consider that under our model (and in our notation) we have \\[\\begin{align}\n  \\log \\text{reads}_i(a)\n    &= \\log \\text{prop}_i (a) +\n    \\underbrace{\\log \\left[\\frac{\\text{efficiency}_i}{\\text{efficiency}_S(a)} \\cdot \\text{reads}_S(a) \\right]}_{\\text{offset}}.\n\\end{align}\\] It can be shown with some algebra that \\[\\begin{align}\n  \\frac{\\text{reads}_S(a)}{\\text{efficiency}_S(a)} \n  = \\sum_i \\frac{\\text{reads}_i(a)}{\\text{efficiency}_i}.\n\\end{align}\\] The left-hand side is the ratio of total reads to mean efficiency of the sample \\(a\\), and the right-hand side is the \\(depth_{a}\\) of sample \\(a\\) defined by Leopold and Busby (2020). It follows that the ‘effort’ terms computed by Leopold and Busby (2020) are indeed the offsets implied by our model.\nRun analysis with each set of offsets\nWe’ll wrap the analysis from jsdModels.R in a function to call with the corrected and uncorrected ‘effort’ offsets. Toggle to see the code.\n\n\nShow code\n\nanalyze_jsd_models <- function(effort, phy, nBoot=4999) { \n  ##########################\n  ### Fit genotype model ###\n  ##########################\n\n  # Make mvabund object \n  mvDat <- otu_table(phy) %>% data.frame  %>% mvabund\n\n  # Fit joint-species model for genotype effect\n  mv.full <- manyglm(mvDat ~ Genotype*Treatment, \n                     offset=effort, \n                     family=\"negative.binomial\",\n                     data=data.frame(sample_data(phy)))\n\n  # Check model assumptions\n  #plot(mv.full)\n  #meanvar.plot(mvDat~sample_data(phy)$Treatment)\n  #meanvar.plot(mvDat~sample_data(phy)$Genotype)\n\n  # Test with anova.manyglm \n  # Using unstructured correlation matrix and wald tests.  \n  # Including univariate test with adjustment for multiple testing.  \n  mv.anova <- anova(mv.full, nBoot=nBoot, p.uni=\"adjusted\", cor.type=\"shrink\", test=\"wald\")\n  #> saveRDS(mv.anova, \"output/rds/mv.genotype.rds\")\n\n  ########################\n  ### Fit region model ###\n  ########################\n\n  #' # Fit joint-species model for genotype effect\n  mv.region <- manyglm(mvDat ~ Region*Treatment, \n                       offset=effort, \n                       family=\"negative.binomial\",\n                       data=data.frame(sample_data(phy)))\n\n  #' ## Check model assumptions\n  #plot(mv.region)\n  #meanvar.plot(mvDat~sample_data(phy)$Region)\n\n  #' ## Test with anova.manyglm \n  #+ cache=T, results='asis'\n  mv.region.anova <- anova(mv.region, nBoot=nBoot, p.uni=\"adjusted\", cor.type=\"shrink\", test=\"wald\")\n  #> saveRDS(mv.region.anova, \"output/rds/mv.region.rds\")\n\n  mv.results <- bind_cols(\n    mv.anova$table %>% \n      rownames_to_column() %>%\n      filter(rowname!='(Intercept)') %>%\n      mutate(rowname = gsub(\"Genotype\",\"Host\",rowname)),\n    mv.region.anova$table %>% \n      rownames_to_column() %>%\n      filter(rowname!='(Intercept)') %>%\n      select(-rowname),\n    # NOTE: [MRM] I set the name repair function to match the original behavior\n    .name_repair = function(x) make.unique(x, sep = '')\n  ) %>%\n    gt(rowname_col = \"rowname\") %>%\n      tab_spanner(\n        label = \"Genotype\",\n        columns = vars(Res.Df, Df.diff, wald, 'Pr(>wald)')\n      ) %>%\n      tab_spanner(\n        label = \"Ecotype\",\n        columns = vars(Res.Df1, Df.diff1, wald1, 'Pr(>wald)1')\n      ) %>%\n      fmt_number(c(4,8),\n                 decimals = 1) %>%\n      fmt(c(5,9),\n          fns = function(x) {\n            ifelse(x>=0.001,round(x,3),\"< 0.001\")\n          }) %>%\n      cols_label('Pr(>wald)'=md(\"*P*-value\"),\n                 wald=md(\"Wald-χ<sup>2<sup>\"),\n                 Res.Df=md(\"Df.resid\"),\n                 Df.diff=\"Df\",\n                 'Pr(>wald)1'=md(\"*P*-value\"),\n                 wald1=md(\"Wald-χ<sup>2<sup>\"),\n                 Res.Df1=md(\"Df.resid\"),\n                 Df.diff1=\"Df\") %>%\n      cols_move_to_start(3) %>%\n      cols_move(7,5) %>%\n      cols_align(\"center\")\n  #> gtsave(mv.results,\"output/figs/jsdModels.png\")\n\n  list(\n    mv.full = mv.full,\n    mv.anova = mv.anova,\n    mv.region = mv.region,\n    mv.region.anova = mv.region.anova,\n    mv.results = mv.results\n  )\n}\n\n\n\nFinally, we run the analysis. The call is wrapped in xfun::cache_rds() to cache the results; the hash is based on the inputs and the analysis function’s source code.\n\n\nfun_src <- attr(analyze_jsd_models, 'srcref') %>% as('character')\nres <- xfun::cache_rds({\n  effort_list %>% map(analyze_jsd_models, phy = phy)\n}, hash = list(fun_src, effort_list, phy),\n  clean = FALSE\n)\n\n\n\nCompare results\nNext we compare the results of the analysis with and without bias correction.\n\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n\n\nANOVA summary tables\nFirst, let’s compare the results summary tables.\nWith bias correction\n\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#qeayjdrzqo .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#qeayjdrzqo .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#qeayjdrzqo .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#qeayjdrzqo .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#qeayjdrzqo .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#qeayjdrzqo .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#qeayjdrzqo .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#qeayjdrzqo .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#qeayjdrzqo .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#qeayjdrzqo .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#qeayjdrzqo .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#qeayjdrzqo .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#qeayjdrzqo .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#qeayjdrzqo .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qeayjdrzqo .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qeayjdrzqo .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#qeayjdrzqo .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#qeayjdrzqo .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#qeayjdrzqo .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#qeayjdrzqo .gt_left {\n  text-align: left;\n}\n\n#qeayjdrzqo .gt_center {\n  text-align: center;\n}\n\n#qeayjdrzqo .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#qeayjdrzqo .gt_font_normal {\n  font-weight: normal;\n}\n\n#qeayjdrzqo .gt_font_bold {\n  font-weight: bold;\n}\n\n#qeayjdrzqo .gt_font_italic {\n  font-style: italic;\n}\n\n#qeayjdrzqo .gt_super {\n  font-size: 65%;\n}\n\n#qeayjdrzqo .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 65%;\n}\n\n      \n        Genotype\n      \n      \n        Ecotype\n      \n    Df\n      Df.resid\n      Wald-χ2\n      P-value\n      Df\n      Df.resid\n      Wald-χ2\n      P-value\n    Host\n11\n235\n20.1\n< 0.001\n1\n245\n12.4\n< 0.001Treatment\n4\n231\n21.8\n< 0.001\n4\n241\n21.6\n< 0.001Host:Treatment\n44\n187\n23.5\n0.038\n4\n237\n6.1\n0.298\n\nWithout bias correction\n\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#xgdyentzro .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#xgdyentzro .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#xgdyentzro .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#xgdyentzro .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#xgdyentzro .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#xgdyentzro .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#xgdyentzro .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#xgdyentzro .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#xgdyentzro .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#xgdyentzro .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#xgdyentzro .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#xgdyentzro .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#xgdyentzro .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#xgdyentzro .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xgdyentzro .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xgdyentzro .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#xgdyentzro .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#xgdyentzro .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#xgdyentzro .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#xgdyentzro .gt_left {\n  text-align: left;\n}\n\n#xgdyentzro .gt_center {\n  text-align: center;\n}\n\n#xgdyentzro .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#xgdyentzro .gt_font_normal {\n  font-weight: normal;\n}\n\n#xgdyentzro .gt_font_bold {\n  font-weight: bold;\n}\n\n#xgdyentzro .gt_font_italic {\n  font-style: italic;\n}\n\n#xgdyentzro .gt_super {\n  font-size: 65%;\n}\n\n#xgdyentzro .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 65%;\n}\n\n      \n        Genotype\n      \n      \n        Ecotype\n      \n    Df\n      Df.resid\n      Wald-χ2\n      P-value\n      Df\n      Df.resid\n      Wald-χ2\n      P-value\n    Host\n11\n235\n20.3\n< 0.001\n1\n245\n12.4\n< 0.001Treatment\n4\n231\n21.5\n< 0.001\n4\n241\n21.4\n< 0.001Host:Treatment\n44\n187\n23.5\n0.03\n4\n237\n6.2\n0.261\n\nFull model\nWith bias correction\n\n\nres[['Corrected']][['mv.full']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Genotype * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.164          0.167          0.085          0.684  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.016          0.104          0.189          0.089  \n\nDegrees of Freedom: 246 Total (i.e. Null); 187 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2279.7        -1861.5      -4056.8   -1581.0    \nResidual Deviance:    256.4          324.6        250.4     305.9    \nAIC:                 2401.7         1983.5       4178.8    1703.0    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4059.2     -2800.9       -2386.3    -4014.2  \nResidual Deviance:    247.8       250.0         256.2      251.1  \nAIC:                 4181.2      2922.9        2508.3     4136.2  \n\nWithout bias correction\n\n\nres[['Uncorrected']][['mv.full']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Genotype * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.176          0.177          0.067          0.678  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.021          0.110          0.200          0.091  \n\nDegrees of Freedom: 246 Total (i.e. Null); 187 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2296.4        -1869.7      -3997.7   -1579.4    \nResidual Deviance:    256.6          321.8        249.7     306.1    \nAIC:                 2418.4         1991.7       4119.6    1701.4    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4130.5     -2813.6       -2399.7    -4019.2  \nResidual Deviance:    247.9       250.0         256.2      251.1  \nAIC:                 4252.5      2935.6        2521.7     4141.2  \n\nLet’s compare the estimated coefficients for the various response variables.\n\n\ntidy_manyglm <- function(x) {\n  x %>% coef %>%\n    as_tibble(rownames = 'term') %>%\n    pivot_longer(-term, names_to = 'response', values_to = 'estimate')\n}\n\n\n\n\n\ncoef_ests <- res %>%\n  map('mv.full') %>%\n  map_dfr(tidy_manyglm, .id = 'type')\nx <- coef_ests %>%\n  filter(term != '(Intercept)') %>%\n  pivot_wider(names_from = type, values_from = estimate)\nmse <- x %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(2)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Non-intercept coefficients, full model', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nRegion model\nWith bias correction\n\n\nres[['Corrected']][['mv.region']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Region * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.270          0.217          0.118          1.148  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.021          0.154          0.266          0.114  \n\nDegrees of Freedom: 246 Total (i.e. Null); 237 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2398.9        -1901.2      -4140.6   -1674.6    \nResidual Deviance:    259.4          314.0        251.8     296.2    \nAIC:                 2420.9         1923.2       4162.6    1696.6    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4134.5     -2897.9       -2468.6    -4078.0  \nResidual Deviance:    247.9       252.0         257.7      251.9  \nAIC:                 4156.5      2919.9        2490.6     4100.0  \n\nWithout bias correction\n\n\nres[['Uncorrected']][['mv.region']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Region * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.287          0.229          0.093          1.142  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.028          0.165          0.280          0.117  \n\nDegrees of Freedom: 246 Total (i.e. Null); 237 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2413.6        -1909.5      -4078.9   -1673.6    \nResidual Deviance:    259.9          311.7        250.8     296.2    \nAIC:                 2435.6         1931.5       4100.9    1695.6    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4200.8     -2915.9       -2481.6    -4083.4  \nResidual Deviance:    248.1       252.4         258.1      252.0  \nAIC:                 4222.8      2937.9        2503.6     4105.4  \n\nLet’s compare the estimated coefficients for the various response variables.\n\n\ncoef_ests <- res %>%\n  map('mv.region') %>%\n  map_dfr(tidy_manyglm, .id = 'type')\nx <- coef_ests %>%\n  filter(term != '(Intercept)') %>%\n  pivot_wider(names_from = type, values_from = estimate)\nmse <- x %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(2)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Non-intercept coefficients, region model', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nBias correction has little impact on the estimated coefficients for the non-intercept terms for either model.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-06\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ────────────────────────────────────────────────────────────────────\n package          * version  date (UTC) lib source\n ade4               1.7-18   2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5      2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1    2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1    2021-12-13 [1] CRAN (R 4.1.2)\n Biobase            2.52.0   2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0   2021-05-19 [1] Bioconductor\n biomformat         1.20.0   2021-05-19 [1] Bioconductor\n Biostrings         2.60.1   2021-06-06 [1] Bioconductor\n bitops             1.0-7    2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10   2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1    2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6    2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0    2016-07-27 [1] CRAN (R 4.0.0)\n checkmate          2.0.0    2020-02-06 [1] CRAN (R 4.0.2)\n cli                3.1.0    2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2    2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18   2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2    2021-08-11 [1] R-Forge (R 4.1.1)\n commonmark         1.7      2018-12-01 [1] CRAN (R 4.0.0)\n cowplot          * 1.1.1    2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2    2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2   2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1    2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1    2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29   2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3      2021-10-13 [1] CRAN (R 4.1.1)\n downlit            0.4.0    2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7    2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2    2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14     2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0    2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0    2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0    2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1    2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1    2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2    2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1    2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1   2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6    2021-05-31 [1] Bioconductor\n ggplot2          * 3.3.5    2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.5.1    2021-11-30 [1] CRAN (R 4.1.2)\n gt               * 0.3.1    2021-08-07 [1] CRAN (R 4.1.1)\n gtable             0.3.0    2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3    2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1    2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9      2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1    2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2    2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2    2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9    2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0   2021-05-19 [1] Bioconductor\n iterators          1.0.13   2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4    2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2    2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36     2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2    2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45  2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1    2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0    2021-10-07 [1] CRAN (R 4.1.1)\n magrittr         * 2.0.1    2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54   2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4    2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1    2021-11-26 [1] CRAN (R 4.1.2)\n mgcv               1.8-38   2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8    2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0   2021-05-19 [1] Bioconductor\n munsell            0.5.0    2018-06-12 [1] CRAN (R 4.0.0)\n mvabund          * 4.1.12   2021-05-28 [1] CRAN (R 4.1.2)\n NADA               1.6-1.1  2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153  2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102  2021-11-12 [1] local\n patchwork        * 1.1.1    2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5    2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0   2021-05-19 [1] Bioconductor\n pillar             1.6.4    2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3    2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6    2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4    2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1    2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp               1.0.7    2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5 2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1    2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1    2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1    2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4    2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0   2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0    2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2   2021-07-06 [1] Bioconductor\n rlang              0.4.12   2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11     2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2    2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13     2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2    2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0   2021-05-19 [1] Bioconductor\n sass               0.4.0    2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1    2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2    2021-12-06 [1] CRAN (R 4.1.2)\n statmod            1.4.36   2021-05-10 [1] CRAN (R 4.1.0)\n stringi            1.7.6    2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0    2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13   2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6    2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4    2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1    2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1    2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8    2018-02-27 [1] CRAN (R 4.0.1)\n tweedie            2.3.3    2021-01-20 [1] CRAN (R 4.0.4)\n tzdb               0.2.0    2021-10-27 [1] CRAN (R 4.1.2)\n utf8               1.2.2    2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8    2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7    2020-11-28 [1] CRAN (R 4.0.3)\n withr              2.4.3    2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28     2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3    2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0   2021-05-19 [1] Bioconductor\n yaml               2.2.1    2020-02-01 [1] CRAN (R 4.0.0)\n zCompositions      1.3.4    2020-03-04 [1] CRAN (R 4.0.1)\n zlibbioc           1.38.0   2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n───────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-06-leopold2020host-original-regression-analysis/leopold2020host-original-regression-analysis_files/figure-html5/unnamed-chunk-9-1.svg",
    "last_modified": "2022-01-06T13:48:48-05:00",
    "input_file": "leopold2020host-original-regression-analysis.knit.md"
  },
  {
    "path": "posts/2022-01-05-leopold2020host-priority-effects/",
    "title": "Perform Leopold and Busby (2020) priority-effects analysis with and without bias correction",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-05",
    "categories": [
      "ref:leopold2020host",
      "differential abundance",
      "bias sensitivity"
    ],
    "contents": "\n\nContents\nRun analyses with and without bias correction\nCompare results\nSession info\n\nThis Rmd determines whether bias correction has an impact on the analysis of priority effects in Leopold and Busby (2020).\nRun analyses with and without bias correction\n\n\nlibrary(here)\n\nset.seed(42)\n\n\n\nhttps://github.com/dleopold/Populus_priorityEffects\nThis script follows the analysis of code/priorityEffects.R\nStart by running the setup of libraries and loading the phyloseq object and bias estimate. The code is verbatim from the Leopold and Busby (2020) code except for the changes in directory necessary for the calls to source() and file reading.\n\n\n# Analysis of the relative advantage of preemptive colonization.\n\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(phyloseq)\nlibrary(foreach)\nlibrary(doMC)\nlibrary(ggthemes)\n\nthis_dir <- getwd()\nsetwd(here('notebook/_data/leopold2020host/dleopold-Populus_priorityEffects-8594f7c/'))\n\nsource(\"code/Rfunctions.R\")\nsource(\"code/colors.R\")\n\n# register cores for parallel processing\nregisterDoMC(parallel::detectCores())\n\n# load phyloseq data\n(phy <- loadPhyloseq())\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 8 taxa and 247 samples ]\nsample_data() Sample Data:       [ 247 samples by 16 sample variables ]\ntax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]\nrefseq()      DNAStringSet:      [ 8 reference sequences ]\n\n# identify focal taxa for plotting \nfocalTaxa <- unique(sample_data(phy)$Treatment)\n\n# Extract OTU data, convert to proportions and long format\nbias <- read.csv(\"output/tabs/bias.csv\")\n\nsetwd(this_dir)\n\n\n\nNext, we wrap the analyses of the original study within a function analyze_priority_effects() to facilitate running the same analyses on the calibrated and uncalibrated profiles. The code in the function is copied verbatim from the source in code/priorityEffects.R except that the call to unbias() in the very first line is skipped so that we can control whether correction is done. Click the toggle to expand the code chunk.\n\n\nShow code\n\nanalyze_priority_effects <- function(phy, nboots = 10000) { \n  df <- phy %>%\n    transform_sample_counts(function(x){x/sum(x)}) %>%\n    otu_table %>% data.frame %>%\n    dplyr::select(all_of(focalTaxa)) %>%\n    bind_cols(sample_data(phy) %>% data.frame %>% \n                dplyr::select(Region,Genotype,Treatment)) %>%\n    pivot_longer(all_of(focalTaxa),names_to=\"Taxa\",values_to=\"proportion\") %>%\n    mutate(Focal=ifelse(Taxa==Treatment,T,F),\n           Region=ifelse(Region==\"East\",\"E\",\"W\") %>%\n             factor(levels=c(\"W\",\"E\")))\n\n  # Define a function to calculate the estimated priority effect strength for each species on each host genotype as the log-ratio of the proportional abundance when arriving early vs not arriving early\n  getPEs <- function(df) {\n    df %>% group_by(Focal,Region,Taxa,Genotype,Treatment) %>%\n      summarize_all(gm_mean) %>% ungroup %>%\n      group_by(Region,Genotype,Taxa) %>%\n      summarise(PE=log(mean(proportion[Focal])/mean(proportion[!Focal])))\n  }\n  meanPEs <- getPEs(df) \n  meanPEs$Genotype %<>% factor(.,levels=unique(.))\n\n  #####################\n  ### Bootstrap CIs ###\n  #####################\n\n  # Get bootstrap confidence intervals on point estimates of priority effects for each species on each genotype\n  # nboots <- 10000\n  bootPEs <- foreach(i=1:nboots, .combine=bind_rows) %dopar% {\n    df %>% group_by(Region, Taxa, Genotype,Focal,Treatment) %>%\n      sample_frac(replace=T) %>%\n      getPEs() %>% mutate(bootID=i)\n  }\n  bootPEs$Genotype %<>% factor(.,levels=unique(bootPEs$Genotype))\n\n  # Get bias corrected and accelerated confidence intervals\n  bootPE.ci <- bootPEs %>% \n    group_by(Genotype,Taxa) %>%\n    summarize(LCI=coxed::bca(PE)[1],\n              UCI=coxed::bca(PE)[2]) %>% full_join(meanPEs)\n\n  ###################\n  ### Region test ###\n  ###################\n\n  # First get the mean priority effect for each species on eastern and western genotypes\n  regionPEs <- meanPEs %>% group_by(Region,Taxa) %>%\n    summarize(meanPE=mean(PE),\n              tstat=t.test(PE,mu=0,alternative=\"greater\") %>% .$statistic)\n\n  # Run bootstrapped t-test using 100 bootstraps at the region level for each of the previously generated genotype-level bootstraps\n  bootRegion <- foreach(i=1:100,.combine=bind_rows) %dopar% {\n    bootPEs %>% \n      group_by(Region,Taxa,bootID) %>%\n      sample_frac(replace=T) %>%\n      left_join(regionPEs,by=c(\"Region\",\"Taxa\")) %>%\n      mutate(center=PE-meanPE) %>%\n      summarize(mu.boot=mean(PE),\n                tstat.obs=mean(tstat),\n                tstat.boot=ifelse(var(center)==0,ifelse(mean(PE)>mean(meanPE),Inf,-Inf),\n                                  t.test(center,mu=0) %>% .$statistic))}\n  # calculate bootstrapped p-values (one-tailed test for significant positive priority effects)\n  bootRegionPvals <- bootRegion %>% drop_na %>%\n    mutate(test = tstat.boot+1>tstat.obs+1) %>% \n    summarize(pval=mean(as.numeric(test))) %>%\n    mutate(stars=gtools:::stars.pval(pval) %>% gsub(\".\",\"+\",fixed = T,.)) \n  regionSig <- bootRegion %>% summarize(mu.boot.max=max(mu.boot)) %>%\n    left_join(bootRegionPvals)\n\n  ############\n  ### PLOT ###\n  ############\n\n  #' Define a function to plot the regional priority effects bootstrap results \n  get_inset <- function(df,inset.ymin,inset.ymax){\n    ggplot(df, \n           aes(x=Region,y=mu.boot)) +\n      geom_violin(scale=\"width\",fill=\"grey75\",color=\"grey75\") + \n      geom_text(data=df %>% dplyr::select(Region,Taxa,stars,mu.boot.max) %>%\n                  slice(1),\n                aes(label=stars,y=mu.boot.max),size=5)+\n      geom_hline(yintercept = 0,alpha=0.4,linetype=\"dotted\")+\n      coord_cartesian(clip='off')+\n      ylim(c(inset.ymin,inset.ymax))+\n      theme_few()+\n      theme(strip.text = element_blank(),\n            axis.title = element_blank(),\n            panel.border = element_blank(),\n            axis.line = element_line(color=\"black\",size=0.2))\n  }\n\n  # create inset plots as a list\n  insets <- bootRegion %>% \n    left_join(dplyr::select(regionSig,Region,Taxa,stars,mu.boot.max)) %>%\n    split(f = .$Taxa) %>%\n    purrr::map(~annotation_custom2(\n      grob = ggplotGrob(get_inset(.,min(bootRegion$mu.boot),max(bootRegion$mu.boot))), \n      data = data.frame(Taxa=unique(.$Taxa)),\n      ymin = 2.4, ymax=Inf, xmin=4, xmax=Inf)\n    )\n\n  # make full plot of bootstrapped priority effects results\n  plt <- ggplot(bootPE.ci,aes(x=Genotype,y=PE))+\n    geom_pointrange(aes(ymin=LCI,ymax=UCI,fill=Genotype,shape=Genotype),\n                    size=0.5,stroke=0.35,fatten=5.5)+\n    scale_shape_manual(\"Host genotype\", values=c(rep(21,7),rep(23,5)))+\n    scale_fill_manual(\"Host genotype\",values=pal.genotype)+\n    geom_hline(yintercept = 0,alpha=0.6,linetype=\"dotted\")+\n    scale_x_discrete(breaks = levels(bootPEs$Genotype),\n                     limits = c(levels(bootPEs$Genotype)[1:7], \"skip1\",\n                                levels(bootPEs$Genotype)[8:12]),\n                     expand=expansion(0.075))+\n    ylab(\"Strength of priority effect\")+\n    labs(tag=\"Eastern              Western\")+\n    coord_cartesian(clip='off')+\n    ylim(c(-1,3.5))+\n    facet_wrap(~Taxa,scales=\"free_x\",nrow=1)+\n    guides(fill = guide_legend(override.aes = list(size=0.8)))+\n    theme_few()+\n    theme(axis.title.x = element_blank(),\n          axis.text.x = element_blank(),\n          axis.ticks.x = element_blank(),\n          strip.text = element_text(size=14,face=\"italic\"),\n          axis.title.y = element_text(size=14),\n          legend.title = element_text(size=14),\n          legend.text = element_text(size=12),\n          legend.margin=margin(6,6,6,12),\n          plot.tag = element_text(angle=90,hjust=0),\n          plot.tag.position = c(0.848,0.115))+\n    insets\n  # ggsave(\"output/figs/Fig.3.pdf\",width=24,height=10,units=\"cm\")\n\n  return(\n    list(\n      meanPEs = meanPEs, \n      bootPEs = bootPEs,\n      bootPE.ci = bootPE.ci,\n      regionPEs = regionPEs,\n      bootRegion = bootRegion,\n      bootRegionPvals = bootRegionPvals,\n      plot = plt\n    )\n  )\n}\n\n\n\nNext, we run the analysis on the phyloseq objects with and without bias correction (calibration). Leopold and Busby (2020) use a custom function unbias() for bias correction, which also implements a zero-replacement procedure. In order to keep the calibrated and uncalibrated analyses comparable, we should apply the same zero-replacement procedure in both cases. We do this by applying unbias() with the supplied bias vector set to all 1s, which corresponds to no bias.\n\n\nbias_list <- list(\n  'Corrected' = bias, \n  'Uncorrected' = bias %>% mutate(Bhat = 1)\n)\nphy_list <- bias_list %>% map(~unbias(phy, .x))\n\n\n\nThe only difference between the two phyloseq objects should be a perturbation by the bias vector, which we can check by using metacal::calibrate().\n\n\ntmp <- metacal::perturb(\n  phy_list$Corrected, \n  bias %>% filter(Taxon != 'Melampsora') %>% select(Taxon, Bhat) %>% deframe,\n  norm = 'keep'\n)\nlist(phy_list$Uncorrected, tmp) %>%\n  map(otu_table) %>%\n  map(transform_sample_counts, function(x) x / sum(x)) %>%\n  {all.equal(.[[1]], .[[2]])}\n\n\n[1] TRUE\n\nThe sample totals are affected by unbias() such that they differ between the corrected and uncorrected objects,\n\n\nphy_list$Corrected %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n   13838.643    13877.175     6882.873 \n\ntmp %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n   13838.643    13877.175     6882.873 \n\nphy_list$Uncorrected %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n       24815        24599        11290 \n\nBut since the analysis function converts the counts to proportions in the first step, this difference can’t impact the results.\nFinally, we run the analysis on both the corrected and uncorrected phyloseq objects. The call is wrapped in xfun::cache_rds() to cache the results; the hash is based on the inputs and the analysis function’s source code.\n\n\nfun_src <- attr(analyze_priority_effects, 'srcref') %>% as('character')\nres <- xfun::cache_rds({\n  phy_list %>% map(analyze_priority_effects)\n}, hash = list(fun_src, phy_list, focalTaxa),\n  clean = FALSE\n)\n\n\n\nCompare results\nNext we compare the results of the analysis with and without bias correction.\n\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n\n\n\n\nres %>% names\n\n\n[1] \"Corrected\"   \"Uncorrected\"\n\nres[[1]] %>% names\n\n\n[1] \"meanPEs\"         \"bootPEs\"         \"bootPE.ci\"      \n[4] \"regionPEs\"       \"bootRegion\"      \"bootRegionPvals\"\n[7] \"plot\"           \n\nFirst, let’s compare the main text figure with and without correction,\n\n\nmap2(map(res, 'plot'), names(res), ~.x + ggtitle(.y)) %>%\n  {.[[1]]  / .[[2]]} &\n  theme(plot.title.position = 'plot')\n\n\n\n\nThe results are nearly indistinguishable; bias correction has no significant impact.\nNext, let’s compare the point estimates of the priority effects,\n\n\nx <- res %>%\n  map_dfr('meanPEs', .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = PE)\nmse <- x %>%\n  ungroup %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(3)\nx %>%\n  ggplot(aes(Uncorrected, Corrected, color = Region)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Effect of bias correction on priority-effect estimate', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nThere is very little impact on the point estimates. Now, let’s compare the bootstrap confidence intervals with and without correction,\n\n\nres %>%\n  map_dfr('bootPE.ci', .id = 'type') %>%\n  ggplot(aes(x = Genotype, y = PE, color = type, ymin = LCI, ymax =UCI)) +\n  facet_wrap(~Taxa, scales = \"fixed\", ncol = 1) +\n  geom_pointrange(position = position_dodge(width = 0.5)) +\n  scale_color_brewer(type = 'qual') +\n  theme(\n    plot.title.position = 'plot',\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  ) +\n  labs(title = 'Effect of bias correction on priority-effect CIs')\n\n\n\n\nThis fig clearly shows the equivalence of results with uncorrected and corrected taxonomic profiles.\nLet’s do similar for the regional PEs.\n\n\nx <- res %>%\n  map_dfr('regionPEs', .id = 'type') %>%\n  pivot_longer(c(meanPE, tstat)) %>%\n  pivot_wider(names_from = type)\nmse <- x %>%\n  ungroup %>%\n  filter(name == 'meanPE') %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(3)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  facet_wrap(~name, scales = 'free') +\n  # coord_fixed() + # doesn't work with free scales\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Effect of bias correction on regional priority-effect estimate', \n    subtitle = str_glue('Mean squared difference in meanPE: {mse}')\n  ) +\n  theme(plot.title.position = 'plot')\n\n\n\n\nAgain there is almost no effect, except that the largest t statistic is somewhat larger before bias correction.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-06\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ────────────────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.1     2021-06-06 [1] Bioconductor\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10     2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.0      2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n doMC             * 1.3.7      2020-10-14 [1] CRAN (R 4.1.2)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach          * 1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n ggthemes         * 4.2.4      2021-01-20 [1] CRAN (R 4.0.4)\n glue               1.5.1      2021-11-30 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9      2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators        * 1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr         * 2.0.1      2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal            0.2.0.9008 2021-10-30 [1] Github (mikemc/metacal@c1f21db)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n NADA               1.6-1.1    2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8      2018-02-27 [1] CRAN (R 4.0.1)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28       2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)\n zCompositions      1.3.4      2020-03-04 [1] CRAN (R 4.0.1)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n───────────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-05-leopold2020host-priority-effects/leopold2020host-priority-effects_files/figure-html5/unnamed-chunk-7-1.svg",
    "last_modified": "2022-01-06T09:20:37-05:00",
    "input_file": "leopold2020host-priority-effects.knit.md"
  },
  {
    "path": "posts/2021-12-15-momspi-regression-diversity/",
    "title": "MOMS-PI: Regression on diversity",
    "description": "Analyze the impact of bias on a DA analysis of relative abundances versus diversity.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-12-15",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\n\nContents\nSetup\nR setup\nMOMS-PI setup\n\nRegression analysis\nClassify samples into high and low diversity groups\nRegression setup\nLinear regression on log proportion\nAlternate zero-replacement strategy\n\nInterpretion\n\n\nSetup\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\nlibrary(here)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9008'\n\n\n\ntheme_set(theme_cowplot())\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nMOMS-PI setup\nLoad the MOMS-PI profiles and estimate bias,\n\n\nsource(here('notebook/_code/momspi-setup.R'))\n\n\n\nTo simplify interpretation of some of the regression models, let’s rarefy samples to 10K reads (we’ll be dropping some samples that are below this limit).\n\n\nmomspi_rare <- xfun::cache_rds({\n  momspi %>% \n    rarefy_even_depth(\n      sample.size = 1e4, \n      rngseed = 42,\n      replace = FALSE,\n      trimOTUs = FALSE\n    )\n  }, hash = momspi\n)\n# Make sure no taxa have 0 counts, in case this causes issues later on\nstopifnot(all(momspi_rare %>% taxa_sums > 0))\n\n\n\nLet’s also add the new sample sums and estimated mean efficiency and\n\n\nmean_eff <- momspi_rare %>%\n calibrate(bias_all_vec, norm = 'close') %>%\n perturb(bias_all_vec, norm = 'none') %>% \n sample_sums %>%\n enframe('.sample', 'mean_efficiency')\n\nmomspi_rare <- momspi_rare %>% \n  mutate_sample_data(., \n    sample_sum_original = sample_sum,\n    sample_sum = sample_sums(.),\n  ) %>%\n  left_join_sample_data(mean_eff, by = '.sample')\n\n\n\nLet’s also add the top species in each sample,\n\n\nget_top_species <- function(ps) {\n  x <- ps %>%\n    transform_sample_counts(close_elts) %>%\n    otu_table %>%\n    as_tibble(pivot = TRUE) %>%\n    with_groups(.sample, slice_max, .abundance, n = 1)\n  if (anyDuplicated(x$.sample))\n    stop('Ties present')\n  x %>% select(.sample, top_species = .otu)\n}\ntop_species <- list(\n  'obs' = momspi_rare,\n  'cal' = momspi_rare %>% calibrate(bias_all_vec)\n  ) %>%\n  map_dfr(get_top_species, .id = 'type')\ntop_species_wide <- top_species %>%\n  pivot_wider(values_from = top_species, names_from = type, \n    names_prefix = 'top_species_') \nmomspi_rare <- momspi_rare %>%\n  left_join_sample_data(top_species_wide, by = '.sample')\n\n\n\nRegression analysis\nNOTE: Consider saving output so can be used in other notebook files\nClassify samples into high and low diversity groups\nCompute Shannon and Inverse-Simpson diversity indices and add to the sample metadata. Phyloseq::estimate_richness() will complain about the lack of singletons, but we can ignore this since we aren’t using species richness estimators. I will exponentiate the Shannon index to convert it to the q1 Hill number so that (like Inverse Simpson) it has the scale of number of species.\n\n\ndiv <- list(\n  'obs' = momspi_rare,\n  'cal' = momspi_rare %>% calibrate(bias_all_vec)\n) %>%\n  map(estimate_richness, measures = c('Shannon', 'InvSimpson')) %>%\n  map_dfr(as_tibble, rownames = '.sample', .id = 'type') %>%\n  transmute(\n    .sample, type,\n    div_q1 = exp(Shannon),\n    div_q2 = InvSimpson,\n  ) %>%\n  pivot_longer(starts_with('div_'), names_to = 'index', values_to = 'diversity')\ndiv_wide <- div %>%\n  pivot_wider(values_from = diversity, names_from = c('index', 'type')) \n\n\n\n\n\np <- div_wide %>%\n  mutate(across(starts_with('div'), log2)) %>%\n  ggplot() +\n  geom_point(aes(x = .panel_x, y = .panel_y), alpha = 0.5) +\n  ggforce::geom_autodensity() +\n  geom_bin2d(aes(x = .panel_x, y = .panel_y)) +\n  ggforce::facet_matrix(vars(starts_with('div')), layer.diag = 2, layer.lower = 3)\nggrastr::rasterize(p, dpi = 300)\n\n\n\n\nThe observed (Log) order-1 and order-2 diversity show a tight correlation with each other, as do the calibrated diversities, while the correlation is much lower when comparing observed and calibrated numbers. The reason is likely that calibration will tend to increase the diversity of samples that are observed to be dominated by a high-efficiency taxon (like L. iners) and decrease the diversity of samples dominated by a low efficiency tason (like G. vaginalis).\nShannon diversity of the observed profiles is what is most often considered in vaginal microbiome studies, so let’s use this metric to partition the samples.\n\n\ndiv_wide %>%\n  ggplot(aes(x = div_q1_obs)) +\n  scale_x_log10() +\n  annotate('rect', xmin = 0, xmax = 1.5, ymin = -Inf, ymax = Inf, \n    fill = 'blue', alpha = 0.3) +\n  annotate('rect', xmin = 1.5, xmax = 3, ymin = -Inf, ymax = Inf, \n    fill = 'grey', alpha = 0.3) +\n  annotate('rect', xmin = 3, xmax = Inf, ymin = -Inf, ymax = Inf, \n    fill = 'green', alpha = 0.3) +\n  geom_histogram() +\n  geom_vline(xintercept = c(1.5, 3), color = 'black')\n\n\n\n\nI’ll pick the first mode as the ‘Low diversity’ group, treat the second mode as ‘Medium’, and the tail as ‘High’.\n\n\ndiv_wide <- div_wide %>%\n  mutate(\n    div_group = case_when(\n      div_q1_obs < 1.5 ~ 'Low',\n      div_q1_obs > 3 ~ 'High',\n      TRUE ~ 'Medium'\n    ) %>% factor(levels = c('Low', 'Medium', 'High'))\n  )\n\n\n\nRegression setup\nAdd the diversity grouping information, subset to the Low and High samples, and compute the offsets for the Gamma-Poisson model\n\n\nmomspi_div <- momspi_rare %>%\n  left_join_sample_data(div_wide, by = '.sample') %>%\n  filter_sample_data(div_group %in% c('Low', 'High')) %>%\n  mutate_sample_data(\n    gp_offset_obs = log(sample_sum),\n    gp_offset_cal = log(sample_sum) - log(mean_efficiency),\n  )\n\n\n\nWe’ll use the criterion from Fettweis et al to pick the taxa to test. Note, we may not get the same exact taxa as them since we’re using a larger set of women and ignoring the medium-diversity samples. Note, the log proportions used in the regression analysis below are with respect to the full species set.\n\n\ntaxa_to_test <- momspi_div %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~ mean(. >= 1e-2) >= 0.05 | mean(. >= 1e-3) >= 0.15) %>%\n  taxa_names %>%\n  print\n\n\n [1] \"Lachnospiraceae_BVAB1\"         \"Aerococcus_christensenii\"     \n [3] \"Atopobium_vaginae\"             \"Campylobacter_ureolyticus\"    \n [5] \"Clostridiales_BVAB2\"           \"Clostridiales_OTU22\"          \n [7] \"Coriobacteriaceae_OTU27\"       \"Corynebacterium_cluster45\"    \n [9] \"Dialister_cluster51\"           \"Dialister_micraerophilus\"     \n[11] \"Dialister_propionicifaciens\"   \"Finegoldia_magna\"             \n[13] \"Gardnerella_vaginalis\"         \"Lactobacillus_crispatus\"      \n[15] \"Lactobacillus_gasseri_cluster\" \"Lactobacillus_iners\"          \n[17] \"Lactobacillus_jensenii\"        \"Megasphaera_OTU70_type1\"      \n[19] \"Mycoplasma_hominis\"            \"Parvimonas_OTU142\"            \n[21] \"Peptoniphilus_indolicus\"       \"Prevotella_amnii\"             \n[23] \"Prevotella_bivia\"              \"Prevotella_cluster2\"          \n[25] \"Prevotella_cluster50\"          \"Prevotella_disiens\"           \n[27] \"Sneathia_amnii\"                \"Sneathia_sanguinegens\"        \n[29] \"TM7_OTU-H1\"                    \"Ureaplasma_cluster23\"         \n\nLinear regression on log proportion\nThe simple linear regression is the fastest and simplest approach, and the easiest to understand using results from the manuscript.\nFirst, we need to ensure there are no zeros. I’ll try two approaches; the first is to use a pseudocount of 0.5.\n\n\nstat_test <- function(ps, taxa) {\n  ps %>%\n    filter_sample_data(div_group %in% c('Low', 'High')) %>%\n    transform_sample_counts(close_elts) %>%\n    prune_taxa(taxa, .) %>%\n    as_tibble %>%\n    with_groups(.otu, nest) %>%\n    mutate(\n      fit = map(data,\n        ~lm(log(.abundance) ~ div_group, data = .x)\n      ),\n    ) %>%\n    select(-data)\n}\nres_div_lm <- list(\n  'Observed' = momspi_div %>% transform_sample_counts(~. + 0.5),\n  'Calibrated' = momspi_div %>% transform_sample_counts(~. + 0.5) %>%\n    calibrate(bias_all_vec)\n) %>%\n  map_dfr(stat_test, taxa = taxa_to_test, .id = 'type')\nres_div_lm_tidy <- res_div_lm %>%\n  mutate(across(fit, map, broom.mixed::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\n# x should be the outout of a tidier\nplot_estimates <- function(x) {\n  err <- x %>%\n    select(name = type, .otu, value = estimate) %>%\n    pivot_wider() %>%\n    mutate(\n      error = Observed - Calibrated,\n      error_sign = sign(Observed) == sign(Calibrated),\n      sign = case_when(\n        sign(Observed) > 0 & sign(Calibrated) > 0 ~ 'Positive',\n        sign(Observed) < 0 & sign(Calibrated) < 0 ~ 'Negative',\n        TRUE ~ 'Depends',\n      )\n    ) %>%\n    select(.otu, error_sign, sign)\n\n  p1 <- x %>%\n    left_join(err, by = '.otu') %>%\n    ggplot(aes(y = type, x = estimate, fill = sign)) +\n    scale_fill_brewer(type = 'qual', palette = 2,\n      guide = guide_legend(reverse = TRUE)) +\n    geom_vline(xintercept = 0, color = 'grey') +\n    ggdist::geom_dots() +\n    labs(fill = 'Sign of estimate', x = 'Estimated LFC', y = 'Meas. type')\n  p2 <- x %>%\n    mutate(\n      .otu_fct = fct_reorder(.otu, estimate, .fun = min) %>%\n        fct_relabel(function(x) str_replace_all(x, '_', ' '))\n    ) %>%\n    ggplot(aes(y = .otu_fct, x = estimate, color = type)) +\n    # scale_color_brewer(type = 'qual', palette = 7) +\n    colorblindr::scale_color_OkabeIto() +\n    geom_vline(xintercept = 0, color = 'grey') +\n    geom_linerange(size = 1,\n      aes(\n        xmin = estimate - 2*std.error,\n        xmax = estimate + 2*std.error\n      )) +\n    geom_point(size = 1.5) +\n    labs(y = 'Species-level OTU', x = 'Estimated LFC', color = 'Meas. type')\n  p1 / p2 +\n    plot_layout(ncol = 1, heights = c(0.3, 1)) +\n    plot_annotation(tag_levels = 'A') &\n    theme_minimal_hgrid()\n}\n\n\n\n\n\nplot_estimates(res_div_lm_tidy)\n\n\n\n\nThe data is unlikely to meet the assumptions generally considered necessary for simple linear regression. In particular, the standard errors (and confidence intervals) are likely to be much too small. Bootstrapped intervals could be used to address this issue, if we are interested in understanding the impact of bias on confidence intervals in a more realistic scenario.\nAlternate zero-replacement strategy\nLet’s also try adjust the proportions to the Dirichlet posterior mean, with the prior set to the average proportions across all samples. This amounts to a pseudocount of ntaxa times the mean (observed) proportion of the species, and so adjusts for differences in mean proportion among species.\n\n\nmomspi_div_alt <- momspi_div %>% \n  adjust_dirchlet\n\n\n\n\n\nres_div_alt_lm <- list(\n  'Observed' = momspi_div_alt,\n  'Calibrated' = momspi_div_alt %>% calibrate(bias_all_vec)\n) %>%\n  map_dfr(stat_test, taxa = taxa_to_test, .id = 'type')\nres_div_alt_lm_tidy <- res_div_alt_lm %>%\n  mutate(across(fit, map, broom.mixed::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\nplot_estimates(res_div_alt_lm_tidy)\n\n\n\n\nInterpretion\nCheck the diversity-efficiency relationship\n\n\nsam <- momspi_div %>% sample_data %>% as_tibble\nsam %>%\n  ggplot(aes(y = div_group, x = mean_efficiency)) +\n  scale_x_log10() +\n  ggdist::stat_slab()\n\n\n\n\nFrom this plot, we can see that the mean efficiency is 3-10X lower in the High diversity relative to the low diversity group.\nThe results of a linear regression analysis give us the systematic error in LFCs for the simple linear regression,\n\n\nmean_eff_lm <- lm(log(mean_efficiency) ~ div_group,\n  data = sam\n)\nmean_eff_lm %>% summary\n\n\n\nCall:\nlm(formula = log(mean_efficiency) ~ div_group, data = sam)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-3.02856 -0.24524 -0.01627  0.28631  1.61043 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   -0.34795    0.02371  -14.68   <2e-16 ***\ndiv_groupHigh -1.56081    0.03122  -50.00   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5494 on 1267 degrees of freedom\nMultiple R-squared:  0.6637,    Adjusted R-squared:  0.6634 \nF-statistic:  2500 on 1 and 1267 DF,  p-value: < 2.2e-16\n\nmean_eff_lfc <- mean_eff_lm %>% broom::tidy() %>% \n  filter(term == 'div_groupHigh') %>% pull(estimate)\n\n\n\n\n\nres_div_lm_tidy %>%\n  select(name = type, .otu, value = estimate) %>%\n  pivot_wider() %>%\n  mutate(\n    error = Observed - Calibrated,\n  ) %>%\n  pull(error) %>%\n  summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.517   1.517   1.517   1.517   1.517   1.517 \n\nmean_eff_lfc \n\n\n[1] -1.560813\n\nCan see that the errors are the same for all species, and nearly equal to the negative LFC in mean efficiency. A small difference is expected from the addition of pseudocounts for the species regression.\nTo understand why the mean efficiency is lower, can try a scatterplot of mean efficiency against diversity with samples colored by most abundant species.\n\n\ndiv1 <- div %>%\n  left_join(\n    momspi_rare %>% sample_data %>% as_tibble,\n    by = '.sample'\n  ) %>%\n  mutate(\n    top_species_plot = fct_lump_n(top_species_cal, 7)\n  )\n\n\n\n\n\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \ndiv1 %>%\n  ggplot(aes(diversity, mean_efficiency, color = top_species_plot)) +\n  facet_grid(type~index) +\n  scale_x_log10() +\n  scale_y_log10() +\n  ggrastr::rasterize(geom_point(alpha = 0.6), dpi = 300) +\n  stat_smooth(aes(group = 'none'), color = 'black') +\n  labs(color = 'Top species', x = 'Diversity', y = 'Mean efficiency') +\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-12-15-momspi-regression-diversity/momspi-regression-diversity_files/figure-html5/unnamed-chunk-7-1.svg",
    "last_modified": "2022-01-10T15:45:35-05:00",
    "input_file": "momspi-regression-diversity.knit.md"
  },
  {
    "path": "posts/2021-11-01-momspi-summary/",
    "title": "MOMS-PI: Key dynamics",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-11-01",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\n\nContents\nSetup\nR setup\nEstimate bias from Brooks et al. (2015)\nLoad the MOMSPI data\nChecks\n\nCalibrate the MOMSPI measurements\nObserved and calibrated proportions\nSample summary statistics\n\nVisual analysis of mean efficiency distribution and role of key species\nVariation in mean efficiency and individual species\nFold changes in mean efficiency\nExample community trajectory\nSession info\n\nThis document is part of a series of analyses of the impact of taxonomic bias on vaginal community dynamics in MOMSPI dataset (Fettweis et al. (2019)), using the bias estimated from the Brooks et al. (2015) mock community data. The purpose of this document is to demonstrate the key dynamics we want to highlight in the manuscript.\nSetup\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9008'\n\n\n\ntheme_set(theme_cowplot())\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nEstimate bias from Brooks et al. (2015)\nWe can estimate the efficiencies for the control species used in the cellular mocks of Brooks et al. (2015) by running the example code in the docs for metacal::estimate_bias(). This code uses the observed and actual species-level abundance tables which were produced by McLaren, Willis, and Callahan (2019) from the SI files of Brooks et al. (2015) and are included in the metacal package.\n\n\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  as(\"matrix\")\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  as(\"matrix\")\n\n# Estimate bias with bootstrapping for error estimation\nmc_fit <- estimate_bias(observed, actual, margin = 1, boot = TRUE)\nsummary(mc_fit)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 7 × 4\n  taxon                    estimate gm_mean gm_se\n  <chr>                       <dbl>   <dbl> <dbl>\n1 Atopobium_vaginae           0.285   0.285  1.04\n2 Gardnerella_vaginalis       0.160   0.159  1.05\n3 Lactobacillus_crispatus     2.29    2.29   1.03\n4 Lactobacillus_iners         4.68    4.69   1.02\n5 Prevotella_bivia            1.79    1.79   1.04\n6 Sneathia_amnii              4.59    4.60   1.04\n7 Streptococcus_agalactiae    0.250   0.250  1.03\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\nrm(actual, observed, dr)\n\n\n\n\n\ncontrol_species <- mc_fit %>% coef %>% names\ncontrol_genera <- control_species %>% str_extract('^[^_]+')\n\n\n\nLoad the MOMSPI data\nTODO: replace this code chunk with one that pulls data from the github repo into _data/\nLoad the MOMSPI Stirrups profiles into phyloseq\n\n\npath_momspi <- '~/research/momspi'\n\notu <- path(path_momspi, \"output\", \"stirrups-profiles\", \"abundance-matrix.csv.bz2\") %>%\n  read_csv(\n    col_types = cols(.default = col_double(), sample_name = col_character())\n  ) %>%\n  otu_table(taxa_are_rows = FALSE)\nsam <- path(path_momspi, \"output\", \"stirrups-profiles\", \"sample-data.csv.bz2\") %>%\n  read_csv(col_types = \"ccccccic\") %>%\n  mutate(across(host_visit_number, factor, ordered = TRUE)) %>%\n  sample_data\ntax <- path(path_momspi, \"output\", \"stirrups-profiles\", \"taxonomy.csv.bz2\") %>%\n  read_csv(col_types = cols(.default = col_character())) %>%\n  tax_table %>%\n  mutate_tax_table(\n    species = case_when(!is.na(genus) ~ .otu)\n  )\nmomspi_raw <- phyloseq(otu, sam, tax) %>%\n  mutate_tax_table(across(.otu, str_replace, \n      \"(?<=Lactobacillus_crispatus)_cluster\", \"\")) %>%\n  mutate_sample_data(., sample_sum = sample_sums(.))\ntaxa_names(momspi_raw) %>% str_subset(\"crispatus\")\n\n\n[1] \"Lactobacillus_crispatus\"       \"Lactobacillus_crispatus_type1\"\n\nstopifnot(all(control_species %in% taxa_names(momspi_raw)))\n\n\n\nL crisp type 1 is just a few reads so we can ignore it (check)\n\n\np1 <- momspi_raw %>% sample_sums %>% qplot + scale_x_log10() +\n  labs(x = 'sample sum')\np2 <- momspi_raw %>% taxa_sums %>% qplot + scale_x_log10() +\n  labs(x = 'otu sum')\np1 + p2\n\n\n\n\nLet’s filter samples with fewer than 1000 reads (also requirement used by the authors)\n\n\nmomspi <- momspi_raw %>% \n  filter_sample_data(sample_sum >= 1e3)\n\n\n\nNote, we might want to be conservative in terms of composition shifts by making the min prop of species 1e-3. However this might add up to a large effect if we apply it to all species. Could instead filter to 1e4 reads and threshold at 1e-4, or 3e-4\nLet’s see if we can filter the super-low-count species without affecting any remaining samples too much:\n\n\nx <- (momspi %>% filter_taxa2(~sum(.) >= 2e2) %>% sample_sums) / (momspi %>% sample_sums)\nsummary(x)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.99    1.00    1.00    1.00    1.00    1.00 \n\nDropping OTUs with less than 200 reads has a negligible impact on the samples, so let’s do that.\n\n\nmomspi <- momspi %>% filter_taxa2(~sum(.) >= 2e2)\n\n\n\nFinally, let’s impute zeros using the Dirichlet posterior mean, with the prior respecting the average proportions across samples.\n\n\ntaxa_mean_prop <- momspi %>%\n  otu_table %>%\n  transform_sample_counts(close_elts) %>%\n  orient_taxa(as = 'cols') %>%\n  as('matrix') %>%\n  colMeans\nstopifnot(sum(taxa_mean_prop) == 1)\nprior_vec <- taxa_mean_prop * ntaxa(momspi)\nstopifnot(identical(length(prior_vec), ntaxa(momspi)))\n# Note the need for the seq_along trick to get phyloseq to allow this\n# adjustment\nmomspi <- momspi %>% transform_sample_counts(~ prior_vec[seq_along(.x)] + .x)\n\n\n\nChecks\nhow many subjects?\n\n\ncts <- momspi %>% sample_data %>% as_tibble %>% count(host_subject_id)\nnrow(cts)\n\n\n[1] 577\n\nhow does the number of visits vary by subject?\n\n\ncts %>% pull(n) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    2.00    3.00    3.39    4.00    9.00 \n\ncts %>%\n  ggplot(aes(x = n)) +\n  geom_histogram(binwidth = 1)\n\n\n\n\nCalibrate the MOMSPI measurements\nOwing to the large sample size of the mock community experiment, the standard errors in the estimated bias for the control species are quite small, and our uncertainty in the true bias of the MOMSPI study is much larger than what these standard errors imply. Therefore I will use the point estimate of the bias for the control species as if it were known exactly, but we should consider this to just be a hypothesis of what the bias truly is in the MOMSPI study. This hypothetical nature applies even more strongly when we extrapolate to other species.\nSince don’t have a way to directly estimate the efficiencies of the other OTUs, we’ll impute them as follows.\nSet the efficiencies of the 7 control species to the directly estimated values\nCompute efficiencies for the 6 control genera to the efficiency of the control species (if only one) or the geometric mean efficiency (if more than one; here this is just Lactobacillus)\nUse these genera-level efficiencies for the efficiencies of OTUs that are not control species but are in the same genus as one\nFor other OTUs, use the geometric mean of the genera efficiencies; this is similar to using the mean of the 7 control species but gives Lactobacillus equal weight to the other genera.\n\n\nbias_species <- coef(mc_fit) %>% \n  enframe(\"species\", \"efficiency\") %>%\n  print\n\n\n# A tibble: 7 × 2\n  species                  efficiency\n  <chr>                         <dbl>\n1 Atopobium_vaginae             0.285\n2 Gardnerella_vaginalis         0.160\n3 Lactobacillus_crispatus       2.29 \n4 Lactobacillus_iners           4.68 \n5 Prevotella_bivia              1.79 \n6 Sneathia_amnii                4.59 \n7 Streptococcus_agalactiae      0.250\n\nbias_genus <- bias_species %>%\n  mutate(genus = str_extract(species, \"^[^_]+\"), .before = 1) %>%\n  with_groups(genus, summarize, across(efficiency, gm_mean)) %>%\n  print\n\n\n# A tibble: 6 × 2\n  genus         efficiency\n  <chr>              <dbl>\n1 Atopobium          0.285\n2 Gardnerella        0.160\n3 Lactobacillus      3.27 \n4 Prevotella         1.79 \n5 Sneathia           4.59 \n6 Streptococcus      0.250\n\n# Match on genus or species, depending on which is available; then set others\n# to average genus efficiency\nbias_all <- tax_table(momspi) %>% as_tibble %>%\n  left_join(bias_species, by = \"species\") %>%\n  left_join(bias_genus, by = \"genus\") %>%\n  mutate(\n    efficiency = case_when(\n      !is.na(efficiency.x) ~ efficiency.x,\n      !is.na(efficiency.y) ~ efficiency.y,\n      TRUE ~ gm_mean(bias_genus$efficiency)\n    )\n  ) %>%\n  select(-efficiency.x, -efficiency.y) %>%\n  # standardize to L. iners, the most efficiently measured\n  mutate(\n    across(efficiency, ~ . / max(.))\n  ) %>%\n  glimpse\n\n\nRows: 282\nColumns: 10\n$ .otu       <chr> \"Clostridiaceae_1_OTU17\", \"Lachnospiraceae_BVAB1\"…\n$ domain     <chr> NA, NA, NA, NA, NA, NA, \"Bacteria\", \"Bacteria\", \"…\n$ phylum     <chr> NA, NA, NA, NA, NA, NA, \"Firmicutes\", \"Firmicutes…\n$ class      <chr> NA, NA, NA, NA, NA, NA, \"Bacilli\", \"Clostridia\", …\n$ order      <chr> NA, NA, NA, NA, NA, NA, \"Lactobacillales\", \"Clost…\n$ family     <chr> NA, NA, NA, NA, NA, NA, \"Aerococcaceae\", \"Veillon…\n$ genus      <chr> NA, NA, NA, NA, NA, NA, \"Abiotrophia\", \"Acidamino…\n$ control    <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ species    <chr> NA, NA, NA, NA, NA, NA, \"Abiotrophia_defectiva\", …\n$ efficiency <dbl> 0.175212, 0.175212, 0.175212, 0.175212, 0.175212,…\n\nbias_all_vec <- bias_all %>% select(.otu, efficiency) %>% deframe \n\n\n\nObserved and calibrated proportions\nCompute observed and calibrated proportions with all taxa.\n\n\nmomspi_obs <- momspi %>% \n  transform_sample_counts(close_elts)\n# note, calibrate() automatically subsets to just the focal taxa if we haven't\n# already\nmomspi_cal <- momspi_obs %>% calibrate(bias_all_vec)\n\n\n\nSample summary statistics\nMean efficiencies\nMost abundant species\nProportion of Lactobacillus \nTo compute the mean efficiencies, we can use metacal::perturb() to multiply efficiencies by the actual proportions for each sample (using norm = \"none\" to avoid renormalizing the results), then summing up the values from each sample with phyloseq::sample_sums(). It’s also useful to get the mean efficiency among just the control species.\n\n\ntmp1 <- momspi_cal %>%\n  perturb(bias_all_vec, norm = \"none\") %>% \n  sample_sums %>%\n  enframe('.sample', 'mean_efficiency')\ntmp2 <- momspi_cal %>%\n  filter_tax_table(.otu %in% control_species) %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(bias_species %>% deframe, norm = \"none\") %>% \n  sample_sums %>%\n  enframe('.sample', 'mean_efficiency_controls')\nmean_eff <- left_join(tmp1, tmp2, by = '.sample')\n\n\n\nFor each sample, let’s get the most abundant species in the calibrated and uncalibrated profiles.\n\n\nget_top_species <- function(ps) {\n  x <- ps %>%\n    otu_table %>%\n    as_tibble(pivot = TRUE) %>%\n    with_groups(.sample, slice_max, .abundance, n = 1) %>%\n    # add count to check for ties\n    add_count(.sample)\n  if (anyDuplicated(x$.sample))\n    stop('Ties present')\n  x %>% select(.sample, .otu, .abundance)\n}\ntop_species <- list(\n  Uncalibrated = momspi_obs,\n  Calibrated = momspi_cal\n  ) %>%\n  map_dfr(get_top_species, .id = 'type')\n\n\n\nWhich species tend to be dominant?\n\n\ntop_species %>%\n  filter(type == 'Uncalibrated') %>%\n  count(.otu) %>%\n  arrange(desc(n)) %>%\n  print(n=20)\n\n\n# A tibble: 53 × 2\n   .otu                                     n\n   <chr>                                <int>\n 1 Lactobacillus_iners                    779\n 2 Lactobacillus_crispatus                425\n 3 Lachnospiraceae_BVAB1                  238\n 4 Gardnerella_vaginalis                  137\n 5 Lactobacillus_gasseri_cluster           68\n 6 Prevotella_cluster2                     53\n 7 Atopobium_vaginae                       52\n 8 Lactobacillus_jensenii                  50\n 9 Sneathia_amnii                          23\n10 Prevotella_bivia                        16\n11 Streptococcus_cluster29                 16\n12 Mycoplasma_girerdii                     11\n13 Mycoplasma_hominis                       6\n14 Corynebacterium_cluster58                5\n15 Lactobacillus_delbrueckii                5\n16 Bifidobacterium_longum_infantis_suis     4\n17 Finegoldia_magna                         4\n18 Prevotella_disiens                       4\n19 Staphylococcus_cluster47                 4\n20 Streptococcus_agalactiae                 4\n# … with 33 more rows\n\n\n\ntop_species %>%\n  filter(type == 'Calibrated') %>%\n  count(.otu) %>%\n  arrange(desc(n)) %>%\n  print(n=20)\n\n\n# A tibble: 60 × 2\n   .otu                              n\n   <chr>                         <int>\n 1 Gardnerella_vaginalis           525\n 2 Lactobacillus_iners             491\n 3 Lactobacillus_crispatus         386\n 4 Lachnospiraceae_BVAB1           183\n 5 Atopobium_vaginae                63\n 6 Lactobacillus_jensenii           51\n 7 Lactobacillus_gasseri_cluster    45\n 8 Streptococcus_cluster29          28\n 9 Streptococcus_anginosus          20\n10 Prevotella_cluster2              16\n11 Mycoplasma_girerdii              15\n12 Streptococcus_agalactiae         11\n13 Finegoldia_magna                  9\n14 Ureaplasma_cluster23              9\n15 Corynebacterium_cluster58         7\n16 Mycoplasma_hominis                7\n17 Clostridiales_OTU22               5\n18 Lactobacillus_delbrueckii         5\n19 Prevotella_bivia                  5\n20 Anaerococcus_OTU147               4\n# … with 40 more rows\n\nThe most important species/OTU that we do not have direct bias information on at the species or genus level is Lachnospiraceae BVAB1.\nThe proportion of Lactobacillus in each sample - will simply do all control genera.\n\n\ngenus_prop <- momspi_cal %>%\n  subset_taxa(genus %in% control_genera) %>%\n  tax_glom('genus') %>%\n  as_tibble %>%\n  select(.sample, genus, .abundance) %>%\n  pivot_wider(names_from = genus, values_from = .abundance)\n\n\n\nLet’s join the most abundant species and key genera proportions to the mean efficiecies for further analysis. For plotting, we’ll create a version of the top taxa that only colors the taxa that are most often dominant.\n\n\ntmp <- top_species %>% \n  select(-.abundance) %>% \n  pivot_wider(names_from = type, values_from = .otu, \n    names_glue = 'top_{str_to_lower(type)}')\nmean_eff1 <- mean_eff %>%\n  left_join(sample_data(momspi_cal) %>% as_tibble, by = '.sample') %>%\n  left_join(genus_prop, by = '.sample') %>%\n  left_join(tmp, by = '.sample') %>%\n  mutate(\n    top_plot = fct_lump_n(top_calibrated, 7)\n  )\nrm(tmp)\n\n\n\nVisual analysis of mean efficiency distribution and role of key species\nWe can make a plot similar to that used for the Leopold et al analysis.\n\n\n# First let's look at the distribution of mean efficiencies\np1 <- mean_eff1 %>%\n  ggplot(aes(mean_efficiency, fill = top_plot)) +\n  geom_histogram() +\n  # annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  expand_limits(x = range(bias_all_vec)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = 'Most abundant species'\n  )\n# Next let's plot Lactobacillus proportion against mean efficiency, as another\n  # look at the relationship between Lacto and mean efficiency.\np2 <- mean_eff1 %>%\n  ggplot(aes(mean_efficiency, Lactobacillus, color = top_plot)) +\n  geom_point() +\n  scale_x_log10() +\n  expand_limits(x = range(bias_all_vec)) +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.03, 0.1, 0.3, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Lactobacillus proportion\",\n    x = \"Mean efficiency\",\n    color = 'Most abundant species'\n  )\n\n\n\n\n\n# The yellow makes the L crispatus points a bit hard to see, so let's swap it's\n# color with the rarer L. gasseri in the final figure.\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \n(p1 + ggtitle(\"Distribution of sample mean efficiencies\")) / \n  (p2 + \n    ggtitle(\"Lactobacillus proportion vs. mean efficiency\") + \n    theme(legend.position = 'none')\n  ) +\n  plot_annotation(tag_levels = \"A\") +\n  plot_layout(guides = 'collect') &\n  scale_fill_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  ) &\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n# The x-axis is very close but not completely aligned; I think I need to\n# manually set the x limits to get perfect alignment, but that leads to some\n# samples being dropped in the histogram plot; some investigation is needed\n# to go that route.\n\n\n\nThis plot shows that Lactobacillus dominance drives a bimodal distribution in the mean efficiencies, and that Gardnerella dominance drives the low end. Note that the ‘other’ and ‘BVAB1’ dominated samples are lumped around the middle because of our assumption in imputing the efficiencies.\nFor the caption/methods: Note that the most abundant species is that inferred from the calibrated data; could just say that the calibrated data is treated as the actual composition.\nThe Lacto proportion doesn’t seem that much more illuminating than the histogram colored by dominant species, so let’s make a version with just that for the manuscript.\n\n\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \np1 + \n#  ggtitle(\"Distribution of sample mean efficiencies\") +\n  scale_fill_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  ) +\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n\nVariation in mean efficiency and individual species\n\n\nfocal_taxa <- momspi %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~ mean(. >= 1e-2) >= 0.05 | mean(. >= 1e-3) >= 0.15) %>%\n  taxa_names %>%\n  print\n\n\n [1] \"Lachnospiraceae_BVAB1\"         \"Aerococcus_christensenii\"     \n [3] \"Atopobium_vaginae\"             \"Campylobacter_ureolyticus\"    \n [5] \"Clostridiales_BVAB2\"           \"Coriobacteriaceae_OTU27\"      \n [7] \"Corynebacterium_cluster45\"     \"Dialister_cluster51\"          \n [9] \"Dialister_micraerophilus\"      \"Dialister_propionicifaciens\"  \n[11] \"Finegoldia_magna\"              \"Gardnerella_vaginalis\"        \n[13] \"Lactobacillus_crispatus\"       \"Lactobacillus_gasseri_cluster\"\n[15] \"Lactobacillus_iners\"           \"Lactobacillus_jensenii\"       \n[17] \"Megasphaera_OTU70_type1\"       \"Mycoplasma_hominis\"           \n[19] \"Parvimonas_OTU142\"             \"Peptoniphilus_indolicus\"      \n[21] \"Prevotella_amnii\"              \"Prevotella_bivia\"             \n[23] \"Prevotella_cluster2\"           \"Prevotella_cluster50\"         \n[25] \"Prevotella_disiens\"            \"Sneathia_amnii\"               \n[27] \"Sneathia_sanguinegens\"         \"Staphylococcus_cluster47\"     \n[29] \"TM7_OTU-H1\"                    \"Ureaplasma_cluster23\"         \n\n\n\nx <- momspi_cal %>%\n  transform_sample_counts(close_elts) %>%\n  filter_tax_table(.otu %in% focal_taxa) %>%\n  as_tibble\n\n\n\n\n\ntaxa_summary <- x %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(.otu, summarize,\n    across(.abundance, \n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  )\ntaxa_summary %>% arrange(-mean) %>% print(n=Inf)\n\n\n# A tibble: 30 × 5\n   .otu                            mean median    sd   var\n   <chr>                          <dbl>  <dbl> <dbl> <dbl>\n 1 Gardnerella_vaginalis          -2.81  -2.82  1.90  3.60\n 2 Lactobacillus_iners            -3.85  -3.88  2.72  7.41\n 3 Atopobium_vaginae              -4.77  -5.15  1.97  3.86\n 4 Lachnospiraceae_BVAB1          -5.64  -6.31  2.35  5.54\n 5 Lactobacillus_crispatus        -5.75  -6.85  3.18 10.1 \n 6 Prevotella_cluster2            -6.18  -6.42  2.06  4.24\n 7 Megasphaera_OTU70_type1        -6.57  -7.38  2.35  5.53\n 8 Ureaplasma_cluster23           -7.17  -7.62  2.55  6.50\n 9 Dialister_micraerophilus       -7.39  -7.28  2.00  3.99\n10 Finegoldia_magna               -7.40  -7.64  2.33  5.45\n11 Lactobacillus_jensenii         -7.42  -8.31  2.93  8.59\n12 Dialister_cluster51            -7.65  -7.95  2.10  4.40\n13 Corynebacterium_cluster45      -7.96  -8.08  2.44  5.95\n14 Lactobacillus_gasseri_cluster  -8.01  -8.65  2.60  6.74\n15 Aerococcus_christensenii       -8.11  -8.33  2.14  4.58\n16 Prevotella_bivia               -8.12  -8.46  2.24  5.03\n17 Staphylococcus_cluster47       -8.31  -8.52  2.42  5.88\n18 Peptoniphilus_indolicus        -8.36  -8.72  2.33  5.42\n19 Coriobacteriaceae_OTU27        -8.40  -8.96  2.17  4.71\n20 Mycoplasma_hominis             -8.79  -9.21  2.05  4.21\n21 Clostridiales_BVAB2            -8.86  -9.40  2.10  4.42\n22 Dialister_propionicifaciens    -8.90  -9.30  2.41  5.80\n23 Campylobacter_ureolyticus      -8.91  -9.39  2.34  5.50\n24 TM7_OTU-H1                     -9.02  -9.44  2.13  4.55\n25 Sneathia_amnii                 -9.13  -9.66  2.11  4.45\n26 Prevotella_disiens             -9.23  -9.71  2.27  5.15\n27 Parvimonas_OTU142              -9.32  -9.99  2.27  5.17\n28 Prevotella_amnii               -9.43  -9.92  2.09  4.38\n29 Prevotella_cluster50           -9.82 -10.3   2.18  4.76\n30 Sneathia_sanguinegens         -10.3  -10.8   2.12  4.50\n\n\n\nme_summary <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  summarize(\n    across(mean_efficiency,\n      .fns = c(sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.892 0.796\n\nThe mean efficiency has a smaller dispersion than individual species, but it is of a similar magnitude, so there is still potential for it to have a substantial impact.\nWhat about variation within women?\n\n\ntaxa_summary_within <- x %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(c(.otu, host_subject_id), summarize,\n    across(.abundance,\n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3) %>%\n  with_groups(.otu, summarize,\n    sd_mean = sd(mean),\n    mean_sd = mean(sd)\n  )\ntaxa_summary_within %>% print(n=Inf)\n\n\n# A tibble: 30 × 3\n   .otu                          sd_mean mean_sd\n   <chr>                           <dbl>   <dbl>\n 1 Aerococcus_christensenii         1.67    1.37\n 2 Atopobium_vaginae                1.51    1.23\n 3 Campylobacter_ureolyticus        1.79    1.55\n 4 Clostridiales_BVAB2              1.55    1.39\n 5 Coriobacteriaceae_OTU27          1.67    1.36\n 6 Corynebacterium_cluster45        1.76    1.72\n 7 Dialister_cluster51              1.58    1.42\n 8 Dialister_micraerophilus         1.46    1.43\n 9 Dialister_propionicifaciens      1.83    1.63\n10 Finegoldia_magna                 1.74    1.60\n11 Gardnerella_vaginalis            1.57    1.07\n12 Lachnospiraceae_BVAB1            1.87    1.39\n13 Lactobacillus_crispatus          2.89    1.18\n14 Lactobacillus_gasseri_cluster    2.17    1.33\n15 Lactobacillus_iners              2.25    1.45\n16 Lactobacillus_jensenii           2.47    1.41\n17 Megasphaera_OTU70_type1          1.92    1.32\n18 Mycoplasma_hominis               1.52    1.36\n19 Parvimonas_OTU142                1.69    1.48\n20 Peptoniphilus_indolicus          1.71    1.67\n21 Prevotella_amnii                 1.48    1.40\n22 Prevotella_bivia                 1.57    1.63\n23 Prevotella_cluster2              1.48    1.47\n24 Prevotella_cluster50             1.60    1.53\n25 Prevotella_disiens               1.67    1.58\n26 Sneathia_amnii                   1.56    1.36\n27 Sneathia_sanguinegens            1.58    1.39\n28 Staphylococcus_cluster47         1.76    1.71\n29 TM7_OTU-H1                       1.63    1.29\n30 Ureaplasma_cluster23             1.97    1.57\n\n\n\nme_summary_within <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  with_groups(host_subject_id, summarize,\n    across(mean_efficiency,\n      .fns = c(mean = mean, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3) %>%\n  summarize(\n    sd_mean = sd(mean),\n    mean_sd = mean(sd)\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n  sd_mean mean_sd\n    <dbl>   <dbl>\n1   0.715   0.485\n\nNote, a better way to do this would perhaps be to use anova / linear modeling, or whatever method from those would properly weight the number of samples from each woman.\nwhat about the variation between the first samples from each woman?\n\n\ntaxa_summary_first <- x %>%\n  with_groups(host_subject_id, slice_min, host_visit_number, n = 1) %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(.otu, summarize,\n    across(.abundance,\n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  )\ntaxa_summary_first %>% arrange(-mean) %>% print(n=Inf)\n\n\n# A tibble: 30 × 5\n   .otu                            mean median    sd   var\n   <chr>                          <dbl>  <dbl> <dbl> <dbl>\n 1 Gardnerella_vaginalis          -2.62  -2.49  1.89  3.57\n 2 Lactobacillus_iners            -3.87  -4.04  2.74  7.50\n 3 Atopobium_vaginae              -4.54  -4.87  2.01  4.05\n 4 Lachnospiraceae_BVAB1          -5.58  -6.16  2.42  5.87\n 5 Lactobacillus_crispatus        -5.86  -6.88  3.24 10.5 \n 6 Prevotella_cluster2            -6.33  -6.65  2.05  4.21\n 7 Megasphaera_OTU70_type1        -6.51  -7.06  2.29  5.24\n 8 Ureaplasma_cluster23           -7.20  -7.66  2.49  6.19\n 9 Dialister_micraerophilus       -7.46  -7.39  1.98  3.93\n10 Dialister_cluster51            -7.62  -7.92  2.15  4.62\n11 Lactobacillus_jensenii         -7.66  -8.45  2.90  8.43\n12 Finegoldia_magna               -7.87  -8.16  2.21  4.90\n13 Aerococcus_christensenii       -8.01  -8.18  2.17  4.69\n14 Coriobacteriaceae_OTU27        -8.14  -8.65  2.29  5.26\n15 Lactobacillus_gasseri_cluster  -8.24  -8.76  2.64  6.98\n16 Prevotella_bivia               -8.37  -8.73  2.18  4.77\n17 Corynebacterium_cluster45      -8.47  -8.69  2.36  5.55\n18 Mycoplasma_hominis             -8.56  -8.92  2.22  4.92\n19 Staphylococcus_cluster47       -8.59  -8.91  2.38  5.65\n20 Clostridiales_BVAB2            -8.65  -9.17  2.20  4.85\n21 Peptoniphilus_indolicus        -8.74  -9.12  2.18  4.77\n22 Sneathia_amnii                 -8.97  -9.47  2.12  4.50\n23 TM7_OTU-H1                     -9.04  -9.39  2.21  4.88\n24 Parvimonas_OTU142              -9.11  -9.76  2.34  5.49\n25 Prevotella_amnii               -9.30  -9.79  2.18  4.74\n26 Campylobacter_ureolyticus      -9.30  -9.79  2.26  5.09\n27 Dialister_propionicifaciens    -9.40  -9.77  2.29  5.25\n28 Prevotella_disiens             -9.53  -9.85  2.15  4.61\n29 Prevotella_cluster50          -10.1  -10.4   2.09  4.35\n30 Sneathia_sanguinegens         -10.1  -10.6   2.15  4.63\n\n# taxa_summary %>% arrange(-mean) %>% print(n=Inf)\n\n\n\nThese sd’s are similar to the overall sds, which makes sense given most pairwise comparisons are between women.\n\n\nme_summary_first <- mean_eff1 %>%\n  with_groups(host_subject_id, slice_min, host_visit_number, n = 1) %>%\n  mutate(across(mean_efficiency, log)) %>%\n  summarize(\n    across(mean_efficiency,\n      .fns = c(sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.956 0.914\n\nme_summary\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.892 0.796\n\nThis is somewhat larger, but again similar.\nTentative: We see that the (log-e) mean efficiency sd is around 0.9, while the sd of individual taxa ranges from 2-3.5 (between women and overall). Within women, the mean efficiency sd and that of individual taxa are both smaller, such that the relative importance of each seems similar.\nVisualize, for the first sample from each woman:\n\n\nbind_rows(\n  x, \n  mean_eff1 %>% mutate(.otu = 'Mean efficiency', .abundance = mean_efficiency)\n) %>%\n  with_groups(c(.otu, host_subject_id), slice_min, host_visit_number, n = 1) %>%\n  mutate(\n    across(.abundance, log),\n    across(.otu, fct_reorder, .abundance)\n  ) %>%\n  ggplot(aes(y = .otu, x = .abundance)) +\n  ggdist::stat_slab()\n\n\n\n\nFold changes in mean efficiency\nHow often do shifts in the mean efficiency occur within a single subject? How often do shifts from Lacto to non-Lacto dominance occur within a single subject? How often do shifts from Lacto to Gardnerella dominance occur within a single subject?\nLet’s start by computing the pairwise changes in the sample mean efficiency between consecutive samples within women, and between the first samples of different women (first samples only to limit the number of sample pairs).\nSince we may be missing some host visits, let’s create a new host visit number that has no gaps:\n\n\nmean_eff2 <- mean_eff1 %>%\n  with_groups(host_subject_id, mutate, \n    host_visit_rank = rank(host_visit_number))\n\n\n\n\n\ntb <- crossing(\n  sample.1 = mean_eff2$.sample, \n  sample.2 = mean_eff2$.sample\n  ) %>%\n  left_join(mean_eff2, by = c(sample.1 = '.sample')) %>%\n  left_join(mean_eff2, by = c(sample.2 = '.sample'), suffix = c('.1', '.2')) %>%\n  mutate(\n    comparison_type = case_when(\n      host_subject_id.1 == host_subject_id.2 & host_visit_rank.2 == host_visit_rank.1 + 1 ~ \n        'Between consecutive visits',\n      host_subject_id.1 != host_subject_id.2 & host_visit_rank.2 == 1 & host_visit_rank.1 == 1 ~\n        \"Between subjects' first visits\"\n    )\n  ) %>%\n  filter(!is.na(comparison_type)) %>%\n  mutate(\n    switch_class = case_when(\n      top_plot.1 == top_plot.2 ~ 'No change',\n      str_detect(top_plot.1, 'Gardnerella') & str_detect(top_plot.2, 'Lactobacillus') ~ 'Gard. to Lacto.',\n      str_detect(top_plot.1, 'Lactobacillus') & str_detect(top_plot.2, 'Gardnerella') ~ 'Lacto. to Gard.',\n      str_detect(top_plot.1, 'Lactobacillus') & str_detect(top_plot.2, 'Lactobacillus') ~ 'Lacto. to Lacto.',\n      TRUE ~ 'Other',\n    )\n  )\n\n# tb_within <- tb %>%\n#   filter(host_subject_id.1 == host_subject_id.2, host_visit_rank.2 == host_visit_rank.1 + 1)\n# tb_between <- tb %>%\n#   filter(host_subject_id.1 != host_subject_id.2, host_visit_rank.2 == 1, host_visit_rank.1 == 1)\n\n\n\nLet’s look at the distribution of FCs in mean efficiency, coloring by whether there is a shift in dominant species.\n\n\ntb %>%\n  ggplot(aes(mean_efficiency.2 / mean_efficiency.1, fill = switch_class)) +\n  facet_wrap(~comparison_type, ncol = 1, scales = 'free_y') +\n  geom_histogram() +\n  scale_x_log10() +\n  # expand_limits(x = range(bias_all_vec)) +\n  labs(\n    x = \"Fold change in mean efficiency\", \n    y = \"Number of sample pairs\",\n    fill = 'Change in most\\nabundant species'\n  ) +\n  scale_fill_brewer(type = 'qual', palette = 3)\n\n\n\n\nUnsurprisingly, shifts in the mean efficiency tend to be larger between different subjects. Note, the between-subject panel is perfectly symmetric, but the consecutive-visits panel is not.\n\n\ntb %>%\n  count(comparison_type, switch_class) %>%\n  with_groups(comparison_type, mutate, prop = close_elts(n)) %>%\n  knitr::kable(digits = 3)\n\n\ncomparison_type\nswitch_class\nn\nprop\nBetween consecutive visits\nGard. to Lacto.\n61\n0.044\nBetween consecutive visits\nLacto. to Gard.\n63\n0.046\nBetween consecutive visits\nLacto. to Lacto.\n51\n0.037\nBetween consecutive visits\nNo change\n829\n0.601\nBetween consecutive visits\nOther\n375\n0.272\nBetween subjects’ first visits\nGard. to Lacto.\n50750\n0.153\nBetween subjects’ first visits\nLacto. to Gard.\n50750\n0.153\nBetween subjects’ first visits\nLacto. to Lacto.\n50046\n0.151\nBetween subjects’ first visits\nNo change\n68572\n0.206\nBetween subjects’ first visits\nOther\n112234\n0.338\n\nExample community trajectory\nPick a woman with multiple visits and a large change in mean efficiency to illustrate the potential impact of bias on species trajectories. We expect large changes in efficiency to be drive by changes in dominance from Gard to Lactobacillus (or vice versa).\nTo pick a woman, let’s first examine the distribution of geometric standard deviations of mean efficiency across subjects, and pick a subject at the upper end who has multiple visits.\n\n\nme <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  with_groups(host_subject_id, summarize,\n    across(mean_efficiency,\n      .fns = c(mean = mean, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3)\n\n\n\n\n\nme %>% slice_max(sd, n = 10)\n\n\n# A tibble: 10 × 5\n   host_subject_id   mean    sd   var     n\n   <chr>            <dbl> <dbl> <dbl> <int>\n 1 EP591995        -1.03   1.48  2.18     3\n 2 EP996091        -1.03   1.45  2.11     3\n 3 EP418446        -1.17   1.44  2.08     3\n 4 EP972345        -1.09   1.42  2.03     3\n 5 EP694022        -1.30   1.39  1.94     3\n 6 EP974070        -0.970  1.38  1.90     3\n 7 EP280575        -1.59   1.35  1.81     5\n 8 EP174763        -1.80   1.33  1.76     3\n 9 EP292135        -1.50   1.26  1.58     3\n10 EP438714        -1.57   1.25  1.56     3\n\nLet’s pick subject ‘EP280575’, who has the most visits within the top 10.\n\n\nsid <- 'EP280575'\nps_obs <- momspi %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~max(.) > 1e-3)\nps_cal <- momspi_cal %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(taxa_names(ps_obs), .)\nx <- list(Calibrated = ps_cal, Observed = ps_obs) %>%\n  map_dfr(as_tibble, .id = \"type\") %>%\n  mutate(across(.otu, fct_relabel, function(x) str_replace_all(x, '_', ' ')))\n\n\n\n\n\ntaxa_to_plot <- x %>% \n  filter(type == 'Calibrated') %>%\n  with_groups(.otu, summarize, \n    med = median(log10(.abundance)),\n    max = max(log10(.abundance)),\n  ) %>%\n  filter(max > -2.5) %>%\n  arrange(-max) %>%\n  pull(.otu) %>%\n  print\n\n\n [1] Lactobacillus iners                    \n [2] Gardnerella vaginalis                  \n [3] Lachnospiraceae BVAB1                  \n [4] Atopobium vaginae                      \n [5] Ureaplasma cluster23                   \n [6] Enterobacteriaceae cluster31           \n [7] Megasphaera OTU70 type1                \n [8] Finegoldia magna                       \n [9] Lactobacillus gasseri cluster          \n[10] Prevotella cluster2                    \n[11] Coriobacteriaceae OTU27                \n[12] Clostridiales BVAB2                    \n[13] Corynebacterium cluster45              \n[14] Prevotella amnii                       \n[15] Dialister cluster51                    \n[16] Prevotellaceae OTU61                   \n[17] Corynebacterium imitans lipophiloflavum\n25 Levels: Aerococcus christensenii ... Ureaplasma cluster23\n\nx %>%\n  filter(.otu %in% taxa_to_plot) %>%\n  mutate(.otu = factor(.otu, taxa_to_plot)) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\n\n\n\n\nFor the final plot, I’ll pick the most abundant 3 taxa (which are driving the mean efficiency) and two more taxa that show the different behaviors.\n\n\ntaxa_to_plot <- c(\n  'Gardnerella_vaginalis', 'Lachnospiraceae_BVAB1', 'Lactobacillus_iners',\n  'Ureaplasma_cluster23', 'Megasphaera_OTU70_type1') %>%\n  str_replace_all('_', ' ')\np_sp <- x %>%\n  filter(.otu %in% taxa_to_plot) %>%\n  mutate(.otu = factor(.otu, taxa_to_plot)) %>%\n  filter(as.integer(.otu) <= 6) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\np_me <- mean_eff1 %>%\n  filter(host_subject_id == sid) %>%\n  ggplot(aes(host_visit_number, mean_efficiency)) +\n  scale_y_log10() +\n  labs(y = 'Efficiency', title = 'Mean efficiency') +\n  geom_line(aes(group = 1))\np_me / p_sp &\n  annotate('rect', xmin = 3, xmax = 4, ymin = Inf, ymax = 0, alpha = 0.1) &\n  labs(x = 'Host visit') &\n  plot_layout(heights = c(0.1, 1)) &\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nFor comparison, let’s also look at a long trajectory where there is no major change in mean efficiency.\n\n\nme %>% slice_min(sd, n = 10)\n\n\n# A tibble: 10 × 5\n   host_subject_id    mean      sd        var     n\n   <chr>             <dbl>   <dbl>      <dbl> <int>\n 1 EP090829        -0.0318 0.00244 0.00000595     3\n 2 EP853831        -0.374  0.00544 0.0000296      4\n 3 EP733790        -0.395  0.00555 0.0000308      4\n 4 EP495882        -0.373  0.00567 0.0000321      3\n 5 EP646235        -0.373  0.00665 0.0000443      4\n 6 EP131838        -0.0920 0.00805 0.0000648      3\n 7 EP573960        -0.378  0.0145  0.000211       3\n 8 EP694646        -0.379  0.0165  0.000273       5\n 9 EP494740        -0.0644 0.0172  0.000296       4\n10 EP205465        -0.0468 0.0176  0.000309       4\n\n\n\nsid <- 'EP694646'\n\nps_obs <- momspi %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~max(.) > 1e-3)\nps_cal <- momspi_cal %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(taxa_names(ps_obs), .)\nx <- list(Calibrated = ps_cal, Observed = ps_obs) %>%\n  map_dfr(as_tibble, .id = \"type\") %>%\n  mutate(across(.otu, fct_relabel, function(x) str_replace_all(x, '_', ' ')))\nntaxa(ps_obs)\n\n\n[1] 6\n\n\n\np_sp <- x %>%\n  mutate(.otu = fct_reorder(.otu, -.abundance)) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\np_me <- mean_eff1 %>%\n  filter(host_subject_id == sid) %>%\n  ggplot(aes(host_visit_number, mean_efficiency)) +\n  scale_y_log10() +\n  labs(y = 'Efficiency', title = 'Mean efficiency') +\n  geom_line(aes(group = 1))\np_me / p_sp &\n  labs(x = 'Host visit') &\n  plot_layout(heights = c(0.1, 1)) &\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nNote that the variation in mean efficiency is very small.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-11\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.1     2021-06-06 [1] Bioconductor\n bit                4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64              4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10     2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.0      2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional     0.2.2      2021-02-02 [1] CRAN (R 4.0.4)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs               * 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist             3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.5.1      2021-11-30 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9      2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9008 2021-10-30 [1] Github (mikemc/metacal@c1f21db)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom              1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28       2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nBrooks, J Paul, David J Edwards, Michael D Harwich, Maria C Rivera, Jennifer M Fettweis, Myrna G Serrano, Robert A Reris, et al. 2015. “The truth about metagenomics: quantifying and counteracting bias in 16S rRNA studies.” BMC Microbiol. BioMed Central. https://doi.org/10.1186/s12866-015-0351-6.\n\n\nFettweis, Jennifer M., Myrna G. Serrano, Jamie Paul Brooks, David J. Edwards, Philippe H. Girerd, Hardik I. Parikh, Bernice Huang, et al. 2019. “The vaginal microbiome and preterm birth.” Nat. Med. 25 (6): 1012–21. https://doi.org/10.1038/s41591-019-0450-2.\n\n\nMcLaren, Michael R, Amy D Willis, and Benjamin J Callahan. 2019. “Consistent and correctable bias in metagenomic sequencing experiments.” Elife 8 (September): 46923. https://doi.org/10.7554/eLife.46923.\n\n\n\n\n",
    "preview": "posts/2021-11-01-momspi-summary/momspi-summary_files/figure-html5/unnamed-chunk-4-1.svg",
    "last_modified": "2022-01-11T14:54:57-05:00",
    "input_file": "momspi-summary.knit.md"
  },
  {
    "path": "posts/2021-10-27-illustrate-the-problem/",
    "title": "Illustrate the basic problem",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-27",
    "categories": [
      "ref:brooks2015thet",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nR setup\nBrooks et al\nSetup\nPlots\n\nLeopold and Busby 2020\nSetup\nPlots\n\nSession info\n\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\nBrooks et al\nSetup\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nLoad data from the cellular mock communities of Brooks et al 2015 from metacal,\n\n\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n\n\nNote that the single-species samples present.\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nPlots\nIdea is to focus on a single species and show that the error in log proportions is inconsistent, and therefore there is error in the fold changes. L. crispatus is a species MM and BC commonly use to illustrate the inconsistent error, as since it has an intermediate efficiency, we see its error varying in sign/direction. However, the errors in fold changes don’t depend on this aspect, but only the variation in mean efficiency, and is therefore the same for all species.\nData frame for comparing measured and actual proportions:\n\n\nbrooks_prop <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nbrooks_fc <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\n\n\nset.seed(42)\nspecies <- 'Lactobacillus_crispatus'\n\nsamples <- actual %>%\n  as_tibble %>%\n  filter(.otu == species, .abundance > 0) %>%\n  pull(.sample)\n\np1 <- brooks_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- brooks_fc %>%\n  filter(.otu == species, sample1 %in% samples, sample2 %in% samples) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n# p2\n\n\n\n\n\n(p1 + labs(x = 'Actual', y = 'Measured', title = 'Proportion')) + \n  (p2 + labs(x = 'Actual', y = 'Measured', title = 'Fold change')) + \n  plot_annotation(tag_levels = 'A')\n\n\n\n\nLeopold and Busby 2020\nThis dataset is for DNA mocks rather than cellular mocks; however the magnitude of bias is similar. This dataset has a couple advantages for illustration purposes:\nEach species has a wider range of actual proportions than in the Brooks dataset.\nThe ratios between species varies, whereas in the Brooks dataset it is always 1:1. \nSetup\n\n\n## From the metacal 2.0 tutorial\n# Download data from https://zenodo.org/record/3872145\ndata_path <- here::here(\"notebook/_data\", \"leopold2020host\")\n# To use a temporary directory:\n# data_path <- file.path(tempdir(), \"leopold2020\")\nif (!dir.exists(data_path)) {\n  dir.create(data_path, recursive = TRUE)\n  download.file(\n    \"https://zenodo.org/record/3872145/files/dleopold/Populus_priorityEffects-v1.2.zip\",\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\")\n  )\n  unzip(\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\"), \n    exdir = data_path\n  )\n}\n#> The microbiome data is stored in a phyloseq object,\nps <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/output/compiled/phy.rds\") %>%\n  readRDS\n\nsample_data(ps) <- sample_data(ps) %>%\n  transform(\n    Timepoint = factor(Timepoint)\n  )\n\nmock_actual <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/data/MockCommunities.csv\") %>%\n  read.csv(row.names = 1) %>%\n  select(-Sym4) %>%\n  as(\"matrix\") %>%\n  otu_table(taxa_are_rows = FALSE) %>%\n  transform_sample_counts(function(x) close_elts(1 / x))\nmock_taxa <- taxa_names(mock_actual)\nsam <- sample_data(ps) %>% as(\"data.frame\") %>% as_tibble(rownames = \"Sample\")\ntax <- tax_table(ps) %>% as(\"matrix\") %>% as_tibble(rownames = \"Taxon\")\nps.mock <- ps %>% \n  subset_samples(Samp_type == \"Mock\") %>%\n  prune_taxa(mock_taxa, .)\nleopold_actual <- mock_actual\nleopold_observed <- ps.mock %>% otu_table\nrm(mock_actual, mock_taxa, sam, tax, ps.mock)\n\n\n\nPlots\n\n\nleopold_prop <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nleopold_fc <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\nNote, in this case all species are (nominally) in all samples, but that Epicoccum is observed in 0 reads in one sample.\n\n\nspecies <- 'Cladosporium'\n# species <- 'Alternaria'\n# species <- 'Trichoderma'\n\np1 <- leopold_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- leopold_fc %>%\n  filter(.otu == species) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\np1 + p2\n\n\n\n\nSame but for the ratios between two species:\n\n\nx <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'taxa', filter = FALSE)\n\nleopold_ratio <- x %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  filter(otu1 != otu2)\n\nleopold_ratio_fc <- x %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(otu1 != otu2, sample1 != sample2)\n\n\n\n\n\nspecies1 <- 'Cladosporium'\nspecies2 <- 'Fusarium'\n# species2 <- 'Melampsora'\n# species <- 'Trichoderma'\n\np3 <- leopold_ratio %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual ratio', y = 'Measured ratio', color = 'Species') +\n  theme(legend.position = 'none')\np4 <- leopold_ratio_fc %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\n(p1 + p2) / (p3 + p4)\n\n\n\n\nNote, the ratio-view isn’t always obviously better; e.g. when Mel is involved; perhaps because of noise?\nTo make things more directly comparable, it might be best to use faceting and to fix the axes to have the same span.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.1 (2021-08-10)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-10-27                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.1     2021-06-06 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n bookdown           0.24       2021-09-02 [1] CRAN (R 4.1.1)                   \n broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                   \n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                   \n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                \n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                   \n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs               * 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)                   \n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                   \n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.7      2021-10-15 [1] CRAN (R 4.1.1)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                   \n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                   \n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                   \n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                   \n metacal          * 0.2.0.9005 2021-10-04 [1] Github (mikemc/metacal@773cbf3)  \n mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                   \n nvimcom          * 0.9-102    2021-10-25 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)                   \n readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                     \n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)                   \n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                   \n tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                   \n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.27       2021-10-18 [1] CRAN (R 4.1.1)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-10-27-illustrate-the-problem/illustrate-the-problem_files/figure-html5/brooks_lcrisp_prop_and_fc-1.svg",
    "last_modified": "2021-10-27T06:28:34-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-25-brooks2015thet-calibration/",
    "title": "Illustrate calibration types in the mock communities from Brooks et al (2015)",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-25",
    "categories": [
      "ref:brooks2015thet"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\n\n\n# Load data from the cellular mock communities of Brooks et al 2015\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n# Estimate bias with bootstrapping for error estimation\nmc_fit <- estimate_bias(observed, actual, boot = TRUE)\ncontrol_species <- mc_fit %>% coef %>% names\nsummary(mc_fit)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 7 × 4\n  taxon                    estimate gm_mean gm_se\n  <chr>                       <dbl>   <dbl> <dbl>\n1 Atopobium_vaginae           0.285   0.285  1.04\n2 Gardnerella_vaginalis       0.160   0.160  1.05\n3 Lactobacillus_crispatus     2.29    2.29   1.03\n4 Lactobacillus_iners         4.68    4.69   1.02\n5 Prevotella_bivia            1.79    1.78   1.04\n6 Sneathia_amnii              4.59    4.59   1.04\n7 Streptococcus_agalactiae    0.250   0.250  1.03\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\nare the single-species samples present?\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nYes.\nCalibration\nCalibration from community control\nDemonstrate that calibration using a single mock community can create a substantial improvement.\n\n\nsmpls <- actual %>%\n  as_tibble %>%\n  with_groups(.sample, summarize, n_species = sum(.abundance > 0)) %>%\n  filter(n_species == 7) %>%\n  pull(.sample)\n\n\n\n\n\ncontrol_samples <- smpls[1]\nbias_from_control <- estimate_bias(\n  observed %>% prune_samples(control_samples, .),\n  actual %>% prune_samples(control_samples, .),\n  ) %>%\n  coef\ncalibrated <- calibrate(observed, bias_from_control)\n\n\n\nCalibration using a reference species\nOne way to do this is to get the correction for each pair of samples, then join it with the table from previous. Another is to make the calibrated OTU table, then redo the pairwise ratio stuff.\nBasic Idea: Multiply the ratio of focal to ref species by the true proportion of the ref. One way to achieve this with phyloseq objects is to construct the correction matrix, then multiply this by the observed proportions\n\n\nref_species <- 'Lactobacillus_crispatus'\n\nref_actual <- actual %>% prune_taxa(ref_species, .) %>% c\nref_observed <- observed %>% prune_taxa(ref_species, .) %>% c\n\ncorrection_matrix <- matrix(\n  ref_actual / ref_observed, \n  nrow = nsamples(observed), ncol= ntaxa(observed),\n  byrow = FALSE\n)\n\ncalibrated_ref <- otu_table(observed * correction_matrix, taxa_are_rows = FALSE)\n\n\n\nPlot comparing calibrated and uncalibrated fold changes\n\n\nx <- list(\n  Actual = actual, \n  Uncalibrated = observed %>% transform_sample_counts(close_elts),\n  Calibrated_community = calibrated,\n  Calibrated_reference = calibrated_ref\n  ) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type')\n\n\n\n\n\nlvls <- mc_fit %>% coef %>% sort %>% names\n\nbrooks2015_fcs <- x %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  pivot_longer(contains('calibrated'), \n    names_to = 'type', values_to = 'Measured'\n  ) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2) %>%\n  mutate(\n    across(type, fct_relevel, 'Uncalibrated'),\n    across(\n      type, fct_recode,\n      'Calibrated (community)' = 'Calibrated_community',\n      'Calibrated (reference)' = 'Calibrated_reference'\n      ),\n    across(.otu, factor, levels = rev(lvls)),\n    # across(.otu, fct_relabel, adjust_species_names)\n  )\n\n\n\nCheck on number of rows in these data frames,\n\n\n# expected in 'x'\nn1 <- observed %>% nsamples %>% print\n\n\n[1] 80\n\nn2 <- observed %>% ntaxa\nall.equal(n1 * n1 * n2 * 4, x %>% nrow)\n\n\n[1] TRUE\n\nx %>% nrow\n\n\n[1] 179200\n\nbrooks2015_fcs %>% nrow\n\n\n[1] 17586\n\nLet’s plot just the sample-pairs with L. crispatus present, so that the same samples are shown in all panels.\n\n\n# Find subset of pairs to plot\nsample_pairs <- brooks2015_fcs %>%\n  filter(is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  select(sample1, sample2) %>%\n  unite(pair, sample1, sample2) %>%\n  distinct %>%\n  pull(pair)\n\n# Species labels\nspecies_label <- function(species) {\n  species %>%\n    str_replace('(?<=^[A-Z])[a-z]+_', '. ')\n}\nspecies_label(lvls)\n\n\n[1] \"G. vaginalis\"  \"S. agalactiae\" \"A. vaginae\"    \"P. bivia\"     \n[5] \"L. crispatus\"  \"S. amnii\"      \"L. iners\"     \n\np <- brooks2015_fcs %>%\n  unite(pair, sample1, sample2) %>%\n  filter(pair %in% sample_pairs, is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(\n    values = colors_brooks, \n    labels = species_label(colors_brooks %>% names)\n  ) +\n  facet_wrap(~type) +\n  scale_x_log10() +\n  scale_y_custom +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(), alpha = 0.5) +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'bottom')\np\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-10-25-brooks2015thet-calibration/brooks2015thet-calibration_files/figure-html5/brooks2015thet_fc_calibration-1.png",
    "last_modified": "2021-10-27T05:15:19-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-18-evaluate-robustness-example/",
    "title": "Evaluate robustness example",
    "description": "Evaluate the robustness of an estimate and inference to bias.",
    "author": [
      {
        "name": "Amy D. Willis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "bias sensitivity",
      "ref:callahan2017repl"
    ],
    "contents": "\n\nContents\nRobustness of an analysis to bias\nExample: relative abundance of Gardnerella\n\nData setup\nSession info\n\nRobustness of an analysis to bias\nWe can investigate the sensitivity of any analysis to taxonomic bias by simulating possible efficiency vectors, calibrating our observed MGS measurements by these efficiencies, and rerunning our analysis on the simulated and calibrated data. Specifically, we can take the observed proportion of each species in our dataset \\(\\hat{\\text{prop}}_{i}(a)\\), and “undo” the efficiencies to obtain the calibrated proportions \\[\\begin{align}\n  \\text{calibrated prop}_{i}(a)\n  &= \\left( \\frac{\\hat{\\text{prop}}_{i}(a)}{\\text{efficiency}_{i}} \\right) \\bigg / \\sum_{i'} \\left( \\frac{\\hat{\\text{prop}}_{i'}(a)}{\\text{efficiency}_{i'}} \\right),\n\\end{align}\\] and the calibrated read counts \\[\\begin{align}\n  \\text{reads}_{i}(a)\n  &= \\text{total reads}(a) \\times \\text{calibrated prop}_{i}(a).\n\\end{align}\\] We can then rerun our data analysis using the calibrated read counts in place of our original data. If we do this repeatedly, each time using different realizations of the efficiency vector, we can investigate how the results of our analysis change. If the change is minimal, this suggests that our results are robust to unequal detection efficiencies in the different species. The converse would suggest that we need to be careful interpreting our results.\nExample: relative abundance of Gardnerella\nWe illustrate this method using vaginal microbiome data from pregnant women published in a study by Callahan et al. (2017) seeking to replicate associations of specific genera (Lactobacillus, Gardnerella, and Ureaplasma) with preterm birth in two cohorts. For example, suppose we are interested in investigating if the genus Gardnerella is more abundant in the vaginal microbiome of women who give birth preterm, and we investigate this model by running corncob using preterm birth as a covariate in the mean and dispersion model. We could investigate the robustness of our findings using the following structure:\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n\nIn brief, this approach uses the library simulator to generate random efficiencies and “undo” them as described above, then runs corncob on these generated datasets before finally obtaining the estimated coefficients on preterm birth and the p-value for the hypothesis test that the coefficient on preterm birth is zero. Let’s take a look at the components of the code.\nFirst, we load the relevant libraries and our data (see Data setup),\n\n\n# library(here)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(speedyseq)\nlibrary(corncob)\n# devtools::install_github(\"jacobbien/simulator\")\nlibrary(simulator)\ncal <- readRDS(\n  here::here(\"notebook/_data\", \"callahan2017repl\", \"callahan2017repl_phyloseq_clean.rds\")\n)\n\n\n\nThen we can create the function that generates random efficiencies and accordingly alters the observed counts:\n\n\nundo_efficiencies <- function(ps, sig_sq_e) {\n\n  ps_ms <- ps %>% group_by(.sample) %>% mutate(mm = sum(.abundance)) %>% ungroup\n  ps_tax <- ps %>% select(`.otu`, `kingdom`:`species`) %>% distinct %>% tax_table\n  ps_sample <- ps %>% select(`.sample`, `subject_id`:`outcome`) %>% distinct %>% sample_data\n\n  new_model(name = \"eff_undo\", label = sprintf(\"sig_sq_e = %s\", sig_sq_e),\n            params = list(ps_ms = ps_ms, ps_tax = ps_tax, ps_sample = ps_sample, sig_sq_e = sig_sq_e),\n            simulate = function(ps_ms, ps_tax, ps_sample, sig_sq_e, nsim) {\n              replicate(nsim,\n                        {\n                          effs_tib <- ps_ms %>%\n                            select(genus) %>% distinct %>%\n                            mutate(\"efficiency\" = rnorm(nrow(.), mean = 0, sd = sqrt(sig_sq_e)) %>% exp)\n\n                          ps_tib <- ps_ms %>%\n                            full_join(effs_tib) %>%\n                            group_by(.sample) %>%\n                            mutate(p_ijs = (.abundance / efficiency) / sum(.abundance / efficiency)) %>%\n                            mutate(w_ij = round(mm * p_ijs)) %>%\n                            ungroup\n\n                          phyloseq(ps_tib %>%\n                                     select(`.otu`, `.sample`, `w_ij`) %>%\n                                     pivot_wider(names_from=`.otu`, values_from=`w_ij`) %>%\n                                     otu_table(taxa_are_rows = F),\n                                   ps_tax,\n                                   ps_sample) %>%\n                            tax_glom(\"genus\")\n                        },\n                        simplify=F)\n            })\n}\n\n\n\nNext, we specify how we use our data to construct our estimates. We are using bbdml from the library corncob to model the relative abundance of ASV 8 (Gardnerella) using preterm birth as a covariate to model the mean and dispersion, but this is only one type of analysis that we might be interested in.\n\n\ncorncob_Gardnerella <- new_method(\"corncob\", \"Corncob\",\n                               method = function(model, draw) {\n\n                                 fit <- bbdml(formula = ASV8 ~ preterm,\n                                              formula_null= ~1,\n                                              phi.formula= ~ preterm,\n                                              phi.formula_null= ~1,\n                                              data = draw %>%\n                                                merge_samples2(\"subject_id\", fun_otu = sum))\n\n                                 list(fit = fit,\n                                      summary = summary(fit))\n                               })\n\n\n\nFinally, we construct methods to obtain the estimated coefficient on preterm birth in the mean relative abundance model, and its p-value.\n\n\nbetahat_fit <- new_metric(\"betahat\", \"beta-hat\",\n metric = function(model, out) {\n   out$summary$coefficients[2,1]\n })\npvalue_fit <- new_metric(\"pvalue\", \"p-value\",\n                         metric = function(model, out) {\n                           out$summary$coefficients[2,4]\n                         })\n\n\n\nNow that we have all of the pieces, we can run them together as follows. The below code runs 100 simulations split across 4 cores; for testing, the commented code runs just 4 iterations.\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  # simulate_from_model(nsim = 4, index = 1) %>%\n  # run_method(list(corncob_Gardnerella)) %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/model.Rdata\n#> ..Simulated 25 draws in 6.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r1.Rdata\n#> ..Simulated 25 draws in 5.37 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r2.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r3.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r4.Rdata\n#> ..Simulated 25 draws in 8.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r1.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r2.Rdata\n#> ..Simulated 25 draws in 6.43 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r3.Rdata\n#> ..Simulated 25 draws in 6.47 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r4.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r1.Rdata\n#> ..Simulated 25 draws in 6.77 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r2.Rdata\n#> ..Simulated 25 draws in 5.97 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r3.Rdata\n#> ..Simulated 25 draws in 6.62 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r4.Rdata\n#> ..Simulated 25 draws in 7.09 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r1.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r2.Rdata\n#> ..Simulated 25 draws in 6.12 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r3.Rdata\n#> ..Simulated 25 draws in 5.89 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r4.Rdata\n#> ..Simulated 25 draws in 5.66 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r1.Rdata\n#> ..Simulated 25 draws in 5.49 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r2.Rdata\n#> ..Simulated 25 draws in 5.31 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r3.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r4.Rdata\n#> ..Simulated 25 draws in 5.67 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r1.Rdata\n#> ..Simulated 25 draws in 6.16 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r2.Rdata\n#> ..Simulated 25 draws in 5.3 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r3.Rdata\n#> ..Simulated 25 draws in 5.54 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r4.Rdata\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n\nHere’s how the estimated coefficient on preterm birth changes under different draws from a distribution given by \\(\\text{efficiency}_{i} \\overset{iid}{\\sim} \\text{LogNormal}(0, \\sigma^2_e)\\), and how the p-value for testing the null hypothesis that the coefficient on preterm birth is zero:\n\n\nev_df <- our_sim %>% evals %>% as.data.frame\nmodel_df <- our_sim %>% model %>% as.data.frame\nev_with_model_params <- dplyr::right_join(model_df, ev_df, by = c(\"name\" = \"Model\")) %>% tibble\nf_names <- list('p-value' = \"p-value\",\n                'beta-hat' = expression(hat(beta)))\nf_labeller <- function(variable, value){return(f_names[value])}\n\n\n\n\n\nev_with_model_params %>%\n  pivot_longer(cols = betahat:pvalue, names_to=\"eval\") %>%\n  mutate(eval = ifelse(eval == \"pvalue\", \"p-value\", \"beta-hat\")) %>%\n  ggplot(aes(x = sig_sq_e, group = sig_sq_e, y = value)) +\n  geom_boxplot() +\n  geom_abline(aes(slope = slope, intercept = intercept), color = \"blue\",\n              tibble(eval = c(\"p-value\", \"beta-hat\"), slope = c(0,0), intercept = c(0.05, 0))) +\n  xlab(expression(sigma[e]^2)) +\n  # ggtitle(\"Corncob results for testing\\nH0: Mean Gardnerella relative abundance is equal for preterm & full-term\") +\n  facet_wrap(~eval, scales=\"free_y\", nrow = 2, labeller = f_labeller) +\n  ylab(\"\") +\n  cowplot::theme_cowplot()\n\n\n\n\nWhile the estimate of the coefficient does not change on average, we see more variation in its estimate as the variation in the efficiencies increases. For some realizations from a model with large variation in the efficiencies, we even see a change in the sign of \\(\\hat{\\beta}\\) from positive to negative. Furthermore, we see a corresponding increase in the range of p-values, suggesting that more variation in the efficiencies can lead to either deattenuated estimates (larger p-values) or more precise non-zero estimates (smaller p-values).\nA major advantage of this approach is that any distribution of efficiency vectors can be investigated. For example, we could specifically investigate how Gardnerella being low- or high-efficiency impacts our results. We could also investigate more sophisticated distributions for the efficiencies, such as correlated efficiencies across phylogeny.\nData setup\nThe following code was used to download and prepare the data from Callahan et al. (2017) for analysis; it is not evaluated when this document is knit. The first code chunk downloads the ASV abundance matrix, sample metadata, and taxonomy assignments for the vaginal samples.\n\n\nlibrary(tidyverse)\nlibrary(speedyseq)\n\n# Download --------------------------------------------------------------------\ndl_path <- here::here(\"notebook/_data\", \"callahan2017repl\")\nlink <- \"https://stacks.stanford.edu/file/druid:yb681vm1809/RepRefine_Scripts.tar.gz\"\nif (!dir.exists(dl_path)) {\n  dir.create(dl_path)\n  download.file(link, file.path(dl_path, basename(link)))\n  system2(\"tar\", args = c(\"-xvf\", file.path(dl_path, basename(link)), \"-C\", dl_path))\n}\nload(file.path(dl_path, \"RepRefine_Scripts\", \"input\", \"processed.rda\"))\n# This loads:\n# df: the sample metadata\n# st: the sequence table (in counts)\n# ft: the sequence table normalized to frequencies / proportions\n# tax: taxonomy assignment matrix\n# \n# To confirm relationship between ft and st, run \n# all.equal(ft, st %>% apply(1, function(x) x / sum(x)) %>% t)\n# \n# The taxonomy matrix has an extra column with a duplicate name of \"Species\"\n# that is all NAs, so let's remove that\ntax <- tax[, -8]\n# Import into phyloseq --------------------------------------------------------\nsam <- sample_data(df)\nst <- otu_table(st, taxa_are_rows = FALSE)\ntax <- tax_table(tax)\nps <- phyloseq(sam, st, tax)\n# Check that all samples and taxa made it into the phyloseq object\nstopifnot(all.equal(colnames(st), taxa_names(ps)))\nstopifnot(all.equal(rownames(sam), sample_names(ps)))\n# Add ASV sequences to the refseq() slot\nseqs <- taxa_names(ps) %>% rlang::set_names() %>% Biostrings::DNAStringSet()\nps <- merge_phyloseq(ps, seqs)\n# Rename the ASVs to simpler names (ASV1, ASV2, ...). The full sequences remain\n# in `refseq(ps)`.\ntaxa_names(ps) <- paste0(\"ASV\", seq(ntaxa(ps)))\n# Clean up objects\nrm(tax, df, sam, st, ft, seqs)\n\n\n\nNext, we use munging functions from janitor and speedyseq to select the metadata of primary interest, standardize format of column names, and convert categorical variables to factors.\n\n\nps1 <- ps %>% \n  select_sample_data(SubjectID, Cohort, Race, preterm, Outcome) %>%\n  rename_with_sample_data(janitor::make_clean_names) %>%\n  rename_with_tax_table(janitor::make_clean_names) %>%\n  mutate_sample_data(\n    across(c(subject_id, cohort, race, outcome), factor),\n  )\n\n\n\nFinally, we save the phyloseq object for use in the analysis.\n\n\nsaveRDS(ps1, file.path(dl_path, \"callahan2017repl_phyloseq_clean.rds\"))\nrm(ps, ps1)\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.1 (2021-08-10)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-10-25                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package          * version    date       lib source                              \n#>  ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                      \n#>  ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                      \n#>  assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                      \n#>  backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  Biobase            2.52.0     2021-05-19 [1] Bioconductor                        \n#>  BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                        \n#>  biomformat         1.20.0     2021-05-19 [1] Bioconductor                        \n#>  Biostrings         2.60.1     2021-06-06 [1] Bioconductor                        \n#>  bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                      \n#>  bookdown           0.22       2021-04-22 [1] CRAN (R 4.1.0)                      \n#>  broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                      \n#>  bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                      \n#>  cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                      \n#>  cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                      \n#>  cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                      \n#>  codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                      \n#>  colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                   \n#>  corncob          * 0.2.0      2021-03-11 [1] CRAN (R 4.0.5)                      \n#>  cowplot            1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)   \n#>  crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                      \n#>  data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                      \n#>  dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                      \n#>  digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                      \n#>  distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                      \n#>  downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                      \n#>  dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                      \n#>  ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                      \n#>  fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                      \n#>  farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                      \n#>  fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                      \n#>  forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                      \n#>  foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                      \n#>  generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                      \n#>  GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                        \n#>  GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                        \n#>  ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                      \n#>  glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                      \n#>  gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                      \n#>  haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                      \n#>  here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                      \n#>  highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                      \n#>  hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                      \n#>  httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                      \n#>  igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                      \n#>  IRanges            2.26.0     2021-05-19 [1] Bioconductor                        \n#>  iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                      \n#>  jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                      \n#>  labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                      \n#>  lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                      \n#>  lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                      \n#>  lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                      \n#>  magrittr         * 2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                      \n#>  MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                      \n#>  Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                      \n#>  multtest           2.48.0     2021-05-19 [1] Bioconductor                        \n#>  munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                      \n#>  nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                      \n#>  nvimcom          * 0.9-102    2021-10-25 [1] local                               \n#>  permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                      \n#>  phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                        \n#>  pillar             1.6.3      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                      \n#>  plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                      \n#>  purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                      \n#>  R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                      \n#>  Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                      \n#>  RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                      \n#>  readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                      \n#>  reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                      \n#>  reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                      \n#>  rhdf5              2.36.0     2021-05-19 [1] Bioconductor                        \n#>  rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                        \n#>  Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                        \n#>  rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                      \n#>  rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                      \n#>  rvest              1.0.1      2021-07-26 [1] CRAN (R 4.1.0)                      \n#>  S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                        \n#>  sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                      \n#>  scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                      \n#>  sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                      \n#>  simulator        * 0.2.3      2021-10-25 [1] Github (jacobbien/simulator@aef35ab)\n#>  speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)   \n#>  stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                      \n#>  stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                      \n#>  survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                      \n#>  tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                      \n#>  tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                      \n#>  tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                      \n#>  utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                      \n#>  vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                      \n#>  withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                      \n#>  xfun               0.26       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                      \n#>  XVector            0.32.0     2021-05-19 [1] Bioconductor                        \n#>  yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                      \n#>  zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                        \n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\nCallahan, Benjamin J, Daniel B DiGiulio, Daniela S Aliaga Goltsman, Christine L Sun, Elizabeth K Costello, Pratheepa Jeganathan, Joseph R Biggio, et al. 2017. “Replication and refinement of a vaginal microbial signature of preterm birth in two racially distinct cohorts of US women.” Proc. Natl. Acad. Sci. U. S. A. 114 (37): 9966–71. https://doi.org/10.1073/pnas.1705899114.\n\n\n\n\n",
    "preview": "posts/2021-10-18-evaluate-robustness-example/evaluate-robustness-example_files/figure-html5/summary_plot-1.svg",
    "last_modified": "2021-10-25T16:17:34-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-09-momspi-patient-exploration-and-summary/",
    "title": "MOMS-PI patient exploration and analysis of fold changes",
    "description": {},
    "author": [
      {
        "name": "Jacob T. Nearing",
        "url": {}
      },
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-09",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\nThis is a link post to an analysis of the MOMS-PI vaginal microbiome profiles. The analysis computes, for each species, the fold changes between subsequent visits within individual women. It then plots species trajectories for several women, with and without calibration, and visualizes and computes some summary statistics for the observed versus actual fold changes for the species in the mock community.\nLink to analysis\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-19T14:37:02-05:00",
    "input_file": "momspi-patient-exploration-and-summary.knit.md"
  },
  {
    "path": "posts/2021-08-03-simulate-regression-example/",
    "title": "Simulate regression example",
    "description": "Simulate an example of how bias impacts a regression analysis.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-08-03",
    "categories": [],
    "contents": "\n\nContents\nSimulate data\nActual densities\nTaxonomic bias and measured densities\nCompute mean efficiencies\n\nPlots\nEstimated and actual densities\nRegression coefficients\nManuscript figure\n\n\n\n\n# library(here)\nlibrary(tidyverse)\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nlibrary(ggdist)\nlibrary(ggbeeswarm)\n\nlibrary(speedyseq)\nlibrary(metacal)\n\nset.seed(42)\n\n\n\nSimulate data\n\n\nn_species <- 10\nn_samples <- 50\n\nspecies <- str_c(\"Species \", seq(n_species))\n\n\n\nActual densities\nLog abundances are independent and follow a simple linear model,\nlog density = a_0 + a_1 * X + epsilon\n\n\nn_samples <- 50\nx <- c(\n  rep(0, n_samples / 2),\n  rep(1, n_samples / 2)\n)\nX <- rbind(1, x)\n\nSigma <- diag(1, nrow = n_species)\nrownames(Sigma) <- colnames(Sigma) <- species\na_0 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na_1 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na <- cbind(a_0, a_1)\nnames(a_0) <- names(a_1) <- rownames(a) <- species\n\nepsilon <- MASS::mvrnorm(\n  n = n_samples,\n  mu = rep(0, n_species), \n  Sigma = diag(0.5, nrow = n_species)\n) %>%\n  t\n\ny <- a %*% X + epsilon\ncolnames(y) <- str_glue(\"sa{1:n_samples}\")\n\n\n\nFor the data frame of true coefficients, convert from log-e to log-2.\n\n\ntrue_coeffs <- list('(Intercept)' = a_0, x1 = a_1) %>%\n  map_dfr(enframe, \".otu\", \"truth\", .id = \"term\") %>%\n  mutate(across(truth, ~ . / log(2))) %>%\n  print\n\n\n#> # A tibble: 20 × 3\n#>    term        .otu         truth\n#>    <chr>       <chr>        <dbl>\n#>  1 (Intercept) Species 1  -0.0905\n#>  2 (Intercept) Species 2   2.91  \n#>  3 (Intercept) Species 3  -0.137 \n#>  4 (Intercept) Species 4   2.18  \n#>  5 (Intercept) Species 5  -0.153 \n#>  6 (Intercept) Species 6   0.583 \n#>  7 (Intercept) Species 7   0.913 \n#>  8 (Intercept) Species 8   0.524 \n#>  9 (Intercept) Species 9  -0.815 \n#> 10 (Intercept) Species 10  1.98  \n#> 11 x1          Species 1   1.90  \n#> 12 x1          Species 2  -3.52  \n#> 13 x1          Species 3  -3.83  \n#> 14 x1          Species 4  -0.410 \n#> 15 x1          Species 5   0.917 \n#> 16 x1          Species 6  -0.192 \n#> 17 x1          Species 7  -0.402 \n#> 18 x1          Species 8  -2.00  \n#> 19 x1          Species 9   3.30  \n#> 20 x1          Species 10  1.88\n\n\n\nsam <- tibble(.sample = colnames(y), x) %>%\n  mutate(across(x, factor))\nactual_dens <- phyloseq(\n  otu_table(y, taxa_are_rows = TRUE) %>% transform_sample_counts(exp),\n  sample_data(sam)\n)\n\n\n\n\n\nactual_dens %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance, fill = x)) +\n  scale_x_log10() +\n  stat_dots()\n\n\n\n\nTaxonomic bias and measured densities\nDraw efficiencies from a log normal distribution; set relative to the geometric mean efficiency.\n\n\nlog_efficiency <- MASS::mvrnorm(\n  mu = rep(0, n_species),\n  Sigma = diag(3, nrow = n_species)\n) %>%\n  # {. - min(.)}\n  {. - mean(.)}\nefficiency <- exp(log_efficiency)\n# names(efficiency) <- species\n\n\n\n\n\nlog_efficiency %>% summary\n\n\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#> -3.7952 -1.4314  0.0123  0.0000  0.9551  5.0904\n\nmax(efficiency) / min(efficiency)\n\n\n#> [1] 7226.731\n\nefficiency %>% qplot + scale_x_log10()\n\n\n\n\nTo create an association of log mean efficiency and the covariate, I will set set it so that the species with the largest slope coefficient also has the largest efficiency. This scenario is inspired by the leopold2020host and brooks2015thet experiments.\n\n\nidx_slope <- which.max(a_1)\nidx_eff <- which.max(efficiency)\nnames(efficiency) <- species\nnames(efficiency)[idx_eff] <- species[idx_slope]\nnames(efficiency)[idx_slope] <- species[idx_eff]\n\n\n\nData frame with all species parameters,\n\n\nspecies_params <- true_coeffs %>%\n  pivot_wider(names_from = term, values_from = truth) %>%\n  rename(intercept = '(Intercept)') %>%\n  left_join(efficiency %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  mutate(log2_efficiency = log2(efficiency)) %>%\n  print\n\n\n#> # A tibble: 10 × 5\n#>    .otu       intercept     x1 efficiency log2_efficiency\n#>    <chr>          <dbl>  <dbl>      <dbl>           <dbl>\n#>  1 Species 1    -0.0905  1.90      0.0225          -5.48 \n#>  2 Species 2     2.91   -3.52      1.15             0.200\n#>  3 Species 3    -0.137  -3.83      0.213           -2.23 \n#>  4 Species 4     2.18   -0.410     0.0748          -3.74 \n#>  5 Species 5    -0.153   0.917     2.98             1.58 \n#>  6 Species 6     0.583  -0.192     0.339           -1.56 \n#>  7 Species 7     0.913  -0.402     0.892           -0.165\n#>  8 Species 8     0.524  -2.00      1.73             0.787\n#>  9 Species 9    -0.815   3.30    162.               7.34 \n#> 10 Species 10    1.98    1.88      9.62             3.27\n\n\n\nspecies_params %>%\n  ggplot(aes(x1, log2_efficiency)) +\n  geom_text(aes(label = str_extract(.otu, '[0-9]+')))\n\n\n\n\nQuestion: Is it true that the first species is driving the association?\nThe measured (i.e. estimated) proportions and densities are given by perturbing the actual densties by the efficiencies, and normalizing to proportions or to the original (correct) total.\n\n\nmeasured_prop <- actual_dens %>% perturb(efficiency)\nmeasured_dens <- actual_dens %>% perturb(efficiency, norm = \"keep\")\n\n\n\nCompute mean efficiencies\n\n\nmean_eff <- actual_dens %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(efficiency, norm = \"none\") %>%\n  sample_sums %>%\n  enframe(\".sample\", \"mean_efficiency\") %>%\n  left_join(sam, by = \".sample\")\n\n\n\n\n\nmean_eff %>%\n  ggplot(aes(y = as.factor(x), x = mean_efficiency)) +\n  scale_x_log10() +\n  stat_dotsinterval()\n\n\n\n\nPlots\nEstimated and actual densities\n\n\nlvls <- a_1 %>% sort(decreasing = TRUE) %>% names\n\ndens <- bind_rows(\n  Actual = actual_dens %>% as_tibble,\n  Measured = measured_dens %>% as_tibble,\n  .id = 'type'\n) %>%\n  rename(density = .abundance) %>%\n  mutate(\n    log2_density = log2(density),\n    across(.otu, factor, levels = lvls)\n  )\n\n\n\n\n\np_species_all <- dens %>%\n  ggplot(aes(x, log2_density, color = type)) +\n  labs(y = \"Log density \") +\n  facet_grid(.otu~type, scales = \"fixed\") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, fill = 'grey', se = FALSE\n  ) +\n  theme(legend.position = \"none\")\np_species_all \n\n\n\n\n\n\np_mean_eff <- mean_eff %>%\n  ggplot(aes(x, log2(mean_efficiency))) +\n  labs(y = \"Log efficiency \") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, color = 'black', fill = 'grey', se = FALSE\n  )\np_mean_eff \n\n\n\n\n\n\np_mean_eff + p_species_all +\n  plot_layout(ncol = 1, heights = c(0.2, 1)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nRegression coefficients\n\n\nlm_results_mean_eff <- mean_eff %>%\n  {lm(log2(mean_efficiency) ~ 1 + x, .)} %>%\n  broom::tidy(conf.int = TRUE)\n\n\n\n\n\nlm_results <- dens %>%\n  group_by(.otu, type) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log2_density ~ 1 + x, .)),\n    fit = map(fit, broom::tidy, conf.int = TRUE),\n  ) %>%\n  select(-data) %>%\n  unnest(fit) %>%\n  ungroup %>%\n  left_join(true_coeffs, by = c(\".otu\", \"term\"))\n\nlm_results_slope <- lm_results %>%\n  filter(term == \"x1\") %>%\n  mutate(\n    across(.otu, fct_reorder, estimate)\n  ) %>%\n  arrange(.otu)\n\n\n\n\n\n# params for arrows showing error\ndelta <- lm_results_mean_eff %>% filter(term == \"x1\") %>% pull(estimate)\nstart <- lm_results_slope %>% filter(type == 'Actual', .otu == 'Species 9') %>%\n  pull(estimate)\n\np_coef_ci <- lm_results_slope %>% \n  ggplot(aes(y = .otu, x = estimate, color = type)) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_pointinterval(aes(xmin = conf.low, xmax = conf.high)) +\n  theme(legend.position = 'top') +\n  guides(color = guide_legend(reverse = TRUE)) +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = start, xend = start - delta, \n    y = 10.5, yend = 10.5\n  ) +\n  coord_cartesian(clip = 'off')\n\np_coef_ci_with_true_coef <- p_coef_ci +\n  geom_point(data = ~filter(., type == \"Actual\"),\n    aes(x = truth),\n    color = 'black', shape = '+', size = 4)\n\np_coef_ci_mean_eff <- lm_results_mean_eff %>% \n  filter(term == \"x1\") %>%\n  ggplot(aes(y = \"Mean efficiency\", x = estimate)) +\n  expand_limits(\n    x = c(\n      min(lm_results_slope$conf.low), \n      max(lm_results_slope$conf.high)\n  )) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_point() +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = 0, xend = delta, \n    y = 1.0, yend = 1.0\n  )\n\np_coef_dot <- lm_results_slope %>% \n  ggplot(aes(y = type, x = estimate, fill = type)) +\n  labs(x = \"Log fold change\", y = \"Type\") +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  stat_dots()\n\np_coef_ci_mean_eff / p_coef_ci_with_true_coef / p_coef_dot + \n  plot_layout(heights = c(0.2, 1, 0.3)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nThe true coefficients fall within the ‘Actual’ CIs, confirming that our simulations worked. For the manuscript figure, we won’t include the true data-generating coefficients, since our aim is to illustrate the relationship between coefficients estimated on the ‘Actual’ and ‘Measured’ measurements.\nManuscript figure\nChose species that show the full range of qualitative behaviors in terms of the effect of taxonomic bias on the estimated slope coefficient.\nSpecies 9: Bias causes a substantial decrease in the magnitude of the slope\nSpecies 10: Bias causes a substantial decrease in the magnitude of the slope, such that the estimate is no longer distinguishable from zero.\nSpecies 5: Bias causes a sign error\nSpecies 7: Bias cases a small negative slope that would not have been distinguishable from zero to become significantly (in a biological and statistical sense) negative\nSpecies 2: Bias cases a substantially negative slope to become more negative (increased magnitude)\n\n\nspecies_to_plot <- str_c(\"Species \", c('9', '10', '5', '7', '2'))\np_species_focal <- p_species_all\np_species_focal$data <- p_species_focal$data %>% \n  filter(.otu %in% species_to_plot)\n\n# Bold these species in coeffcient CI plot\np_coef_ci1 <- p_coef_ci +\n  theme(\n    axis.text.y = element_text(\n      face = ifelse(levels(p_coef_ci$data$.otu) %in% species_to_plot, \n        \"bold\", \"plain\")\n    )\n  )\n\n# Set range of mean eff panel to match\nrng <- p_species_focal$data %>%\n  pull(log2_density) %>%\n  {max(.) - min(.)}\nm <- p_mean_eff$data %>% pull(mean_efficiency) %>% log2 %>% mean\np_mean_eff1 <- p_mean_eff + \n  expand_limits(y = c(m - rng/2, m + rng/2))\n\n\n\n\n\n(p_mean_eff1 + ggtitle(\"Mean efficiency\")) +\n  (p_coef_ci_mean_eff + ggtitle(\"LFC in mean efficiency\")) + \n  (p_species_focal + ggtitle(\"Actual and measured densities\\nof select species\")) + \n  (p_coef_ci1 + ggtitle(\"Estimated LFCs of all species\") +\n    theme(legend.box.margin = margin(b = -15))\n  ) + \n  plot_layout(ncol = 2, heights = c(0.2, 1)) +\n  plot_annotation(tag_levels = 'A') &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto() &\n  theme(\n    plot.title = element_text(face = \"plain\")\n  )\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-08-03-simulate-regression-example/simulate-regression-example_files/figure-html5/unnamed-chunk-6-1.svg",
    "last_modified": "2021-10-25T12:24:55-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-10-vaginal-microbiome-example/",
    "title": "Hypothetical example of spurious fold changes in proportions in the vaginal microbiome",
    "description": "This doc develops a hypothetical example in which bias leads to a spurious differential abundance result. It is based on a real case of bias measured among three species of vaginally-associated bacteria.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-05-10",
    "categories": [],
    "contents": "\n\nContents\nSetup\nSimulate data\nPlots\nSession info\n\n\nChangelog\n2021-07-17: Cleaned up the doc and updated to use the cleaner code and include the caption from /article.Rmd\nSetup\n\n\nset.seed(42)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE,\n  cache = FALSE,\n  echo = TRUE\n)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nclose_elts <- function(x) x / sum(x)\n\n\n\nSimulate data\n\n\nbias <- tibble(taxon = c(\"Lactobacillus\", \"Gardnerella\", \"Atopobium\", \"Spike-in\"),\n  efficiency = c(4.68, 0.16, 0.285, 1)) %>%\n  mutate(across(efficiency, ~. / min(.)))\n# efficiency associated with the targeted measurement of Lactobacillus\ntargeted_efficiency <- 2\na0 <- tribble(\n  ~taxon, ~timepoint, ~abundance,\n  \"Lactobacillus\", \"T1\", 5,\n  \"Lactobacillus\", \"T2\", 0.5,\n  \"Gardnerella\", \"T1\", 2,\n  \"Gardnerella\", \"T2\", 8,\n  \"Atopobium\", \"T1\", 3,\n  \"Atopobium\", \"T2\", 1.5,\n) %>%\n  # Shrink abundance to have similar scale as proportions\n  mutate(across(abundance, ~ . / max(.))) %>%\n  left_join(bias, by = \"taxon\") %>%\n  with_groups(timepoint, mutate,\n    total_abundance = sum(abundance),\n    proportion = close_elts(abundance),\n    biased_abundance = efficiency * abundance,\n    biased_proportion = close_elts(biased_abundance),\n    biased_count = biased_proportion * 1e3,\n    abundance_estimate_bulk = biased_proportion * total_abundance,\n    #> abundance_estimate_spikein = biased_count / biased_count[taxon == \"Spike-in\"],\n    abundance_estimate_targeted = biased_count * targeted_efficiency *\n      abundance[taxon == \"Lactobacillus\"] / biased_count[taxon == \"Lactobacillus\"],\n  )\na1 <- a0 %>%\n  select(-total_abundance) %>%\n  pivot_longer(-c(taxon, efficiency, timepoint), names_to = \"type\")\n# data frame for plots\nptb <- a1 %>%\n  filter(\n    type %in% c(\"proportion\", \"biased_proportion\"),\n  ) %>%\n  mutate(\n    across(type, fct_relevel, \"proportion\", \"biased_proportion\"),\n    across(type, fct_recode,\n      \"Actual\" = \"proportion\",\n      \"Observed\" = \"biased_proportion\"),\n  )\n\n\n\nPlots\nPanels showing the error in measurement and in differential abundance\n\n\nshared_layers <- list(\n  geom_path(aes(group = taxon),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))),\n  geom_point(size = 2),\n  scale_color_brewer(type = \"qual\", palette = 1, guide = \"none\"),\n  labs(y = \"Proportion\", color = \"Taxon\"),\n  scale_y_log10(),\n  coord_cartesian(clip = \"off\"),\n  # scale_y_log10(breaks = c(1e-2, 3e-2, 1e-1, 3e-1, 1)) +\n  expand_limits(y = 1e-2),\n  theme(plot.margin = unit(c(0, 1.3, 0, 0), units = \"in\"))\n)\n# How much to nudge the taxon labels and proportions\nnudge.taxon <- 0.48\nnudge.prop <- 0.24\n# In future iterations, consider labelling the taxa in both facets\np.meas <- ptb %>%\n  ggplot(aes(type, value, color = taxon)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  shared_layers +\n  geom_text(data = ~filter(., type == \"Actual\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., type == \"Observed\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Type\",\n    title = \"Measurement error at each time point\"\n  )\np.fc <- ptb %>%\n  ggplot(aes(timepoint, value, color = taxon)) +\n  facet_wrap(~type, nrow = 1, scales = \"fixed\") +\n  shared_layers +\n  geom_text(data = ~filter(., timepoint == \"T1\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Time point\",\n    title = \"Actual and observed fold changes\"\n  )\n\n\n\nPanel showing the efficiencies of individual taxa and the sample means\n\n\n# First, compute the mean efficiency, then join with the taxon efficiencies in\n# a table for plotting.\nsme <- a0 %>%\n  with_groups(timepoint, summarize, mean_efficiency = sum(proportion * efficiency))\nsme0 <- sme %>%\n  mutate(label = str_glue(\"mean ({timepoint})\")) %>%\n  select(label, efficiency = mean_efficiency)\nsme1 <- sme %>%\n  mutate(taxon = \"Mean\", type = \"Mean\") %>%\n  select(taxon, efficiency = mean_efficiency, timepoint, type)\nbias1 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(type = \"Taxon\")\nlvls = c(\"Atopobium\", \"Gardnerella\", \"Lactobacillus\", \"Mean\")\netb1 <- bind_rows(bias1, sme1) %>%\n  mutate(across(taxon, factor, levels = lvls))\n\nlvls = c(\"Gardnerella\", \"Atopobium\", \"Lactobacillus\")\nbias2 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(\n    type = \"Taxon\",\n    across(taxon, factor, levels = lvls),\n    x = as.integer(taxon)\n  ) %>%\n  left_join(sme, by = \"timepoint\")\n\nclrs <- c(RColorBrewer::brewer.pal(n = 3, \"Accent\"), rep(\"#585858\", 2))\np.eff <- bias2 %>%\n  ggplot(aes(x = x, y = efficiency, color = taxon)) +\n  geom_point(size = 2) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = taxon), x = 3.3, hjust = 0) +\n  geom_segment(aes(xend = x, yend  = efficiency, y = mean_efficiency),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))) +\n  geom_segment(data = sme,\n    aes(x = 1, xend = 3, y = mean_efficiency, yend = mean_efficiency),\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  geom_text(data = sme0 %>% mutate(timepoint = \"T2\"),\n    aes(label = label, y = efficiency), x = 3.3, hjust = 0,\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  scale_color_manual(values = clrs) +\n  labs(y = \"Relative efficiency\", x = NULL, color = \"Taxon\",\n    title = \"Taxonomic bias of protocol\"\n  ) +\n  # Set the vertical span to match the other plots\n  scale_y_log10(limits = c(1, 100) / 2,\n    breaks = etb1$efficiency,\n    labels = signif(etb1$efficiency, 2)\n  ) +\n  xlim(c(0.0, 4)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  coord_cartesian(clip = \"off\") +\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.title.x = element_blank(),\n    legend.position = \"none\",\n    plot.margin = unit(c(0, 1.0, 0, 0), units = \"in\")\n  )\n\n\n\nPlot as a multi-panel figure\n\n\np.meas + p.eff + p.fc + plot_spacer() + \n  plot_layout(byrow = TRUE, ncol = 2, widths = c(1, 0.6)) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nCaption (copied from main article version 47ce39c): Taxonomic bias can distort differential abundance results even when it is consistent for each taxon across samples. Panel A shows the actual and observed proportions for hypothetical community samples from two time points, which differ in their relative abundance of three taxa. Panel B shows taxonomic bias in terms of the relative efficiencies of the three taxa against the mean efficiency of each sample; the difference between the taxon’s efficiency and the sample’s mean (vertical arrows) determines the fold error seen in Panel A. Panel C rearranges the plot from Panel A to show the actual and observed fold changes between time points. The efficiencies of individual taxa were estimated by @mclaren2019cons from mock community data from @brooks2015thet. The abundances are hypothetical but inspired by observations from the human vaginal microbiome; see main text.\nSome ideas for improvement:\nExperiment with ways to make the connections even clearer between the efficiency differences and the error.\nTry making the arrows vertical, so that they are directly connected to the fold changes in proportion and in efficiency.\nCan also split the third plot into T1 and T2.\nMight consider changing “Time point T1” to “Sample S1”, to fit the primary language of the text.\nCan mention in the text that these could be samples from different women, or the same woman at different times.\nalso use a shape scale for the taxa, to give a second way besides color to distinguish them\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.0 (2021-05-18)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-07-17                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package      * version date       lib source        \n#>  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n#>  backports      1.2.1   2020-12-09 [1] CRAN (R 4.0.3)\n#>  base64enc      0.1-3   2015-07-28 [1] CRAN (R 4.0.0)\n#>  bookdown       0.22    2021-04-22 [1] CRAN (R 4.1.0)\n#>  broom          0.7.6   2021-04-05 [1] CRAN (R 4.0.5)\n#>  bslib          0.2.5.1 2021-05-18 [1] CRAN (R 4.1.0)\n#>  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n#>  cli            3.0.0   2021-06-30 [1] CRAN (R 4.1.0)\n#>  colorspace     2.0-2   2021-06-24 [1] CRAN (R 4.1.0)\n#>  cowplot      * 1.1.1   2020-12-30 [1] CRAN (R 4.0.4)\n#>  crayon         1.4.1   2021-02-08 [1] CRAN (R 4.0.4)\n#>  DBI            1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n#>  dbplyr         2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n#>  digest         0.6.27  2020-10-24 [1] CRAN (R 4.0.3)\n#>  distill        1.2     2021-01-13 [1] CRAN (R 4.1.0)\n#>  downlit        0.2.1   2020-11-04 [1] CRAN (R 4.0.3)\n#>  dplyr        * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n#>  ellipsis       0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n#>  evaluate       0.14    2019-05-28 [1] CRAN (R 4.0.0)\n#>  fansi          0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n#>  farver         2.1.0   2021-02-28 [1] CRAN (R 4.0.4)\n#>  forcats      * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n#>  fs             1.5.0   2020-07-31 [1] CRAN (R 4.0.2)\n#>  generics       0.1.0   2020-10-31 [1] CRAN (R 4.0.3)\n#>  ggplot2      * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n#>  glue           1.4.2   2020-08-27 [1] CRAN (R 4.0.2)\n#>  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n#>  haven          2.4.1   2021-04-23 [1] CRAN (R 4.1.0)\n#>  here         * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n#>  highr          0.9     2021-04-16 [1] CRAN (R 4.1.0)\n#>  hms            1.1.0   2021-05-17 [1] CRAN (R 4.1.0)\n#>  htmltools      0.5.1.1 2021-01-22 [1] CRAN (R 4.0.3)\n#>  httr           1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n#>  jquerylib      0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n#>  jsonlite       1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n#>  knitr          1.33    2021-04-24 [1] CRAN (R 4.1.0)\n#>  labeling       0.4.2   2020-10-20 [1] CRAN (R 4.0.3)\n#>  lifecycle      1.0.0   2021-02-15 [1] CRAN (R 4.0.4)\n#>  lubridate      1.7.10  2021-02-26 [1] CRAN (R 4.0.4)\n#>  magrittr       2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n#>  modelr         0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n#>  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n#>  nvimcom      * 0.9-102 2021-07-17 [1] local         \n#>  patchwork    * 1.1.1   2020-12-17 [1] CRAN (R 4.0.3)\n#>  pillar         1.6.1   2021-05-16 [1] CRAN (R 4.1.0)\n#>  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n#>  purrr        * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n#>  R6             2.5.0   2020-10-28 [1] CRAN (R 4.0.3)\n#>  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 4.0.0)\n#>  Rcpp           1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n#>  readr        * 1.4.0   2020-10-05 [1] CRAN (R 4.0.3)\n#>  readxl         1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n#>  reprex         2.0.0   2021-04-02 [1] CRAN (R 4.0.5)\n#>  rlang          0.4.11  2021-04-30 [1] CRAN (R 4.1.0)\n#>  rmarkdown    * 2.8     2021-05-07 [1] CRAN (R 4.1.0)\n#>  rprojroot      2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n#>  rstudioapi     0.13    2020-11-12 [1] CRAN (R 4.0.3)\n#>  rvest          1.0.0   2021-03-09 [1] CRAN (R 4.0.5)\n#>  sass           0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n#>  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n#>  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.0)\n#>  stringi        1.6.2   2021-05-17 [1] CRAN (R 4.1.0)\n#>  stringr      * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n#>  tibble       * 3.1.2   2021-05-16 [1] CRAN (R 4.1.0)\n#>  tidyr        * 1.1.3   2021-03-03 [1] CRAN (R 4.0.4)\n#>  tidyselect     1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n#>  tidyverse    * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n#>  utf8           1.2.1   2021-03-12 [1] CRAN (R 4.0.5)\n#>  vctrs          0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n#>  withr          2.4.2   2021-04-18 [1] CRAN (R 4.0.5)\n#>  xfun           0.23    2021-05-15 [1] CRAN (R 4.1.0)\n#>  xml2           1.3.2   2020-04-23 [1] CRAN (R 4.0.0)\n#>  yaml           2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-05-10-vaginal-microbiome-example/vaginal-microbiome-example_files/figure-html5/vaginal-example-proportions-timepoints-1.svg",
    "last_modified": "2021-08-12T09:56:57-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/",
    "title": "Illustration of a spurious differential abundance result due to bias",
    "description": "Create illustration of a spurious differential abundance using the Leopold and Busby (2020) dataset.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-04-26",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9001'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 × 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.77   1.06\n2 Dioszegia        0.295   0.294  1.10\n3 Epicoccum        1.01    1.01   1.50\n4 Fusarium         3.07    3.06   1.14\n5 Penicillium      0.223   0.223  1.09\n6 Cladosporium     0.899   0.898  1.13\n7 Trichoderma      0.578   0.578  1.09\n8 Alternaria       1.47    1.47   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\nRegression analysis\nFirst let’s pick a subset of samples to work with.\n\n\nsam %>%\n  count(Samp_type, Timepoint)\n\n\n# A tibble: 4 × 3\n  Samp_type  Timepoint     n\n  <chr>      <fct>     <int>\n1 Experiment 1           250\n2 Experiment 2           298\n3 Mock       <NA>         10\n4 Single     <NA>          9\n\nsam %>%\n  filter(Samp_type == \"Experiment\") %>%\n  count(Treatment, Timepoint)\n\n\n# A tibble: 12 × 3\n   Treatment     Timepoint     n\n   <chr>         <fct>     <int>\n 1 Alternaria    1            52\n 2 Alternaria    2            53\n 3 Aureobasidium 1            50\n 4 Aureobasidium 2            48\n 5 Cladosporium  1            49\n 6 Cladosporium  2            48\n 7 Dioszegia     1            48\n 8 Dioszegia     2            49\n 9 Fusarium      1            49\n10 Fusarium      2            50\n11 Negative      1             2\n12 Negative      2            50\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Timepoint == 2) %>%\n  count(Region, Treatment)\n\n\n# A tibble: 12 × 3\n   Region Treatment         n\n   <chr>  <chr>         <int>\n 1 East   Alternaria       22\n 2 East   Aureobasidium    21\n 3 East   Cladosporium     19\n 4 East   Dioszegia        18\n 5 East   Fusarium         21\n 6 East   Negative         21\n 7 West   Alternaria       31\n 8 West   Aureobasidium    27\n 9 West   Cladosporium     29\n10 West   Dioszegia        31\n11 West   Fusarium         29\n12 West   Negative         29\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  count(Region, Timepoint)\n\n\n# A tibble: 4 × 3\n  Region Timepoint     n\n  <chr>  <fct>     <int>\n1 East   1           102\n2 East   2           101\n3 West   1           146\n4 West   2           147\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  with_groups(Genotype, summarize, n1 = sum(Timepoint == 1), n2 = sum(Timepoint == 2), tot = n())\n\n\n# A tibble: 12 × 4\n   Genotype    n1    n2   tot\n   <chr>    <int> <int> <int>\n 1 East-1      20    20    40\n 2 East-2      16    17    33\n 3 East-3      19    18    37\n 4 East-4      25    25    50\n 5 East-5      22    21    43\n 6 West-1      22    21    43\n 7 West-2      22    24    46\n 8 West-3      23    23    46\n 9 West-4      23    23    46\n10 West-5      18    17    35\n11 West-6      20    19    39\n12 West-7      18    20    38\n\nThe “Negative” treatment was not inoculated with commensals; let’s drop that from the analysis. Note that there are 2 more West genotypes adn thus more West than East samples.\nTime point\nAsks, how did taxa vary in proportion with the addition of Mel? Note, we expect the commensal taxa to typically decrease given that Mel successfully infects most plants.\nWant to do linear regression on the timepoint.\nstarting point - observed and calibrated proportions in the experiment samples; SME in the experiment samples\n\n\nps1.obs <- ps.pseudo %>%\n  subset_samples(Samp_type == \"Experiment\" & Treatment != \"Negative\") %>%\n  prune_taxa(mock_taxa, .) %>%\n  orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nps1.cal <- ps1.obs %>% calibrate(bias)\nsam1 <- sample_data(ps1.obs) %>% as(\"data.frame\")\nsme1 <- sme %>% filter(Sample %in% sample_names(ps1.obs)) %>% rename(Mean_efficiency = SMRE)\n\n\n\nNote the different numbers of samples at each timepoint Should consider more sophisticated resgression models.\n\n\nfit.obs <- lm(log2(otu_table(ps1.obs)) ~ Timepoint, data = sam1)\nfit.cal <- lm(log2(otu_table(ps1.cal)) ~ Timepoint, data = sam1)\nfit.sme <- lm(log2(Mean_efficiency) ~ Timepoint, data = sme1)\n\n\n\nCheck that the observed changes - the calibrated changes are off by the expected constant shift,\n\n\nt(coef(fit.obs) - coef(fit.cal))\n\n\n              (Intercept) Timepoint2\nMelampsora     2.60208447  -1.991951\nAureobasidium -0.96511376  -1.991951\nTrichoderma   -1.31867681  -1.991951\nFusarium       1.08940455  -1.991951\nPenicillium   -2.68941450  -1.991951\nAlternaria     0.02685515  -1.991951\nCladosporium  -0.68076501  -1.991951\nDioszegia     -2.28952043  -1.991951\nEpicoccum     -0.51768451  -1.991951\n\ncoef(fit.sme)\n\n\n(Intercept)  Timepoint2 \n  0.5269812   1.9919505 \n\n\n\ncoef(fit.obs) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -10.9999195  10.702851\nAureobasidium  -7.9294352  -3.681906\nTrichoderma    -9.4061811  -3.872543\nFusarium       -2.1926596  -5.089495\nPenicillium   -10.8867241  -2.555602\nAlternaria     -0.9593701  -4.074728\nCladosporium   -6.0294424  -3.585850\nDioszegia      -7.7191545  -5.463284\nEpicoccum      -2.3532764  -4.745944\n\ncoef(fit.cal) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -13.6020039 12.6948011\nAureobasidium  -6.9643215 -1.6899556\nTrichoderma    -8.0875043 -1.8805929\nFusarium       -3.2820642 -3.0975448\nPenicillium    -8.1973096 -0.5636511\nAlternaria     -0.9862252 -2.0827775\nCladosporium   -5.3486773 -1.5938999\nDioszegia      -5.4296340 -3.4713339\nEpicoccum      -1.8355919 -2.7539932\n\nThe effect of bias is significant; e.g. Aureobasidium and Trichoderma appear to decrease in proportion by 16X but actually decrease by 4X, and Penicillium appears to decrease by 5.9X but only decreases by 1.5X.\nCould use the case of Penicillium as our example.\n\n\n# Check expected relationship between coefficients on intercept and slope\nall.equal(\n  coef(fit.obs)[,\"Penicillium\"],\n  coef(fit.cal)[,\"Penicillium\"] + c(log2(bias[\"Penicillium\"]), 0) - coef(fit.sme)\n)\n\n\n[1] TRUE\n\n\n\ntb <- bind_rows(\n  Observed = psmelt(ps1.obs),\n  Calibrated = psmelt(ps1.cal),\n  .id = \"Type\"\n) %>%\n  mutate(across(Type, fct_relevel, \"Calibrated\")) %>%\n  rename(Proportion = Abundance)\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8) +\n  scale_color_brewer(type = \"qual\", palette = 6)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\nTODO: Add a panel with the sample mean efficiency\n\n\nsme1 %>%\n  ggplot(aes(y = log2(Mean_efficiency), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n\n\n\n\nQuestion: For the purposes of illustration, might we want to find the host region or host genotype with the largest change in SME? Ok as long as we’re clear what we’re doing. Reducing the number of data points and biological variation might actually make things cleaner as well (or could use boxplots), since the point is not to dwell on all the variation, but rather just the average effect.\nfor paper, might be clearer to call “Corrected” instead of “Calibrated”.\nCan easily split graph by region or host genotype:\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Region)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\") +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_grid(Region~Type)\n\n\n\n\nNote that the 95% CIs are small and hard to see.\nWant to plot the sme’s with the change in proportion; make sure the y-axes have the same scale. One way to simplify this is to show the mean efficiency relative to the taxon in question; then it will give the difference between calibrated and observed.\n\n\nsme2 <- sme1 %>%\n  mutate(Mean_relative_efficiency = Mean_efficiency / bias[\"Penicillium\"]) %>%\n  rename(Proportion = Mean_relative_efficiency) %>%\n  mutate(Type = \"Mean relative efficiency\")\ntb1 <- tb %>%\n  filter(OTU == \"Penicillium\") %>%\n  bind_rows(sme2) %>%\n  mutate(across(Type, fct_relevel, c(\"Calibrated\", \"Observed\", \"Mean relative efficiency\")))\n\n\n\n\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n)\ntb1 %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  lyrs +\n  facet_grid(Region~Type)\n\n\n\n\n\n\ntb1 %>%\n  mutate(across(Type, fct_reorder, Proportion)) %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.3) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_grid(.~Region) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = 5,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"Pathogen growth causes\\nmean efficiency to increase,\",\n  ) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = -10,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"which leads to larger-than-\\nactual decreases in the\\nfocal taxon Penicillium.\",\n  ) +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  theme(\n    legend.position = \"top\",\n    plot.margin = margin(r = 2.5, unit = \"in\"),\n  ) +\n  plot_annotation(\n    title = \"Effect of bias on Penicillium differential abundance\"\n  )\n\n\n\n\nSummary:\nRegression of log2(Proportion) of the fungus Penicillium versus timepoint; timepoints 1 and 2 are pre- and post- challenge with the pathogen Melampsora. Data is split by the region the host plants are derived from.\nCalibrated proportions = Observed proportions in the real, experimental samples after adjustment for the bias measured in mock communities\nMean efficiency of each community is inferred by treating the calibrated proportions as the truth, and multiplying by efficiencies estimated from the mocks\nThe pathogen Melampsora has a high measurement efficiency; thus once it infects the plants, the mean efficiency of the sample increases (purple points). Efficiency is here taken as relative to the focal taxon Penicillium.\nWest plants tend to be more resistant to the pathogen, which likely explains why the mean efficiency doesn’t increase as much in the West plants\nPenicillium is observed to decrease in log proportion, in both the East and West plants. But the calibrated measurements show that it actually slightly increases in the East plants, and has a lesser decrease in the West plants than what was observed before bias correction.\nThe difference between the Calibrated and Observed data points and regression lines equals the regression line of the mean efficiency: Orange = Green + Purple; Green = Orange - Purple\nThe absolute error in regression coeffiecients is the same for all taxa. I picked Penicillium for illustration since it has the smallest observed decrease, which makes the error due to bias have a particularly significant impact. \n\n\n\nAlt. plot\n\n\ntb2 <- tb1 %>%\n  mutate(\n    log2_proportion = log2(Proportion),\n    across(Type, fct_relevel, c(\"Observed\", \"Calibrated\", \"Mean relative efficiency\")),\n    #> across(Type, fct_recode, Corrected = \"Calibrated\", Uncorrected = \"Observed\")\n  )\n\n\n\nLet’s show the calibrated, observed, and mean efficiency side by side, similar to my initial explanatory plot.\nQuestion: How to get the same y-axis range in each facet? We need to determine what we want the min and max y values for each facet to be. Choose so that the range in each panel equals the max data range for any one panel, and center the data range of each panel within the plot range.\n\n\nyr <- tb2 %>%\n  with_groups(c(Region, Type), summarize, \n    across(log2_proportion, c(min = min, max = max), .names =  \"data_{.fn}\")\n ) %>%\n  mutate(\n    data_range = data_max - data_min,\n    data_mid = (data_max + data_min) / 2,\n    y_min = data_mid - max(data_range) / 2,\n    y_max = data_mid + max(data_range) / 2\n  ) %>%\n  print\n\n\n# A tibble: 6 × 8\n  Region Type      data_min data_max data_range data_mid   y_min y_max\n  <chr>  <fct>        <dbl>    <dbl>      <dbl>    <dbl>   <dbl> <dbl>\n1 East   Observed    -14.9     -8.66       6.26   -11.8  -16.2   -7.41\n2 East   Calibrat…   -12.2     -5.96       6.22    -9.07 -13.5   -4.69\n3 East   Mean rel…     2.48     5.27       2.79     3.87  -0.510  8.26\n4 West   Observed    -14.9     -6.16       8.77   -10.5  -14.9   -6.16\n5 West   Calibrat…   -11.3     -3.58       7.76    -7.46 -11.8   -3.07\n6 West   Mean rel…     2.47     5.26       2.79     3.87  -0.515  8.25\n\nstopifnot(yr %>% {sd((.$y_max - .$y_min))} < 1e-14)\nyr.long <- yr %>%\n  pivot_longer(c(y_min, y_max))\n\n\n\n\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  geom_blank(data = yr.long, aes(y = value, x = 1)) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_wrap(Region~Type, scales = \"free_y\") +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)) +\n  labs(y = \"log2(Proportion)\")\n\n\n\n\n\n\ntext_tb <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\n#> Label \"Calibrated\" as \"Actual\" for purposes of illustration?\nlblr <- function(labels) {\n  labels %>% pull(1) %>% fct_recode(Actual = \"Calibrated\") %>% as.character %>% list\n}\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    #> arrow = grid::arrow(length = unit(0.15, \"inches\")),\n    size = 0.9, color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  facet_wrap(~Type, scales = \"free_y\", labeller = lblr),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  theme(\n    plot.title = element_text(face = \"plain\"),\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\")\n  ),\n  labs(y = \"log2(Proportion)\"),\n  # Corrected = Observed - Mean relative efficiency\n  coord_cartesian(xlim = c(1, 2), clip = \"off\")\n)\np1 <- tb2 %>%\n  filter(Region == \"East\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"East\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Eastern genotypes: Bias causes sign error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"East\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\np2 <- tb2 %>%\n  filter(Region == \"West\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"West\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Western genotypes: Bias causes magnitude error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"West\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\n\n\n\n\n\np1 / p2 + \n  plot_annotation(\n    #> title = \"Effect of bias on Penicillium differential abundance\",\n    tag_levels = \"A\"\n  )\n\n\n\n\nThis ^ is my favorite so far\n\n\n\nTODO:\nChange y label to log2(value) and adding “proportion” to the two proportion facets\nChange back to “Calibrated proportion” and “Observed proportion”?\nSlightly increase spacing between patchwork panels (rows)\nSwap positions of calibrated and uncalibrated so that the equation is correct: Observed = Actual - Mean efficiency\nalternate approach using 2-d facet wrap:\n\n\nsymbol_labels <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n      #> Type == \"Mean relative efficiency\" & Region == \"East\" ~ \"Eastern\\ngenotypes\",\n      #> Type == \"Mean relative efficiency\" & Region == \"West\" ~ \"Western\\ngenotypes\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\nregion_labels <- yr %>%\n  filter(Type == \"Mean relative efficiency\") %>%\n  mutate(\n    text = case_when(\n      Region == \"East\" ~ \"Eastern genotypes\\n\\nBias causes\\nsign error\",\n      Region == \"West\" ~ \"Western genotypes\\n\\nBias causes\\nmagnitude error\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> geom_blank(data = yr, aes(y = y_min, x = factor(1))),\n  #> geom_blank(data = yr, aes(y = y_max, x = factor(1))),\n  geom_blank(data = yr.long, aes(y = value, x = 1)),\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  #> facet_wrap(~Type, scales = \"free_y\"),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  labs(y = \"log2(Proportion)\"),\n  # Calibrated = Observed - Mean relative efficiency\n  geom_text(\n    data = symbol_labels,\n    aes(y = y, label = text),\n    x = 2.9, color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  ),\n  geom_text(\n    data = region_labels,\n    aes(y = y, label = text),\n    x = 2.8, color = \"black\", size = 4.8, hjust = 0, vjust = 0.5,\n  ),\n  coord_cartesian(xlim = c(1, 2), clip = \"off\"),\n  theme(\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\"),\n    plot.margin = margin(r = 1.75, unit = \"in\")\n  )\n)\n\n# labeller assuming first col is region, second is type\nlblr <- function(labels) {\n  labels %>% pull(2) %>% as.character %>% list\n}\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  facet_wrap(Region~Type, scales = \"free_y\", \n    labeller = lblr\n    #> labeller = labeller(Region = NULL, .multi_line = FALSE),\n    #> strip.position = \"right\"\n  )\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.0 (2021-05-18)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-07-28                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.0     2021-05-19 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n broom            * 0.7.8      2021-06-24 [1] CRAN (R 4.1.0)                   \n bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n checkmate          2.0.0      2020-02-06 [1] CRAN (R 4.0.2)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.0)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.0)                   \n colorspace         2.0-2      2021-06-24 [1] CRAN (R 4.1.0)                   \n cowplot          * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n foreign            0.8-81     2020-12-22 [2] CRAN (R 4.1.0)                   \n Formula            1.2-4      2020-10-16 [1] CRAN (R 4.0.3)                   \n fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n GenomeInfoDb       1.28.0     2021-05-19 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.1      2021-04-23 [1] CRAN (R 4.1.0)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n Hmisc              4.5-0      2021-02-28 [1] CRAN (R 4.0.4)                   \n hms                1.1.0      2021-05-17 [1] CRAN (R 4.1.0)                   \n htmlTable          2.2.1      2021-05-18 [1] CRAN (R 4.1.0)                   \n htmltools          0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n htmlwidgets        1.5.3      2020-12-10 [1] CRAN (R 4.0.3)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jpeg               0.1-9      2021-07-24 [1] CRAN (R 4.1.0)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.33       2021-04-24 [1] CRAN (R 4.1.0)                   \n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.0)                   \n latticeExtra       0.6-29     2019-12-19 [1] CRAN (R 4.0.0)                   \n lifecycle          1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.0)                   \n Matrix             1.3-3      2021-05-04 [2] CRAN (R 4.1.0)                   \n metacal          * 0.2.0.9001 2021-07-16 [1] Github (mikemc/metacal@a7a87a1)  \n mgcv               1.8-35     2021-04-18 [2] CRAN (R 4.1.0)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.0)                   \n nnet               7.3-16     2021-05-03 [2] CRAN (R 4.1.0)                   \n nvimcom          * 0.9-102    2021-07-17 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.1      2021-05-16 [1] CRAN (R 4.1.0)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n png                0.1-7      2013-12-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                   \n readr            * 2.0.0      2021-07-20 [1] CRAN (R 4.1.0)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.0     2021-05-19 [1] Bioconductor                     \n rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                   \n rmarkdown        * 2.9        2021-06-15 [1] CRAN (R 4.1.0)                   \n rpart              4.1-15     2019-04-12 [2] CRAN (R 4.1.0)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.3      2021-07-16 [1] CRAN (R 4.1.0)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.0)                   \n tibble           * 3.1.3      2021-07-23 [1] CRAN (R 4.1.0)                   \n tidyr            * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.24       2021-06-15 [1] CRAN (R 4.1.0)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/index_files/figure-html5/unnamed-chunk-2-1.svg",
    "last_modified": "2021-10-25T12:24:55-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-11-12-leopold2020host-bias-sensitivity/",
    "title": "Exploring the effect of bias in Leopold and Busby (2020)\n",
    "description": {},
    "author": [
      {
        "name": "Michael McLaren",
        "url": {}
      }
    ],
    "date": "2019-10-21",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nSetup\nSample mean efficiency across samples\nAlt plot\nCheck errors in FCs\nmock samples\nExperiment samples\n\n\nSession info\n\nAnalysis of bias in Leopold and Busby (2020).\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 x 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.76   1.06\n2 Dioszegia        0.295   0.295  1.10\n3 Epicoccum        1.01    0.995  1.50\n4 Fusarium         3.07    3.08   1.14\n5 Penicillium      0.223   0.224  1.09\n6 Cladosporium     0.899   0.903  1.13\n7 Trichoderma      0.578   0.579  1.09\n8 Alternaria       1.47    1.46   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\n\n\nrange(sme$SMRE)\n\n\n[1] 0.2236076 8.7034225\n\nrange(bias)\n\n\n[1] 0.2233792 8.7486819\n\n\n\np1 <- ggplot(sme, aes(SMRE, fill = Samp_type)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = \"Sample type\"\n  )\np1 +\n  plot_annotation(\n    title = \"Distribution of sample mean relative efficiencies\",\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nIn this case, the bimodal distribution is likely driven by the high proportion of Melampsora (pathogen) in ~half the samples.\nTODO: check this hypothesis. by making a histogram of melampspora %, and a scatterplot of the melamspora vs. SMRE. Can do with facet matrix from ggforce\n\n\nmel <- otu %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  psmelt %>%\n  select(-OTU, Melampsora = Abundance)\nsme0 <- left_join(sme, mel, by = \"Sample\")\n\n\n\n\n\n# p2 <- ggplot(sme0, aes(SMRE, fill = Melampsora)) +\np2 <- ggplot(sme0, aes(y = Melampsora, x = SMRE, color = Samp_type)) +\n  geom_point() +\n  # annotate(\"point\", y = 1, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  expand_limits(x = range(bias)) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\",\n    color = \"Sample type\"\n  )\np2\n\n\n\n\n\n\n(p1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.pdf\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\n\n\n\nNote, the high-Mel samples are the timepoint 2 samples, and were not used for some (all?) of his analysis due to the dominance of Mel. Let’s check this out,\n\n\nsme %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  ) %>%\n  # filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Treatment)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Region)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nCan see that Eastern genotypes more susceptible (more Mel and higher SME)\nAre some western genotypes less susceptible?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"West\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nEastern?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"East\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nAlt plot\nMight be better to just focus on the treated experimental samples; can note that the bimodal distribution in SMRE is due to the presence of Mel in the timepoint 2, and thus we’d mess up our AA inferences if we tried to infer the change in AA after Mel introduction. We might also (if were were analyzing timepoint 2 samples)\nActually, including the bias values serves the important purpose of showing how the SME varies less than the efficiencies. For that reason it could even be worth having the single-isolate samples, though seems unneeded.\nPoints\nSME varies less across samples than efficiencies vary across taxa\nSME much greater after rusting (timepoint 2) -> it will look like the growth of the pathogen suppressed the proportion and absolute abundance of the colonizers 5-6X more than it actually did\nThe Mel prop and hence the SME varies significantly in the timepoint 2 samples. This may lead to systematic errors in certain inferences. E.g., if host genotype affects Mel and another taxon, that other taxon’s value will be distorted (and, I think, the effect on Mel will be inflated).\nAs an example, think through the case of more resistant host genotypes\nMight also consider the taxa found to suppress Mel; see paper\n\n\n\np1.1 <- sme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\np2.1 <- sme0 %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(y = Melampsora, x = SMRE, color = Timepoint)) +\n  geom_point() +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    x = \"Mean efficiency\"\n  )\n\n\n\n\n\n(p1.1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2.1 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nTODO: Still need to determien if the y axis is accurate on histogram; I think its off when using pseudo-log. But perhaps can get away with linear?\nCheck errors in FCs\nWe can use this distribution to pick examples of samples where bias approximately cancels in the FC estimates (because their SMRE’s are similar), and samples where bias does not approximately cancel (because their SMRE’s are very different). Could do for mock samples (using the ground truth) or for natural samples (using the calibrated composition). Might as well do it both ways; not sure which would be best for a paper. The mocks have the benefit of knowing the ground truth, while the natural samples demonstrate practical significance. Also, we can give nice intuitive description of what we’re doing in the natural samples by saying that we’re comparing samples w/ low-low, high-high, or low-high pathogen %.\nTODO ^^\nmock samples\nTo pick from the mock samples:\n\n\nsme0 %>%\n  filter(Samp_type == \"Mock\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 10 x 5\n   Sample   SMRE Melampsora log10_SMRE     diff\n   <chr>   <dbl>      <dbl>      <dbl>    <dbl>\n 1 Mock.3  0.541    0.00782   -0.267   NA      \n 2 Mock.7  0.970    0.00761   -0.0132   0.254  \n 3 Mock.9  0.981    0.0116    -0.00824  0.00492\n 4 Mock.2  1.16     0.0524     0.0628   0.0711 \n 5 Mock.6  1.24     0.0435     0.0931   0.0303 \n 6 Mock.10 1.82     0.0948     0.261    0.168  \n 7 Mock.1  2.00     0.0540     0.301    0.0400 \n 8 Mock.4  2.12     0.164      0.327    0.0256 \n 9 Mock.8  2.20     0.134      0.343    0.0161 \n10 Mock.5  2.96     0.179      0.472    0.129  \n\nMock.3 -> Mock.5 have the biggest difference in SMRE. Notably, its still only a factor of 5.5 difference.\nMock.7 -> Mock.9 have the smallest log difference.\nNext: Compute the actual and observed FC in proportions, for each of these pairs of communities. Perhaps define a function to spit out the relevant data frame, given any pair of samples, the phyloseq object (or calibrated phyloseq object?), and the bias vector? Actually, for the mocks, should use the “actual” table instead of calibrated.\nUse these objects,\n\n\nmock_actual\n\n\nOTU Table:          [ 9 taxa and 10 samples ]:\nTaxa are columns\n        Melampsora Dioszegia Epicoccum Fusarium Penicillium\nMock.1      0.0538    0.0108    0.0108   0.269       0.0108\nMock.2      0.0538    0.269     0.269    0.0108      0.0108\nMock.3      0.0108    0.269     0.0538   0.0108      0.269 \nMock.4      0.269     0.0538    0.0108   0.0538      0.269 \nMock.5      0.269     0.0108    0.0108   0.269       0.0538\nMock.6      0.0538    0.0538    0.0538   0.0108      0.0108\nMock.7      0.0108    0.269     0.0538   0.269       0.269 \nMock.8      0.269     0.0108    0.269    0.0538      0.0538\nMock.9      0.0108    0.0538    0.269    0.0538      0.0538\nMock.10     0.111     0.111     0.111    0.111       0.111 \n# … with 4 more taxa (columns)\n\nps.mock.pseudo\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 10 samples ]:\nsample_data() Sample Data:        [ 10 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nWe can use metacal::pairwise_ratios() to compute the FCs in abundances between all samples + for all taxa, given a phyloseq object.\n\n\nfcs <- list(Actual = mock_actual, Observed = ps.mock.pseudo) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = \"samples\", filter = FALSE) %>%\n  map_dfr(psmelt, .id = \"Type\") %>%\n  # redo sample.1 and sample.2 since missing for the mock\n  select(-sample.1, -sample.2) %>%\n  rename(Pair = Sample, Fold_change = Abundance) %>%\n  separate(Pair, str_c(\"Sample.\", 1:2), sep = \":\", remove = FALSE) %>%\n  mutate(across(OTU, factor, levels = bias %>% sort %>% names)) %>%\n  left_join(sme0 %>% select(Sample.1 = Sample, SMRE, Melampsora), \n    by = \"Sample.1\") %>%\n  left_join(sme0 %>% select(Sample.2 = Sample, SMRE, Melampsora), \n    by = \"Sample.2\", suffix = c(\".1\", \".2\"))\n\n\n\n\n\nfcs %>%\n  filter(Pair %in% c(\"Mock.5:Mock.3\", \"Mock.9:Mock.7\")) %>%\n  ggplot(aes(y = OTU, x = Fold_change, shape = Type, color = Type)) +\n  facet_grid(. ~ Pair) +\n  scale_shape_manual(values = c(Actual = 3, Observed = 1)) +\n  scale_color_brewer(type = \"qual\", palette = 6) +\n  geom_vline(xintercept = 1, color = \"black\", size = 0.2) +\n  geom_point(size = 2) +\n  theme_minimal_hgrid() +\n  scale_x_log10(limits = c(3e-3, 1e2), oob = scales::squish) +\n  labs(x = \"Fold change in proportion\") +\n  plot_annotation(\n    title = \"Actual and observed fold changes between pairs of mocks\"\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020-fc-mock-examples.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nCan see that on the left, the error is positive for all taxa, and of a similar magnitude (on the order of ~6X, as predicted) for all taxa except for Epicoccum, which dropped out during sequencing in Mock.5; and on the right, the error is smaller and not consistently positive or negative. Sign errors correspond to the observed and actual fold changes being on opposing sides of the vertical red line at 1.\ntodo: add the SMRE changes to the facet labels, and perhaps mark the expected\nWhat other types of plots, which might use all pairs of samples?\nwe could plot the observed vs. predicted error\nwe could check that the error really is taxon independent; one way to do this is to calc the correlation in LFC between observed and actual\n\n\nlvls <- sme0 %>% arrange(SMRE) %>% pull(Sample)\nfcs0 <- fcs %>%\n  # filter(Sample.1 < Sample.2) %>%\n  select(Type:Fold_change, SMRE.1:Melampsora.2) %>%\n  pivot_wider(names_from = Type, values_from = Fold_change) %>%\n  mutate(across(c(Sample.1, Sample.2), factor, levels = lvls))\n\n\n\n\n\nfcs0 %>%\n  filter(as.integer(Sample.1) < as.integer(Sample.2)) %>%\n  ggplot(aes(Actual, Observed, color = OTU)) +\n  geom_abline(color = \"grey\") +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_log10() +\n  facet_grid(Sample.1 ~ Sample.2) +\n  scale_color_brewer(type = \"qual\", palette = 3)\n\n\n\n\nNote how (especially) for Mock 1 and 6, the points follow a straight line with a greater slope than predicted. This seems likely related to the systematic deviation from the model that I observed.\nCheck that there is indeed very high correlations; remove the Epicoccum Mock-5 dropout first to avoid major distortions just from that.\n\n\ncorrs <- fcs0 %>%\n  filter(\n    Sample.1 != Sample.2,\n    !((Sample.1 == \"Mock.5\" | Sample.2 == \"Mock.5\") & OTU == \"Epicoccum\")\n  ) %>%\n  mutate(across(c(Actual, Observed), log10)) %>%\n  group_by(Pair) %>%\n  summarize(correlation = cor(Actual, Observed, method = \"pearson\"))\ncorrs %>% pull(correlation) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.9637  0.9827  0.9894  0.9874  0.9929  0.9989 \n\n# qplot(corrs$correlation)\n\n\n\nExperiment samples\nWe could just try picking a high and low Melampsora sample - perhaps from the mode of the peaks, rather than the extreme.\n\n\nsme0 %>%\n  filter(Samp_type == \"Experiment\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 548 x 5\n   Sample         SMRE Melampsora log10_SMRE       diff\n   <chr>         <dbl>      <dbl>      <dbl>      <dbl>\n 1 G12.T6.R4.TP1 0.996  0.00182     -0.00185 NA        \n 2 G1.T5.R2.TP1  1.24   0.0000218    0.0939   0.0958   \n 3 G11.T2.R4.TP1 1.24   0.0000836    0.0951   0.00114  \n 4 G12.T1.R2.TP1 1.28   0.0000166    0.108    0.0128   \n 5 G12.T2.R4.TP1 1.28   0.0000309    0.108    0.000619 \n 6 G11.T3.R3.TP1 1.29   0.000253     0.110    0.00119  \n 7 G2.T2.R4.TP1  1.29   0.0000220    0.110    0.000570 \n 8 G8.T4.R1.TP1  1.29   0.0000132    0.110    0.0000354\n 9 G9.T5.R3.TP1  1.29   0.0000714    0.110    0.000185 \n10 G4.T6.R3.TP1  1.29   0.000197     0.112    0.00139  \n# … with 538 more rows\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.0.5 (2021-03-31)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-04-21                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package      * version    date       lib source                           \n ade4           1.7-16     2020-10-28 [1] CRAN (R 4.0.3)                   \n ape            5.4-1      2020-08-13 [1] CRAN (R 4.0.2)                   \n assertthat     0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports      1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm       0.3.1      2021-03-07 [1] CRAN (R 4.0.5)                   \n Biobase        2.50.0     2020-10-27 [1] Bioconductor                     \n BiocGenerics   0.36.0     2020-10-27 [1] Bioconductor                     \n biomformat     1.18.0     2020-10-27 [1] Bioconductor                     \n Biostrings     2.58.0     2020-10-27 [1] Bioconductor                     \n broom          0.7.6      2021-04-05 [1] CRAN (R 4.0.5)                   \n bslib          0.2.4      2021-01-25 [1] CRAN (R 4.0.4)                   \n cellranger     1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli            2.4.0      2021-04-05 [1] CRAN (R 4.0.5)                   \n cluster        2.1.1      2021-02-14 [2] CRAN (R 4.0.5)                   \n codetools      0.2-18     2020-11-04 [2] CRAN (R 4.0.5)                   \n colorspace     2.0-0      2020-11-11 [1] CRAN (R 4.0.3)                   \n cowplot      * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon         1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table     1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI            1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr         2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest         0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill        1.2.4      2021-04-05 [1] Github (rstudio/distill@3ec93f1) \n downlit        0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr        * 1.0.5      2021-03-05 [1] CRAN (R 4.0.4)                   \n ellipsis       0.3.1      2020-05-15 [1] CRAN (R 4.0.0)                   \n evaluate       0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi          0.4.2      2021-01-15 [1] CRAN (R 4.0.3)                   \n farver         2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats      * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach        1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs             1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics       0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n ggbeeswarm   * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2      * 3.3.3      2020-12-30 [1] CRAN (R 4.0.4)                   \n glue           1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable         0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven          2.3.1      2020-06-01 [1] CRAN (R 4.0.1)                   \n here           1.0.1      2020-12-13 [1] CRAN (R 4.0.3)                   \n highr          0.8        2019-03-20 [1] CRAN (R 4.0.0)                   \n hms            1.0.0      2021-01-13 [1] CRAN (R 4.0.4)                   \n htmltools      0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n httr           1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph         1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges        2.24.1     2020-12-12 [1] Bioconductor                     \n iterators      1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib      0.1.3      2020-12-17 [1] CRAN (R 4.0.4)                   \n jsonlite       1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr          1.31       2021-01-27 [1] CRAN (R 4.0.3)                   \n lattice        0.20-41    2020-04-02 [2] CRAN (R 4.0.5)                   \n lifecycle      1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate      1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr       2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS           7.3-53.1   2021-02-12 [2] CRAN (R 4.0.5)                   \n Matrix         1.3-2      2021-01-06 [2] CRAN (R 4.0.5)                   \n metacal      * 0.2.0      2021-04-21 [1] Github (mikemc/metacal@cf3a3c7)  \n mgcv           1.8-34     2021-02-16 [2] CRAN (R 4.0.5)                   \n modelr         0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest       2.46.0     2020-10-27 [1] Bioconductor                     \n munsell        0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme           3.1-152    2021-02-04 [2] CRAN (R 4.0.5)                   \n nvimcom      * 0.9-102    2021-04-05 [1] local                            \n patchwork    * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute        0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq     * 1.34.0     2020-10-27 [1] Bioconductor                     \n pillar         1.6.0      2021-04-13 [1] CRAN (R 4.0.5)                   \n pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr           1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n prettyunits    1.1.1      2020-01-24 [1] CRAN (R 4.0.0)                   \n progress       1.2.2      2019-05-16 [1] CRAN (R 4.0.2)                   \n ps             1.6.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n purrr        * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6             2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer   1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp           1.0.6      2021-01-15 [1] CRAN (R 4.0.3)                   \n readr        * 1.4.0      2020-10-05 [1] CRAN (R 4.0.3)                   \n readxl         1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex         2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2       1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5          2.34.0     2020-10-27 [1] Bioconductor                     \n rhdf5filters   1.2.0      2020-10-27 [1] Bioconductor                     \n Rhdf5lib       1.12.1     2021-01-26 [1] Bioconductor                     \n rlang          0.4.10     2020-12-30 [1] CRAN (R 4.0.3)                   \n rmarkdown    * 2.7        2021-02-19 [1] CRAN (R 4.0.4)                   \n rprojroot      2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi     0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest          1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors      0.28.1     2020-12-09 [1] Bioconductor                     \n sass           0.3.1      2021-01-24 [1] CRAN (R 4.0.4)                   \n scales         1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo    1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq    * 0.5.3.9001 2020-10-06 [1] Github (mikemc/speedyseq@8daed32)\n stringi        1.5.3      2020-09-09 [1] CRAN (R 4.0.3)                   \n stringr      * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival       3.2-10     2021-03-16 [2] CRAN (R 4.0.5)                   \n tibble       * 3.1.1      2021-04-18 [1] CRAN (R 4.0.5)                   \n tidyr        * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect     1.1.0      2020-05-11 [1] CRAN (R 4.0.0)                   \n tidyverse    * 1.3.0      2019-11-21 [1] CRAN (R 4.0.0)                   \n useful         1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8           1.2.1      2021-03-12 [1] CRAN (R 4.0.5)                   \n vctrs          0.3.7      2021-03-29 [1] CRAN (R 4.0.5)                   \n vegan          2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor          0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr          2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun           0.22       2021-03-11 [1] CRAN (R 4.0.5)                   \n xml2           1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector        0.30.0     2020-10-27 [1] Bioconductor                     \n yaml           2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc       1.36.0     2020-10-27 [1] Bioconductor                     \n\n[1] /home/michael/R/x86_64-pc-linux-gnu-library/4.0\n[2] /usr/lib/R/library\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2020-11-12-leopold2020host-bias-sensitivity/index_files/figure-html5/unnamed-chunk-3-1.svg",
    "last_modified": "2021-10-25T12:24:55-07:00",
    "input_file": {}
  }
]
