[
  {
    "path": "posts/2022-01-30-hmp-stool-vagina-comparison/",
    "title": "Compare impact of bias in HMP stool and vagina samples",
    "description": "This report compares gut and vaginal microbiome profiles from the Human Microbiome Project to consider how the different ecological dynamics in each sample type might modulate the potential for bias to distort FCs in species proportions.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-30",
    "categories": [],
    "contents": "\n\nContents\nSetup\nExploratory plots and stats\nBreakdown of total diversity (gamma) into alpha and beta components\nOrder-2 diversity\n\nBias simulation\nVariation in species\nPreliminary checks\n\nFinal figures and numbers\nSession info\n\nSetup\n\n\nlibrary(here)\nlibrary(tidyverse)\nlibrary(speedyseq)\nlibrary(metacal)\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\nlibrary(ggbeeswarm)\nlibrary(ggdist)\nlibrary(ggridges)\n\nlibrary(fs)\ndir_create('_output')\n\n\n\nFirst, I load a phyloseq object with the Metaphlan3 profiles from the curatedMetagenomicData R package. This phyloseq object was created in notebook/_code/import-gut-datasets.Rmd. Filtering: I filter to just Bacteria, drop samples with no bacterial abundance, and drop species that don’t appear in at least two samples. I then renormalize to proportions. I also simplify the OTU names to just the species name.\nThen, I compute the most abundant species and its proportion, and add these to the sample data. In addition, I add the plug-in estimates of three alpha-diversity metrics to the sample data. These are the hill numbers of order 0, 1, and 2, equivalent to richness, the exponential of Shannon entropy, and Inverse Simpson index, respectively.\n\n\n#> here('notebook/_data/gut') %>% fs::dir_ls()\nps <- here('notebook/_data/gut',\n  '2021-03-31.HMP_2012.relative_abundance.phyloseq.rds'\n) %>% readRDS %>%\n  filter_tax_table(kingdom == 'Bacteria') %>%\n  prune_samples(sample_sums(.) > 0, .) %>% # to drop samples w/o bacteria %>%\n  filter_taxa2(~sum(.>0) >= 2) %>%\n  transform_sample_counts(close_elts) %>%\n  mutate_tax_table(.otu = species)\n# most abundant species and diversity\nx <- ps %>% as_tibble\nmost_abundant <- x %>%\n  with_groups(.sample, slice_max, .abundance, n = 1) %>%\n  select(.sample, top_species = species, top_species_prop = .abundance)\nfns <- list(\n  #> richness = ~sum(.x > 0),\n  diversity_q0 = ~sum(.x > 0),\n  diversity_q1 = ~vegan::diversity(.x, index = 'shannon') %>% exp,\n  diversity_q2 = ~vegan::diversity(.x, index = 'invsimpson')\n) %>%\n  map(as_mapper)\nmat <- ps %>% otu_table %>% orient_taxa(as = 'cols') %>% as('matrix')\ndiv <- fns %>%\n  map_dfc(~apply(mat, 1, .x))\ndiv1 <- bind_cols(most_abundant, div)\n#  join w/ ps object\nps <- ps %>%\n  left_join_sample_data(div1, by = '.sample')\nrm(most_abundant, div, div1, x)\n\n\n\nLet’s check the breakdown of samples by body site and subsite,\n\n\nsam <- ps %>% sample_data %>% as_tibble\nsam %>% count(body_site) %>% knitr::kable()\n\n\nbody_site\nn\nnasalcavity\n93\noralcavity\n414\nskin\n27\nstool\n147\nvagina\n67\n\nsam %>% count(body_site, body_subsite) %>% knitr::kable()\n\n\nbody_site\nbody_subsite\nn\nnasalcavity\nanterior_nares\n93\noralcavity\nbuccal_mucosa\n119\noralcavity\nhard_palate\n1\noralcavity\nkeratinized_gingiva\n6\noralcavity\npalatine_tonsils\n6\noralcavity\nsaliva\n5\noralcavity\nsubgingival_plaque\n7\noralcavity\nsupragingival_plaque\n127\noralcavity\nthroat\n7\noralcavity\ntongue_dorsum\n136\nskin\nl_retroauricular_crease\n9\nskin\nr_retroauricular_crease\n18\nstool\nstool\n147\nvagina\nmid_vagina\n2\nvagina\nposterior_fornix\n62\nvagina\nvaginal_introitus\n3\n\nSince only the posterior fornix of the vaginal samples has more than a few samples, we’ll restrict to just that subtype in what follows, along with the stool type/subtype.\n\n\nps_gv <- ps %>%\n  filter_sample_data(body_subsite %in% c('stool', 'posterior_fornix')) %>%\n  filter_taxa2(~ sum(.) > 0)\nsam <- ps_gv %>% sample_data %>% as_tibble\n\n\n\nExploratory plots and stats\nDistribution of alpha diversity across samples\n\n\nsam %>%\n  pivot_longer(starts_with('diversity')) %>%\n  mutate(\n    q = str_extract(name, '[0-2]'),\n    index = str_glue('q = {q}')\n  ) %>%\n  ggplot(aes(y = body_site, x = value)) +\n  scale_x_log10() +\n  facet_grid(.~index, scales = 'free', space = 'free') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  geom_density_ridges(stat = 'binline', scale = 0.90) +\n  labs(y = 'Body site', x = 'Diversity')\n\n\n\n\nDistribution of the proportion of the most abundant species in each sample,\n\n\nsam %>%\n  ggplot(aes(y = body_site, top_species_prop)) +\n  scale_x_log10() +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  expand_limits(x = 0.1) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  geom_density_ridges(stat = 'binline', scale = 1.90) +\n  labs(x = 'Proportion of most abundant species', y = 'Body site')\n\n\n\n\nWhich species tend to be most abundant?\n\n\nmake_table <- function(x) {\n  x %>%\n    mutate(\n      across(top_species, fct_infreq),\n      across(top_species, fct_lump_n, n = 5),\n    ) %>%\n    count(top_species) %>%\n    mutate(frac = close_elts(n)) %>%\n    knitr::kable(digits = 2)\n}\n\n# Vagina\nsam %>% filter(body_site == 'vagina') %>% make_table\n\n\ntop_species\nn\nfrac\nLactobacillus crispatus\n26\n0.42\nLactobacillus iners\n15\n0.24\nLactobacillus jensenii\n8\n0.13\nLactobacillus gasseri\n7\n0.11\nPrevotella amnii\n2\n0.03\nOther\n4\n0.06\n\n# Stool\nsam %>% filter(body_site == 'stool') %>% make_table\n\n\ntop_species\nn\nfrac\nBacteroides vulgatus\n45\n0.31\nBacteroides uniformis\n18\n0.12\nPrevotella copri\n15\n0.10\nBacteroides stercoris\n13\n0.09\nBacteroides ovatus\n9\n0.06\nOther\n47\n0.32\n\nIn both cases, a small number of closely related species dominant most samples. Notably, we do not see Gardnerella or Lactobacillus BVAB1 in the vaginal samples, or any Firmicutes or other non-Bacteroidetes in the gut samples. It is unclear whether this is due to the cohorts or bias in the protocol.\nBreakdown of total diversity (gamma) into alpha and beta components\nThis is more experimental. We can use the hillR package to compute alpha, beta, and gamma diversity as Hill numbers (effective number of species) for q = 0 (richness), q = 1 (exponential of Shannon entropy), and q = 2 (Inverse Simpson index). Note: Gamma diversity for q=0 (maybe also for other q) will increase with the number of samples, and so we’d expect it to be larger for stool simply due to the larger number of samples unless we subsample to a fixed number of samples for each body site. q=0 is also sensitive to read depth, which we don’t really have a way to account for here. Since we have a phylogeny, we can compute phylogenetic diversity as well as species diversity.\nFirst, get equal numbers of stool and vaginal (posterior fornix) samples.\n\n\nsam %>% count(body_site, body_subsite)\n\n\n# A tibble: 2 × 3\n  body_site body_subsite         n\n  <chr>     <chr>            <int>\n1 stool     stool              147\n2 vagina    posterior_fornix    62\n\nps_list <- list(\n  stool = ps_gv %>% filter_sample_data(body_site == 'stool'),\n  vagina = ps_gv %>% filter_sample_data(body_site == 'vagina')\n) %>%\n  # subsample to equal number of samples\n  map(filter_sample_data, row_number() <= 62) %>%\n  map(filter_taxa2, ~sum(.) > 0) %>%\n  map(orient_taxa, as = 'cols')\n\n\n\nThen compute the diversity breakdown for each body site,\n\n\n# Function that, given a phyloseq object, computes phylogenetic and species\n# diversity measures for the requested q values\nhill <- function(ps, q) {\n  ps <- ps %>% filter_taxa2(~sum(.) > 0) %>% orient_taxa(as = 'cols')\n  suppressMessages(\n    tibble(q = !!q) %>%\n      mutate(\n        div_taxa = map(q, ~hillR::hill_taxa_parti(otu_table(ps), .x)),\n        div_phylo = map(q, ~hillR::hill_phylo_parti(otu_table(ps), phy_tree(ps), .x)),\n      ) %>%\n      unnest(c(div_taxa, div_phylo), names_repair = 'universal') %>%\n      select(q = q...1, starts_with(c('TD', 'PD')))\n  )\n  }\ndiv <- ps_list %>%\n  map_dfr(hill, q = c(0, 1, 2), .id = 'body_site')\n\n\n\n\n\ndiv %>% knitr::kable(digits = 1)\n\n\nbody_site\nq\nTD_gamma\nTD_alpha\nTD_beta\nPD_gamma\nPD_alpha\nPD_beta\nstool\n0\n347.0\n80.1\n4.3\n37.6\n12.5\n3.0\nstool\n1\n36.3\n10.4\n3.5\n4.4\n2.4\n1.8\nstool\n2\n18.7\n5.1\n3.7\n2.6\n1.5\n1.7\nvagina\n0\n112.0\n7.3\n15.4\n18.5\n2.1\n9.0\nvagina\n1\n6.2\n1.6\n4.0\n1.7\n0.8\n2.2\nvagina\n2\n4.1\n1.3\n3.2\n1.2\n0.7\n1.8\n\n\n\ndiv %>%\n  pivot_longer(starts_with(c('TD', 'PD'))) %>%\n  pivot_wider(names_from = body_site) %>% \n  knitr::kable(digits = 1)\n\n\nq\nname\nstool\nvagina\n0\nTD_gamma\n347.0\n112.0\n0\nTD_alpha\n80.1\n7.3\n0\nTD_beta\n4.3\n15.4\n0\nPD_gamma\n37.6\n18.5\n0\nPD_alpha\n12.5\n2.1\n0\nPD_beta\n3.0\n9.0\n1\nTD_gamma\n36.3\n6.2\n1\nTD_alpha\n10.4\n1.6\n1\nTD_beta\n3.5\n4.0\n1\nPD_gamma\n4.4\n1.7\n1\nPD_alpha\n2.4\n0.8\n1\nPD_beta\n1.8\n2.2\n2\nTD_gamma\n18.7\n4.1\n2\nTD_alpha\n5.1\n1.3\n2\nTD_beta\n3.7\n3.2\n2\nPD_gamma\n2.6\n1.2\n2\nPD_alpha\n1.5\n0.7\n2\nPD_beta\n1.7\n1.8\n\nOrder-2 diversity\nWhat is the GM, GSD, and GSE of order-2 diversity in each body site?\n\n\ndiv_q2_stats <- sam %>%\n  with_groups(body_site, summarize, \n    gm = gm_mean(diversity_q2),\n    gsd = gm_sd(diversity_q2),\n    gse = gsd ^ (1 / sqrt(n()))\n  )\ndiv_q2_stats %>%\n  knitr::kable(digits = 2)\n\n\nbody_site\ngm\ngsd\ngse\nstool\n6.31\n1.69\n1.04\nvagina\n1.39\n1.61\n1.06\n\nWe’ll save this for use in the manuscript,\n\n\nwrite_csv(div_q2_stats, path('_output', 'div_q2_stats.csv'))\n\n\n\nBias simulation\nTo assess the relative importance of bias for proportion-based DA analyses in the two ecosystems, we will consider the variation in the mean efficiency across samples for a large number of possible taxonomic biases, under the assumption that the measured profiles reflected the truth.\nThe following function samples random bias vectors from a multivariate lognormal distribution with a given covariance structure and geometric standard deviation across the efficiencies.\n\n\n# Returns a matrix with taxa as columns\nsample_bias <- function(n, gsd, vcv, taxa_as = 'cols') {\n  stopifnot(isSymmetric(vcv))\n  stopifnot(n > 1)\n  n_taxa <- nrow(vcv)\n  bias <- MASS::mvrnorm(n, mu = rep(0, n_taxa), Sigma = vcv) %>%\n    t %>%\n    scale %>%\n    {. * log(gsd)} %>%\n    exp\n  if (taxa_as == 'cols')\n    bias <- t(bias)\n  bias\n}\n#> x <- sample_bias(3, gsd = 3, phy_vcv)\n#> x %>% apply(1, gm_sd) %>% head\n#> x[1,] %>% qplot + scale_x_log10()\n#> sample_bias(3, gsd = 3, phy_vcv, taxa_as = 'rows') %>% head\n\n\n\nTo choose a GSD for the simulations, let’s examine the bias estimated by McLaren, Willis, and Callahan (2019) for the Costea et al. (2017) Phase 2 experimental protocols,\n\n\nbias_costea <- '_data/mclaren2019cons-table2-mod.tsv' %>% read_tsv\nbias_costea_gsd <- bias_costea %>%\n  summarize(across(-Taxon, gm_sd))\nbias_costea_gsd %>%\n  knitr::kable(digits = 1)\n\n\nH\nQ\nW\nH/Q\nH/W\nQ/W\n7.7\n2.9\n3.2\n4.8\n3.6\n2.4\n\nThe strength of bias as quantified by the GSD in species efficiencies is much larger for protocol H than the other two protocols. The GM of the GSD of the three protocols is 4.15. Let’s round this to a simple whole number 4 and take this as the GSD for our simulations.\nFor the IID and phylogenetic-covariance models, simulate 1000 replicate bias vectors.\n\n\nset.seed(42)\nR <- 1000\ngsd_sim <- 4\nreps <- list(\n  iid = diag(ntaxa(ps_gv)),\n  vcv = ps_gv %>% phy_tree %>% ape::vcv()\n  #> gram = gram_vcv\n) %>%\n  map_dfr(.id = 'sim_type',\n    ~sample_bias(n = R, gsd = gsd_sim, vcv = .x) %>%\n      split(., row(.)) %>%\n      enframe(\".idx\", \"bias\")\n  )\n\n\n\nFor each replicate, compute the mean efficiency of each sample, assuming that the observed profiles are the truth and the simulated vector is the bias. Summarize the variation in the mean efficiency for the replicate by the GSD.\n\n\nreps_me <- reps %>%\n  mutate(\n    mean_efficiency = map(bias, ~mean_efficiency(ps_gv, .x, type = 'actual')),\n    across(mean_efficiency, map, enframe, '.sample', 'mean_efficiency')\n  ) %>%\n  select(-bias) %>%\n  unnest(mean_efficiency) %>%\n  left_join(ps_gv %>% sample_data %>% as_tibble, by = '.sample')\nreps_me_summ <- reps_me %>%\n  with_groups(c(sim_type, body_site, .idx), summarize,\n    across(mean_efficiency, gm_sd)\n  )\n\n\n\n\n\nreps_me_summ %>%\n  ggplot(aes(y = sim_type, x = mean_efficiency)) +\n  facet_wrap(~body_site, ncol = 1) +\n  scale_x_log10() +\n  geom_vline(xintercept = c(1,gsd_sim), color = 'grey') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.5), scale = 0.95) +\n  labs(x = 'GSD of mean efficiency', y = 'Simulation type')\n\n\n\n\nNote, despite always forcing a GSD of 3 on the efficiencies, we sometimes see GSDs in the mean efficiency that are larger than 3, particularly in the vaginal communities. This makes some sense: We expect the variation in the efficiency of vaginal communities to be driven by a just a few species, and the there is a non-negligible chance that they end up with a much higher/lower mean efficiency than typical.\nQuestion: How does the mean efficiency GSD scale with the efficiency GSD? When we compare this variation to that in the species proportions, the scale/value of GSD will matter. However, it might not matter for comparing to the vaginal MB.\nHow much greater is the GM of the GSD in the vaginal comms versus stool?\n\n\nreps_me_summ %>%\n  with_groups(c(body_site, sim_type), summarize, \n    across(mean_efficiency, gm_mean)) %>%\n  pivot_wider(names_from = body_site, values_from = mean_efficiency) %>%\n  mutate(vagina/stool) %>%\n  knitr::kable(digits = 2)\n\n\nsim_type\nstool\nvagina\nvagina/stool\niid\n1.65\n2.61\n1.58\nvcv\n1.68\n2.70\n1.61\n\nUsing the median instead of the GM should give a similar answer,\n\n\nreps_me_summ %>%\n  with_groups(c(body_site, sim_type), summarize, \n    across(mean_efficiency, median)) %>%\n  pivot_wider(names_from = body_site, values_from = mean_efficiency) %>%\n  mutate(vagina/stool) %>%\n  knitr::kable(digits = 2)\n\n\nsim_type\nstool\nvagina\nvagina/stool\niid\n1.61\n2.48\n1.54\nvcv\n1.63\n2.53\n1.55\n\nNote that the type of simulation has a negligible impact on these numbers.\nLet’s compute the GM, GSD, and GSE of the GM for the difference (ratio) between gut and vaginal samples.\n\n\nreps_me_summ %>%\n  with_groups(c(body_site, sim_type), summarize, \n    GM = gm_mean(mean_efficiency),\n    GSD = gm_sd(mean_efficiency),\n    # GSE = exp(sd(log(mean_efficiency)) / sqrt(n())),\n    GSE = GSD ^ (1 / sqrt(n()))\n  ) %>%\n  knitr::kable(digits = 4)\n\n\nbody_site\nsim_type\nGM\nGSD\nGSE\nstool\niid\n1.6452\n1.1374\n1.0041\nstool\nvcv\n1.6771\n1.1730\n1.0051\nvagina\niid\n2.6069\n1.4565\n1.0120\nvagina\nvcv\n2.7031\n1.5930\n1.0148\n\nAnd if the difference,\n\n\nreps_me_summ_diff <- reps_me_summ %>%\n  pivot_wider(names_from = body_site, values_from = mean_efficiency) %>%\n  mutate(ratio = vagina / stool) %>%\n  with_groups(c(sim_type), summarize, \n    gm = gm_mean(ratio),\n    gsd = gm_sd(ratio),\n    gse = gsd ^ (1 / sqrt(n()))\n  )\nreps_me_summ_diff %>%\n  knitr::kable(digits = 3)\n\n\nsim_type\ngm\ngsd\ngse\niid\n1.585\n1.485\n1.013\nvcv\n1.612\n1.636\n1.016\n\n\n\nwrite_csv(reps_me_summ_diff , path('_output', 'reps_me_summ_diff.csv'))\n\n\n\nLet’s also check the distribution of the ratio (geometric difference),\n\n\nreps_me_summ %>%\n  pivot_wider(names_from = body_site, values_from = mean_efficiency) %>%\n  mutate(ratio = vagina / stool) %>%\n  ggplot(aes(y = sim_type, x = ratio)) +\n  scale_x_log10() +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.5), scale = 0.95) +\n  labs(y = 'Simulation type', x = 'GSD in vagina / GSD in stool')\n\n\n\n\nNote that there is a decent fraction of simulations in which the variation in the mean efficiency is lower in the vaginal samples, despite it typically being higher.\nThe large number of simulations (1000) makes the GSE very small; however, this number does not account for the limited number of gut and vaginal samples. In other words, we have precisely estimated the difference for these particular samples.\nVariation in species\nFor analysis of LFCs in proportions, what matters is the variation in the species proportions relative to the mean efficiency. Therefore we should also consider whether the species proportions vary less in the more diverse gut. To do so, I will measure the GSD in the (zero-replaced) proportion of each species within the given sample type that passes a prevalence filter within that sample type.\nPreliminary checks\nTo figure out how to replace zeros, let’s check what the min positive abundances look like for various species.\n\n\nx <- ps_gv %>%\n  as_tibble\n\n\n\n\n\nx %>%\n  filter(.abundance > 0) %>%\n  with_groups(c(.otu, body_site), summarize, \n    min_pos = min(.abundance)) %>%\n  ggplot(aes(x = min_pos, y = body_site)) +\n  scale_x_log10() +\n  labs(x = 'Min. positive proportion of the species', y = 'Body site') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  geom_density_ridges(stat = 'binline', alpha = 0.3, scale = 0.95)\n\n\n\n\nWhat about the min positive proportion in the sample?\n\n\nx %>%\n  filter(.abundance > 0) %>%\n  with_groups(c(.sample, body_site), summarize, \n    min_pos = min(.abundance)) %>%\n  ggplot(aes(x = min_pos, y = body_site)) +\n  scale_x_log10() +\n  labs(x = 'Min. positive proportion of the sample', y = 'Body site') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  geom_density_ridges(stat = 'binline', alpha = 0.3, scale = 0.95)\n\n\n\n\nWe also need to choose what species to consider as candidates for a DA analysis in the given ecosystem. For simplicity, let’s use the filtering criterion we used in the MOMSPI diversity regression. We’ll do this filtering and the subsequent analysis separately within each sample type.\n\n\nps_list <- list(\n  stool = ps_gv %>% filter_sample_data(body_site == 'stool'),\n  vagina = ps_gv %>% filter_sample_data(body_site == 'vagina')\n) %>%\n  map(filter_taxa2, ~ mean(. >= 1e-2) >= 0.05 | mean(. >= 1e-3) >= 0.15) %>%\n  map(orient_taxa, as = 'cols')\nps_list %>% map_int(nsamples)\n\n\n stool vagina \n   147     62 \n\nps_list %>% map_int(ntaxa)\n\n\n stool vagina \n    66     13 \n\nNote that there are many more species passing this criterion in stool.\nI will replace zeros by adding a small pseudo-value to all proportions. I expect the choice of pseudo-value will have a large impact on the GSDs of a species, so I will try a wide range of values. Note, I am not renormalizing the proportions after adding the psuedo-value, since we’ve already filtered out many species. However, the renormalization would involve dividing all proprotions by the same factor and so would not affect the resulting GSDs. (This factor is equal to \\(1 + k\\episilon\\), where \\(k\\) is the number of pre-filtered species and \\(\\epsilon\\) is the pseudo-value. Since \\(\\episilon \\ll 1/k\\) except perhaps for the highest \\(\\epsilon = 10^{-3}\\), this factor is generally close to 1 anyways.)\n\n\nmin_vals <- c(1e-6, 1e-5, 1e-4, 1e-3)\n\ngsd <- ps_list %>%\n  map_dfr(as_tibble) %>%\n  with_groups(c(.otu, body_site), summarize,\n    min = min_vals,\n    gsd = map_dbl(min_vals, ~gm_sd(.abundance + .x))\n  )\n\n\n\n\n\ngsd %>%\n  ggplot(aes(x = gsd, y = as.factor(min), \n      fill = body_site, color = body_site)) +\n  # facet_wrap(~body_site) +\n  scale_x_log10() +\n  expand_limits(x = 1) +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  geom_density_ridges(stat = 'binline', scale = 0.95, alpha = 0.3)\n\n\n\n\nThe GSDs tend to be larger in the vaginal microbiome, regardless of which min value is used.\nWhat is the difference between gut and vaginal GSDs? Determine by taking the geometric mean (GM) of the GSDs of various species.\n\n\ngsd %>%\n  ggplot(aes(x = gsd, y = as.factor(min), \n      fill = body_site, color = body_site)) +\n  scale_x_log10() +\n  stat_summary() +\n  expand_limits(x = 1)\n\n\n\n\n\n\nspecies_gsd_stats <- gsd %>%\n  with_groups(c(body_site, min), summarize, across(gsd, gm_mean)) %>%\n  pivot_wider(names_from = body_site, values_from = gsd) %>%\n  mutate(vagina/stool)\nspecies_gsd_stats \n\n\n# A tibble: 4 × 4\n       min stool vagina `vagina/stool`\n     <dbl> <dbl>  <dbl>          <dbl>\n1 0.000001 37.2   65.4            1.76\n2 0.00001  15.7   27.5            1.75\n3 0.0001    6.82  11.9            1.74\n4 0.001     3.09   5.37           1.74\n\nNote, the difference between body sites has hardly any dependence on the pseudo-value.\n\n\nspecies_gsd_stats %>%\n  janitor::clean_names() %>%\n  write_csv(path('_output', 'species_gsd_stats.csv'))\n\n\n\nFinal figures and numbers\n\n\n# Alpha diversity\np_div <- sam %>%\n  ggplot(aes(y = body_site, x = diversity_q2)) +\n  scale_x_log10() +\n  geom_boxplot(outlier.shape = NA) +\n  geom_quasirandom(groupOnX = FALSE, alpha = 0.75) +\n  # theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  # scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  # geom_density_ridges(stat = 'binline', scale = 0.90) +\n  labs(y = 'Body site', x = 'Order-2 diversity')\n# p_div \n\n# Variation in species proportions\np_species_gsd <- gsd %>%\n  filter(min == 1e-4) %>%\n  ggplot(aes(x = gsd, y = body_site)) +\n  labs(y = 'Body site', x = \"GSD[proportion]\") +\n  scale_x_log10() +\n  expand_limits(x = 1) +\n  # geom_vline(xintercept = c(1,gsd_sim), color = 'grey') +\n  geom_boxplot(outlier.shape = NA) +\n  geom_quasirandom(groupOnX = FALSE, alpha = 0.75)\n  # theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  # scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  # geom_density_ridges(stat = 'binline', scale = 0.90)\n\n# GSD in mean eff in simulations\np_me_gsd <- reps_me_summ %>%\n  filter(sim_type == 'iid') %>%\n  ggplot(aes(y = body_site, x = mean_efficiency)) +\n  scale_x_log10() +\n  # expand_limits(x = 0.85) +\n  geom_vline(xintercept = c(gsd_sim), color = 'grey') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.5), scale = 0.95) +\n  labs(x = 'GSD[mean efficiency]', y = 'Body site')\n# p_me_gsd \n\n(p_div + ggtitle('Within-sample diversity')) /\n  (p_me_gsd + ggtitle(\"Cross-sample variation in the mean efficency\")) /\n  (p_species_gsd + ggtitle(\"Cross-sample variation in species' proportions\")) +\n  plot_annotation(tag_levels = 'A') +\n  plot_layout() &\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) \n\n\n\n\nWe can also try putting the GSD in proportions and in mean efficiency on a common scale,\n\n\n# Variation in species proportions\np_species_gsd <- gsd %>%\n  filter(min == 1e-4) %>%\n  ggplot(aes(x = gsd, y = body_site)) +\n  labs(y = 'Body site', x = \"GSD[proportion]\") +\n  scale_x_log10(limits = c(0.9, 200)) +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  geom_vline(xintercept = c(1,gsd_sim), color = 'grey') +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  # geom_density_ridges(stat = 'binline', scale = 0.90)\n  geom_density_ridges(jittered_points = TRUE, scale = 0.95)\n\n# GSD in mean eff in simulations\np_me_gsd <- reps_me_summ %>%\n  filter(sim_type == 'iid') %>%\n  ggplot(aes(y = body_site, x = mean_efficiency)) +\n  scale_x_log10(limits = c(0.9, 200)) +\n  geom_vline(xintercept = c(1,gsd_sim), color = 'grey') +\n  theme_ridges(grid = FALSE, center_axis_labels = TRUE) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, .7))) +\n  stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.5), scale = 0.95) +\n  labs(x = 'GSD[mean efficiency]', y = 'Body site')\n# p_me_gsd \n\np_species_gsd / p_me_gsd\n\n\n\n\nThis plot makes it clear that the GSD in mean efficiency is generally smaller than that in the species proportions, suggesting that for the strength of bias in these simulations (GSD=4), that bias is unlikely to have a large impact. However, the GSD in species proportions is highly dependent on the pseudocount; also, our choice of GSD=4 is simply for illustration. Thus we should not overinterpret this result.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-03-21\n pandoc   2.14.2 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package           * version    date (UTC) lib source\n ade4                1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                 5.6-1      2022-01-07 [1] CRAN (R 4.1.2)\n assertthat          0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports           1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n beeswarm            0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase             2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics        0.38.0     2021-05-19 [1] Bioconductor\n biomformat          1.20.0     2021-05-19 [1] Bioconductor\n Biostrings          2.60.2     2021-08-05 [1] Bioconductor\n bit                 4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64               4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops              1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n bookdown            0.24       2021-09-02 [1] CRAN (R 4.1.1)\n broom               0.7.11     2022-01-03 [1] CRAN (R 4.1.2)\n bslib               0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem              1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger          1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                 3.2.0      2022-02-14 [1] CRAN (R 4.1.2)\n cluster             2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n clusterGeneration   1.3.7      2020-12-15 [1] CRAN (R 4.1.1)\n coda                0.19-4     2020-09-30 [1] CRAN (R 4.0.2)\n codetools           0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace          2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n combinat            0.0-8      2012-10-29 [1] CRAN (R 4.1.1)\n cowplot           * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon              1.5.0      2022-02-14 [1] CRAN (R 4.1.2)\n data.table          1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                 1.1.2      2021-12-20 [1] CRAN (R 4.1.2)\n dbplyr              2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n deSolve             1.30       2021-10-07 [1] CRAN (R 4.1.1)\n digest              0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill             1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional      0.3.0      2022-01-05 [1] CRAN (R 4.1.2)\n downlit             0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr             * 1.0.8      2022-02-08 [1] CRAN (R 4.1.2)\n ellipsis            0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate            0.14       2019-05-28 [1] CRAN (R 4.0.0)\n expm                0.999-6    2021-01-13 [1] CRAN (R 4.1.1)\n fansi               1.0.2      2022-01-14 [1] CRAN (R 4.1.2)\n farver              2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap             1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n fastmatch           1.1-3      2021-07-23 [1] CRAN (R 4.1.0)\n forcats           * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach             1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                * 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n geiger              2.0.7      2020-06-02 [1] CRAN (R 4.1.1)\n generics            0.1.2      2022-01-31 [1] CRAN (R 4.1.2)\n GenomeInfoDb        1.28.4     2021-09-05 [1] Bioconductor\n GenomeInfoDbData    1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm        * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist            * 3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggplot2           * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n ggridges          * 0.5.3      2021-01-08 [1] CRAN (R 4.0.4)\n glue                1.6.1      2022-01-22 [1] CRAN (R 4.1.2)\n gtable              0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven               2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here              * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr               0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hillR               0.5.1      2021-03-02 [1] CRAN (R 4.1.2)\n hms                 1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools           0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr                1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph              1.2.11     2022-01-04 [1] CRAN (R 4.1.2)\n IRanges             2.26.0     2021-05-19 [1] Bioconductor\n iterators           1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n janitor             2.1.0      2021-01-05 [1] CRAN (R 4.0.4)\n jquerylib           0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite            1.7.3      2022-01-17 [1] CRAN (R 4.1.2)\n knitr               1.37       2021-12-16 [1] CRAN (R 4.1.2)\n lattice             0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle           1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate           1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr            2.0.2      2022-01-26 [1] CRAN (R 4.1.2)\n maps                3.4.0      2021-09-25 [1] CRAN (R 4.1.1)\n MASS                7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix              1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise             2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal           * 0.2.0.9010 2022-02-15 [1] Github (mikemc/metacal@f56792d)\n mgcv                1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n mnormt              2.0.2      2020-09-01 [1] CRAN (R 4.1.1)\n modelr              0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest            2.48.0     2021-05-19 [1] Bioconductor\n munsell             0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n mvtnorm             1.1-3      2021-10-08 [1] CRAN (R 4.1.1)\n nlme                3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n numDeriv            2016.8-1.1 2019-06-06 [1] CRAN (R 4.0.0)\n nvimcom           * 0.9-102    2022-03-12 [1] local\n patchwork         * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute             0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phangorn            2.8.1      2021-12-15 [1] CRAN (R 4.1.2)\n phyloseq          * 1.36.0     2021-05-19 [1] Bioconductor\n phytools            1.0-1      2022-01-03 [1] CRAN (R 4.1.2)\n pillar              1.7.0      2022-02-01 [1] CRAN (R 4.1.2)\n pkgconfig           2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plotrix             3.8-2      2021-09-08 [1] CRAN (R 4.1.1)\n plyr                1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr             * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n quadprog            1.5-8      2019-11-20 [1] CRAN (R 4.0.0)\n R6                  2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp                1.0.8      2022-01-13 [1] CRAN (R 4.1.2)\n RCurl               1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr             * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl              1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex              2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2            1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5               2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters        1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib            1.14.2     2021-07-06 [1] Bioconductor\n rlang               1.0.1      2022-02-03 [1] CRAN (R 4.1.2)\n rmarkdown         * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot           2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi          0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest               1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors           0.30.2     2021-10-03 [1] Bioconductor\n sass                0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales              1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n scatterplot3d       0.3-41     2018-03-14 [1] CRAN (R 4.1.1)\n sessioninfo         1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n snakecase           0.11.0     2019-05-25 [1] CRAN (R 4.0.0)\n speedyseq         * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi             1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr           * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n subplex             1.7        2022-01-16 [1] CRAN (R 4.1.2)\n survival            3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble            * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr             * 1.2.0      2022-02-01 [1] CRAN (R 4.1.2)\n tidyselect          1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse         * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n tmvnsim             1.0-2      2016-12-15 [1] CRAN (R 4.1.1)\n tzdb                0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful              1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8                1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs               0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan               2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor               0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom               1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr               2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun                0.29       2021-12-14 [1] CRAN (R 4.1.2)\n xml2                1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector             0.32.0     2021-05-19 [1] Bioconductor\n yaml                2.2.2      2022-01-25 [1] CRAN (R 4.1.2)\n zlibbioc            1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nCostea, Paul I, Georg Zeller, Shinichi Sunagawa, Eric Pelletier, Adriana Alberti, Florence Levenez, Melanie Tramontano, et al. 2017. “Towards standards for human fecal sample processing in metagenomic studies.” Nat. Biotechnol. 35 (11): 1069–76. https://doi.org/10.1038/nbt.3960.\n\n\nMcLaren, Michael R, Amy D Willis, and Benjamin J Callahan. 2019. “Consistent and correctable bias in metagenomic sequencing experiments.” Elife 8 (September): 46923. https://doi.org/10.7554/eLife.46923.\n\n\n\n\n",
    "preview": "posts/2022-01-30-hmp-stool-vagina-comparison/hmp-stool-vagina-comparison_files/figure-html5/diversity-1.svg",
    "last_modified": "2022-06-05T15:29:12-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-20-vieirasilva2019quan/",
    "title": "Explore bias sensitivity of Vieira-Silva et al (2019) QMP analysis",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-20",
    "categories": [
      "ref:vieirasilva2019quan",
      "bias sensitivity",
      "absolute abundance"
    ],
    "contents": "\n\nContents\nSetup\nR setup\nData setup\n\nExplore data\nReproduce QMP Spearman analysis\nVisually inspect variation for top hits\nCalprotectin\nMoisture\n\nCheck if hits are driven by differential prevalence\n\nBias sensitivity analysis\nAnalysis\nTop hits with low prevalence\nTop hits with high prevalence\nSummary\n\n\nThis document reanalyzes the ‘Quantitative Microbiome Profiles’ of Vieira-Silva et al. (2019).\nSetup\nR setup\n\n\nlibrary(here)\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(ggridges)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9009'\n\n\n\ntheme_set(theme_cowplot())\n\n\n\nData setup\nThe genus-level ‘Quantitative Microbiome Profiles’ from Vieira-Silva et al. (2019) are available for download at http://raeslab.org/software/QMP2/, and the sample metadata is available in the supplemental content at the journal site.\n\n\ndata_path <- here('notebook/_data/vieirasilva2019quan')\ndir_create(data_path)\n# Supplementary tables from the nature website; contains the metadata\nfn <- path(data_path, 'supplementary-data-1.xlsx')\nif (!file_exists(fn)) {\n  download.file(\n    'https://static-content.springer.com/esm/art%3A10.1038%2Fs41564-019-0483-9/MediaObjects/41564_2019_483_MOESM3_ESM.xlsx',\n    fn\n  )\n  file_chmod(fn, '-w')\n}\n# QMP proiles from the Raes lab website\nfn <- path(data_path, 'qmp-matrix-genus.tsv')\nif (!file_exists(fn)) {\n  download.file('http://raeslab.org/software/QMP2/QMP.matrix.tsv', fn)\n  file_chmod(fn, '-w')\n}\n\n\n\nI’ll read in the metadata and QMP profiles into a phyloseq object. The metadata is Table S1 of the Excel spreadsheet. There is an extra value in the BMI column of Table S1 that will be dropped in the import step below.\n\n\notu <- path(data_path, 'qmp-matrix-genus.tsv') %>%\n  read.table() %>%\n  as('matrix') %>%\n  otu_table(taxa_are_rows = FALSE)\nsam <- path(data_path, 'supplementary-data-1.xlsx') %>%\n  readxl::read_excel(sheet = 'Table S1', range = 'A2:L174', na = \"NA\")\noriginal_column_names <- names(sam)\nps <- phyloseq(\n  otu, \n  sam %>% janitor::clean_names() %>% sample_data\n) %>%\n  rename_sample_data(\n   faecal_calprotectin = faecal_calprotectin_mg_g,\n   moisture_content = moisture_content_percent\n  )\nstopifnot(setequal(sample_names(ps), sample_names(otu)))\nsam <- ps %>% sample_data %>% as_tibble %>% glimpse\n\n\nRows: 160\nColumns: 12\n$ .sample                           <chr> \"DC02\", \"DC03\", \"DC04\", \"D…\n$ diagnosis                         <chr> \"CD\", \"CD\", \"CD\", \"CD\", \"C…\n$ age                               <dbl> 45, 37, 64, 52, 55, 32, 48…\n$ gender                            <chr> \"F\", \"M\", \"F\", \"M\", \"F\", \"…\n$ bmi                               <dbl> 23.8, 25.4, 21.8, 20.9, 21…\n$ serum_alkaline_phosphatase_u_l    <dbl> 57, 62, 102, 54, 58, 50, 1…\n$ faecal_calprotectin               <dbl> 134.621, 281.774, 64.359, …\n$ serum_crp_mg_l                    <dbl> 13.4, 1.8, 1.0, 0.2, 1.2, …\n$ average_faecal_cell_count_cells_g <dbl> 61000000000, 8409441603, 3…\n$ moisture_content                  <dbl> 0.731, 0.827, 0.879, 0.758…\n$ dmm_enterotype                    <chr> \"Bact2\", \"Bact2\", \"Bact2\",…\n$ rmp_observed_richness_n_genera    <dbl> 69, 62, 86, 75, 90, 94, 77…\n\nExplore data\nThere are 160, with the following counts by disease status,\n\n\nsam %>% count(diagnosis)\n\n\n# A tibble: 6 × 2\n  diagnosis     n\n  <chr>     <int>\n1 CD           28\n2 mHC          65\n3 PSC          18\n4 PSC-CD       17\n5 PSC-UC       19\n6 UC           13\n\nThe QMP profiles are such that the sum within a sample should equal the reported cell counts per gram in the sample data; let’s check.\n\n\nall.equal(sample_sums(ps), sam$average_faecal_cell_count_cells_g)\n\n\n[1] \"names for target but not for current\" \n[2] \"Mean relative difference: 0.001195002\"\n\ncor(sample_sums(ps), sam$average_faecal_cell_count_cells_g)\n\n\n[1] 0.9999956\n\nThis small difference may be down to rounding error, since apparently the entires in the QMP matrix have been rounded to integers:\n\n\notu %>% c %>% {all.equal(., round(.))}\n\n\n[1] TRUE\n\nIt would be nice to have read counts; however, I don’t think it’s possible to obtain read counts from the available information here. Perhaps it would be possible to reverse the QMP calculation if we had the copy-number-variation information.\nSince we lack read-count information, we will ignore the sequencing-count noise, which was also done in the original paper.\nOur primary covariates of interest are Faecal calprotectin and moisture content.\n\n\nsam %>% select(faecal_calprotectin, moisture_content) %>% summary\n\n\n faecal_calprotectin moisture_content\n Min.   :  30.00     Min.   :0.5370  \n 1st Qu.:  30.00     1st Qu.:0.7040  \n Median :  50.33     Median :0.7830  \n Mean   : 205.17     Mean   :0.7736  \n 3rd Qu.: 164.08     3rd Qu.:0.8345  \n Max.   :1800.00     Max.   :0.9530  \n NA's   :11          NA's   :17      \n\n\n\nsam %>%\n  ggplot(aes(x = faecal_calprotectin)) +\n  scale_x_log10() +\n  geom_histogram()\n\n\n\n\nNote that a large fraction of calprotectin measurements are precisely at 30, suggesting this is a value assigned to samples that were below the detection limit of the assay. Also, the values vary over multiple orders of magnitude.\n\n\nsam %>%\n  ggplot(aes(x = moisture_content)) +\n  geom_histogram()\n\n\n\n\nIn contrast, the moisture varies relatively continuously\nReproduce QMP Spearman analysis\nLet’s try to reproduce the results from the paper. We’ll focus on the Spearman correlations of the genera absolute abundances with faecal calprotectin and stool moisture content. The relevant manuscript text is\n\nApplying QMP on the combined PSC/IBD/mHC data set, we identified 11 genera as significantly correlat-ing with faecal calprotectin concentrations (Spearman correlation, n= 149, FDR < 0.05; Fig. 3a and Supplementary Table 6). Stool mois-ture content had 45 associated taxa (Spearman correlation, n= 143, FDR < 0.05; Supplementary Table 6). Combining both variables, only 6 out of 11 positive(+) or negative(−) calprotectin associations remained significant when controlling for faecal water content vari-ation: Anaerostipes(−), Escherichia(+), Fusobacterium(+), Gemmiger(−), Streptococcus(+) and Veillonella(+) (nested linear model on QMP rank abundances, n= 133, FDR < 0.05; Fig. 3a and Supplementary Table 6).\n\nA summary table with the Spearman results are Table S6 of the supplementary data Excel sheet,\n\n\nstudy_res <- path(data_path, 'supplementary-data-1.xlsx') %>%\n  readxl::read_excel(sheet = 'Table S6', na = \"NA\")\n\n\n\n\n\nqmp_spearman <- ps %>%\n  prune_taxa(str_subset(taxa_names(.), 'unclassified', negate = TRUE), .) %>%\n  as_tibble %>%\n  with_groups(.otu, nest) %>%\n  mutate(\n    qmp_calprotectin_spearman = map(data, \n      ~cor.test(data = .x,\n        ~ .abundance + faecal_calprotectin, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n    qmp_moisture_spearman = map(data, \n      ~cor.test(data = .x,\n        ~ .abundance + moisture_content, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n  ) %>%\n  select(-data) %>%\n  pivot_longer(contains('spearman'), names_to = 'test', values_to = 'fit') %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>%\n  with_groups(test, mutate, p.bh = p.adjust(p.value, method = 'BH'))\n\n\n\nCompare Calprotectin results,\n\n\nstudy_res %>%\n  select(Genera, starts_with('Calprotectin') & ends_with('QMP')) %>%\n  arrange(`Calprotectin  Spearman.P QMP`) %>%\n  slice_head(n=12)\n\n\n# A tibble: 12 × 4\n   Genera           `Calprotectin …` `Calprotectin …` `Calprotectin …`\n   <chr>                       <dbl>            <dbl>            <dbl>\n 1 Veillonella                 0.322           0.0001           0.0039\n 2 Streptococcus               0.279           0.0006           0.013 \n 3 Escherichia                 0.277           0.0006           0.013 \n 4 Anaerostipes               -0.267           0.001            0.0158\n 5 Gemmiger                   -0.262           0.0013           0.016 \n 6 Oscillibacter              -0.256           0.0016           0.0171\n 7 Butyricimonas              -0.24            0.0032           0.0284\n 8 Fusobacterium               0.235           0.0039           0.029 \n 9 Fusicatenibacter           -0.234           0.0041           0.029 \n10 Coprococcus                -0.22            0.007            0.0406\n11 Clostridium_IV             -0.22            0.0071           0.0406\n12 Methanobrevibac…           -0.208           0.0109           0.0571\n\nqmp_spearman %>%\n  filter(test == 'qmp_calprotectin_spearman') %>%\n  arrange(p.value) %>% \n  select(.otu, estimate, p.value, p.bh) %>%\n  slice_head(n=12)\n\n\n# A tibble: 12 × 4\n   .otu                estimate   p.value   p.bh\n   <chr>                  <dbl>     <dbl>  <dbl>\n 1 Veillonella            0.322 0.0000622 0.0101\n 2 Streptococcus          0.279 0.000570  0.0335\n 3 EscherichiaShigella    0.277 0.000621  0.0335\n 4 Anaerostipes          -0.267 0.00100   0.0406\n 5 Gemmiger              -0.262 0.00127   0.0412\n 6 Oscillibacter         -0.256 0.00163   0.0440\n 7 Butyricimonas         -0.240 0.00315   0.0729\n 8 Fusobacterium          0.235 0.00392   0.0745\n 9 Fusicatenibacter      -0.234 0.00414   0.0745\n10 Alloscardovia          0.222 0.00655   0.0957\n11 Coprococcus           -0.220 0.00700   0.0957\n12 Clostridium_IV        -0.220 0.00709   0.0957\n\nThe results are similar but not identical.\nCompare moisture results,\n\n\nstudy_res %>%\n  select(Genera, starts_with('Moisture') & ends_with('QMP')) %>%\n  arrange(`Moisture Spearman.P QMP`) %>%\n  slice_head(n=12)\n\n\n# A tibble: 12 × 4\n   Genera           `Moisture Spea…` `Moisture Spea…` `Moisture Spea…`\n   <chr>                       <dbl>            <dbl>            <dbl>\n 1 Oscillibacter              -0.581          3  e-14          2  e-12\n 2 Clostridium_IV             -0.54           3  e-12          1  e-10\n 3 Blautia                    -0.537          5  e-12          1  e-10\n 4 Faecalibacterium           -0.529          1  e-11          1  e-10\n 5 Ruminococcus               -0.529          1  e-11          1  e-10\n 6 Fusicatenibacter           -0.513          5  e-11          6  e-10\n 7 Coprococcus                -0.51           8  e-11          7  e-10\n 8 Alistipes                  -0.496          3  e-10          2.3e- 9\n 9 Ruminococcus2              -0.493          4  e-10          2.9e- 9\n10 Dorea                      -0.489          6  e-10          3.6e- 9\n11 Collinsella                -0.485          9  e-10          5  e- 9\n12 Parabacteroides            -0.45           1.7e- 8          8.8e- 8\n\nqmp_spearman %>%\n  filter(test == 'qmp_moisture_spearman') %>%\n  arrange(p.value) %>% \n  select(.otu, estimate, p.value, p.bh) %>%\n  slice_head(n=12)\n\n\n# A tibble: 12 × 4\n   .otu             estimate  p.value     p.bh\n   <chr>               <dbl>    <dbl>    <dbl>\n 1 Oscillibacter      -0.581 2.65e-14 4.21e-12\n 2 Clostridium_IV     -0.540 3.26e-12 2.47e-10\n 3 Blautia            -0.537 4.66e-12 2.47e-10\n 4 Faecalibacterium   -0.529 1.06e-11 3.65e-10\n 5 Ruminococcus       -0.529 1.15e-11 3.65e-10\n 6 Fusicatenibacter   -0.513 5.49e-11 1.46e- 9\n 7 Coprococcus        -0.510 7.52e-11 1.71e- 9\n 8 Alistipes          -0.496 2.96e-10 5.88e- 9\n 9 Ruminococcus2      -0.493 4.16e-10 7.35e- 9\n10 Dorea              -0.489 5.74e-10 9.13e- 9\n11 Collinsella        -0.485 8.71e-10 1.26e- 8\n12 Parabacteroides    -0.450 1.74e- 8 2.22e- 7\n\nHere the estimate and p-values seem identical up to rounding, but the FDR-corrected p values differ somewhat.\nNote, I filtered the OTUs that lack genus classifications prior to doing the testing, which I suspect is what was done in the original study. If these OTUs are kept, the FDR-corrected p-values are larger, due to the larger number of tests. But the study results have smaller p-values and only list the OTUs with genus names in the table.\nVisually inspect variation for top hits\nCalprotectin\n\n\ntop_hits <- qmp_spearman %>% \n  filter(test == 'qmp_calprotectin_spearman') %>%\n  slice_min(p.bh, n = 9)\nx <- ps %>%\n  filter_sample_data(!is.na(faecal_calprotectin)) %>%\n  prune_taxa(top_hits$.otu, .) %>%\n  as_tibble %>%\n  mutate(across(.otu, factor, levels = top_hits$.otu))\n\n\n\nTo visualize the spearman correlation, plot and perform a linear regression on the rank-transformed values,\n\n\nx %>%\n  with_groups(.otu, mutate,\n    across(c(faecal_calprotectin, .abundance), rank),\n  ) %>%\n  ggplot(aes(faecal_calprotectin, .abundance)) +\n  facet_wrap(~.otu) +\n  coord_fixed() +\n  geom_point() +\n  stat_smooth(method = 'lm') +\n  labs(y = 'rank(abundance)', x = 'rank(faecal calprotectin)')\n\n\n\n\nMany of the top hits have relatively low pravalence, and it appears that the correlation is being driven by differential prevalence in the two groups of samples where calprotectin has its min value, or is above its min value. For these taxa, we might expect bias to have less impact on the associations.\nMoisture\n\n\ntop_hits <- qmp_spearman %>% \n  filter(test == 'qmp_moisture_spearman') %>%\n  slice_min(p.bh, n = 9)\nx <- ps %>%\n  filter_sample_data(!is.na(moisture_content)) %>%\n  prune_taxa(top_hits$.otu, .) %>%\n  as_tibble %>%\n  mutate(across(.otu, factor, levels = top_hits$.otu))\n\n\n\n\n\nx %>%\n  with_groups(.otu, mutate,\n    across(c(moisture_content, .abundance), rank),\n  ) %>%\n  ggplot(aes(moisture_content, .abundance)) +\n  facet_wrap(~.otu) +\n  coord_fixed() +\n  geom_point() +\n  stat_smooth(method = 'lm') +\n  labs(y = 'rank(abundance)', x = 'rank(moisture content)')\n\n\n\n\nHere we instead see that top taxa as being more prevalent.\nCheck if hits are driven by differential prevalence\nOne way we can do this is to also do Spearman tests after converting abundances to presence/absence (0 if absent, 1 if present). If the original result is driven by prevalence, then the estimates should be similar to when the QMP abundance was used.\n\n\nqmp_presence <- ps %>%\n  prune_taxa(str_subset(taxa_names(.), 'unclassified', negate = TRUE), .) %>%\n  as_tibble %>%\n  mutate(\n    presence = (.abundance > 0) * 1\n  ) %>%\n  with_groups(.otu, nest) %>%\n  mutate(\n    qmp_calprotectin = map(data, \n      ~cor.test(data = .x,\n        ~ .abundance + faecal_calprotectin, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n    presence_calprotectin = map(data, \n      ~cor.test(data = .x,\n        ~ presence + faecal_calprotectin, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n    # cond.qmp_calprotectin = map(data,\n    #   ~cor.test(data = .x %>% filter(.abundance > 0),\n    #     ~ .abundance + faecal_calprotectin, \n    #     method = 'spearman', exact = FALSE, continuity = TRUE)),\n    qmp_moisture = map(data, \n      ~cor.test(data = .x,\n        ~ .abundance + moisture_content, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n    presence_moisture = map(data, \n      ~cor.test(data = .x,\n        ~ presence + moisture_content, \n        method = 'spearman', exact = FALSE, continuity = TRUE)),\n    # cond.qmp_moisture = map(data,\n    #   ~cor.test(data = .x %>% filter(.abundance > 0),\n    #     ~ presence + moisture_content, \n    #     method = 'spearman', exact = FALSE, continuity = TRUE)),\n  ) %>%\n  select(-data) %>%\n  pivot_longer(contains(c('qmp', 'presence')), \n    names_to = 'test', values_to = 'fit') %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>%\n  with_groups(test, mutate, p.bh = p.adjust(p.value, method = 'BH'))\n\n\n\n\n\nqmp_presence_wide <- qmp_presence %>%\n  select(.otu, test, estimate, p.value, p.bh) %>%\n  separate(test, into = c('response', 'covariate'), sep = '_') %>%\n  pivot_wider(names_from = response, values_from = c(estimate, p.value, p.bh), \n    names_glue = '{response}_{.value}', names_sort = TRUE) %>%\n  select(.otu, covariate, starts_with('qmp'), starts_with('presence'))\n#> select(.otu, sort(tidyselect::peek_vars()))\n\n\n\n\n\np1 <- qmp_presence_wide %>%\n  ggplot(aes(presence_estimate, qmp_estimate)) +\n  facet_wrap(~covariate) +\n  coord_fixed() +\n  geom_point()\np1\n\n\n\n\n\n\np2 <- qmp_presence_wide %>%\n  ggplot(aes(presence_p.value, qmp_p.value)) +\n  facet_wrap(~covariate) +\n  coord_fixed() +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_point()\np2\n\n\n\n\nOverall, can see that most of the QMP correlations are highly similar to the presence correlations.\n\n\n\nFaecal calprotectin\n\ngenus\nqmp_estimate\nqmp_p.value\nqmp_p.bh\npresence_estimate\npresence_p.value\npresence_p.bh\nVeillonella\n0.32\n6.2e-05\n0.010\n0.3100\n0.00013\n0.021\nStreptococcus\n0.28\n5.7e-04\n0.034\n0.0053\n0.95000\n0.980\nEscherichiaShigella\n0.28\n6.2e-04\n0.034\n0.2300\n0.00500\n0.150\nAnaerostipes\n-0.27\n1.0e-03\n0.041\n-0.1500\n0.06000\n0.380\nGemmiger\n-0.26\n1.3e-03\n0.041\n-0.1800\n0.03100\n0.310\nOscillibacter\n-0.26\n1.6e-03\n0.044\n-0.1900\n0.01900\n0.230\nButyricimonas\n-0.24\n3.2e-03\n0.073\n-0.2200\n0.00620\n0.150\nFusobacterium\n0.23\n3.9e-03\n0.074\n0.2100\n0.00910\n0.170\nFusicatenibacter\n-0.23\n4.1e-03\n0.074\n-0.2300\n0.00390\n0.150\nAlloscardovia\n0.22\n6.6e-03\n0.096\n0.2200\n0.00660\n0.150\n\nMoisture content\n\ngenus\nqmp_estimate\nqmp_p.value\nqmp_p.bh\npresence_estimate\npresence_p.value\npresence_p.bh\nOscillibacter\n-0.58\n0\n0\n-0.43\n1.0e-07\n7.5e-06\nClostridium_IV\n-0.54\n0\n0\n-0.26\n1.6e-03\n7.7e-03\nBlautia\n-0.54\n0\n0\n-0.11\n2.1e-01\n3.5e-01\nFaecalibacterium\n-0.53\n0\n0\n-0.18\n2.8e-02\n7.8e-02\nRuminococcus\n-0.53\n0\n0\n-0.43\n1.0e-07\n7.5e-06\nFusicatenibacter\n-0.51\n0\n0\n-0.36\n1.1e-05\n2.8e-04\nCoprococcus\n-0.51\n0\n0\n-0.32\n1.2e-04\n1.4e-03\nAlistipes\n-0.50\n0\n0\n-0.26\n1.4e-03\n7.2e-03\nRuminococcus2\n-0.49\n0\n0\n-0.29\n5.0e-04\n3.8e-03\nDorea\n-0.49\n0\n0\n-0.14\n1.1e-01\n2.1e-01\n\nConsider the calprotectin results. For some taxa (like Veillonella, EscherichiaShigella) the two estimates are very similar;for others like Streptococcus they are quite different.\nBias sensitivity analysis\nHypothesis: Correlations that are driven by differential prevalence will be less sensitive to bias than correlations that are not.\nFor the purposes of this analysis, zero observations will be treated as true zeros, which I expect to reduce the apparent impact of bias perturbation or calibration on the DA results relative to if we assumed zeros as indicating small positive abundances.\nAnalysis\nIn order to perform a bias sensitivity analysis on the QMP profiles, we will calibrate (inverse-perturb) the relative abundances by the sampled bias vector, while keeping the total sum for the same constant, so that the total abundance of the same remains given by the fecal cell count.\n\n\n# Returns a matrix with taxa as columns\nsample_bias <- function(n, gsd, vcv, taxa_as = 'cols') {\n  stopifnot(isSymmetric(vcv))\n  stopifnot(n > 1)\n  n_taxa <- nrow(vcv)\n  gsd_log <- log(gsd)\n  bias <- MASS::mvrnorm(n, mu = rep(0, n_taxa), Sigma = vcv) %>%\n    t %>%\n    scale %>%\n    {. * gsd_log} %>%\n    exp\n  if (taxa_as == 'cols')\n    bias <- t(bias)\n  bias\n}\n#> x <- sample_bias(3, gsd = 3, phy_vcv)\n#> x %>% apply(1, gm_sd) %>% head\n#> x[1,] %>% qplot + scale_x_log10()\n#> sample_bias(3, gsd = 3, phy_vcv, taxa_as = 'rows') %>% head\n\nmy_stat <- function(ps, otus) {\n  ps %>%\n    prune_taxa(otus, .) %>%\n    as_tibble %>%\n    with_groups(.otu, nest) %>%\n    mutate(\n      fit = map(data, ~cor.test(data = .x,\n          ~ .abundance + faecal_calprotectin, \n          method = 'spearman', exact = FALSE, continuity = TRUE)),\n      fit = map(fit, broom::tidy)\n    ) %>%\n    select(-data) %>%\n    unnest(fit)\n}\n#> my_stat(ps, 'Veillonella')\n\n\n\n\n\nset.seed(42)\nR <- 300\ngsd <- 3\nvcv <- diag(ntaxa(ps))\nreps <- sample_bias(n = R, gsd = gsd, vcv = vcv) %>%\n  split(., row(.)) %>%\n  enframe(\".idx\", \"bias\")\n\n\n\n\n\ntaxa_to_test <- c(\n  #  low prevalence\n  'Veillonella', 'EscherichiaShigella', 'Fusobacterium',\n  # high prevalence\n  'Streptococcus', 'Anaerostipes', 'Fusicatenibacter'\n  )\nreps_fit <- xfun::cache_rds({\n  reps %>%\n    mutate(\n      fits = map(bias, \n        ~my_stat(\n          ps = calibrate(ps, .x, norm = 'keep'),\n          otus = taxa_to_test\n        ))\n    ) %>%\n    unnest(fits)\n}, dir = '_cache/', file = 'reps_fit', \nhash = list(reps, taxa_to_test))\n\n\n\n\n\nplot_bias_sens <- function(reps, original, .otu) {\n  est_dist <- ggplot(reps, aes(estimate)) +\n    geom_histogram() +\n    geom_vline(xintercept = original$estimate, color = \"darkred\") +\n    geom_vline(xintercept = 0, color = \"grey\") +\n    labs(title = \"Distribution of point estimates\", x = \"Estimate\", y = \"Count\")\n  pval_dist <- ggplot(reps, aes(p.value)) +\n    geom_histogram() +\n    geom_vline(xintercept = original$p.value, color = \"darkred\") +\n    geom_vline(xintercept = 0.05, color = \"grey\") +\n    scale_x_log10() +\n    labs(title = \"Distribution of p-values\", x = \"p-value\", y = \"Count\")\n  est_dist / pval_dist +\n    plot_annotation(title = .otu)\n}\n\noriginal <- qmp_presence %>%\n  filter(.otu %in% taxa_to_test, test == 'qmp_calprotectin') %>%\n  with_groups(.otu, nest) %>%\n  rename(original = data)\n\nreps_plots <- reps_fit %>%\n  with_groups(.otu, nest) %>%\n  rename(reps = data) %>%\n  left_join(original, by = \".otu\") %>%\n  mutate(.,\n    plot = pmap(., plot_bias_sens)\n  ) %>%\n  select(.otu, plot) %>%\n  deframe\n\n\n\nTop hits with low prevalence\n\n\n\n\n\n\n\n\n\n\n\n\nTop hits with high prevalence\n\n\n\n\n\n\n\n\n\nSummary\nIt isn’t clear from these plots that there is a difference in bias sensitivity between the two sets.\n\n\n\nVieira-Silva, Sara, João Sabino, Mireia Valles-Colomer, Gwen Falony, Gunter Kathagen, Clara Caenepeel, Isabelle Cleynen, Schalk van der Merwe, Séverine Vermeire, and Jeroen Raes. 2019. “Quantitative microbiome profiling disentangles inflammation- and bile duct obstruction-associated microbiota alterations across PSC/IBD diagnoses.” Nat. Microbiol. 4 (11): 1826–31. https://doi.org/10.1038/s41564-019-0483-9.\n\n\n\n\n",
    "preview": "posts/2022-01-20-vieirasilva2019quan/vieirasilva2019quan_files/figure-html5/unnamed-chunk-7-1.svg",
    "last_modified": "2022-02-09T08:43:10-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-08-leopold2020host-case-study/",
    "title": "Analysis of Leopold and Busby (2020) for manuscript case study",
    "description": "This document performs analysis of the data from @leopold2020host to support the fungal case study in the manuscript.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-08",
    "categories": [
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\n\nContents\nSetup\nBias estimation\n\nT1 samples\nSetup\nVariation in mean efficiency\nVariation in proportions vs mean efficiency\n\nChange in commensals due to infection\nSetup\nVariation in mean efficiency\nSimple linear regression of log proportion\nGamma-Poisson regression\n\nSession info\n\nSetup\n\n\nlibrary(here)\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(ggdist)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal)\n\n# library(rstanarm)\n# options(mc.cores = 4)\n\n\n\n\n\n# color pallets from leopold2020host\npal_treatment <- c(\"#2F4F4F\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\")\npal_region <- c(\"#A2CD5A\",\"#6E8B3D\")\npal_genotype <- c(\"#800000FF\", \"#767676FF\", \"#CC8214FF\", \"#616530FF\",\n  \"#0F425CFF\", \"#9A5324FF\", \"#3E3E23FF\", \"#D6D6CEFF\", \"#FFB547FF\", \"#ADB17DFF\",\n  \"#5B8FA8FF\", \"#D49464FF\")\n\n\n\n\n\nShow code\n\n## From the metacal 2.0 tutorial\n# Download data from https://zenodo.org/record/3872145\ndata_path <- here::here(\"notebook/_data\", \"leopold2020host\")\n# To use a temporary directory:\n# data_path <- file.path(tempdir(), \"leopold2020\")\nif (!dir.exists(data_path)) {\n  dir.create(data_path, recursive = TRUE)\n  download.file(\n    \"https://zenodo.org/record/3872145/files/dleopold/Populus_priorityEffects-v1.2.zip\",\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\")\n  )\n  unzip(\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\"), \n    exdir = data_path\n  )\n}\n\nmock_actual <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/data/MockCommunities.csv\") %>%\n  read.csv(row.names = 1) %>%\n  select(-Sym4) %>%\n  as(\"matrix\") %>%\n  otu_table(taxa_are_rows = FALSE) %>%\n  transform_sample_counts(function(x) close_elts(1 / x))\nmock_taxa <- taxa_names(mock_actual)\ncommensal_taxa <- setdiff(mock_taxa, 'Melampsora')\n\n# Rust severity\nrust <- file.path(data_path, 'dleopold-Populus_priorityEffects-8594f7c',\n  'data/rust_measurements.csv'\n) %>%\n  read_csv %>%\n  select(-1)\n# summarize following approach from leopold \nrust_summary <- rust %>%\n  janitor::clean_names() %>%\n  rename(plant_id = samp_id) %>%\n  with_groups(plant_id, summarize, \n    # across(ends_with('cm2'), mean)\n    rust_pct = sum(rust_cm2)/sum(leaf_cm2),\n    lesion_pct = sum(lesion_cm2) / sum(leaf_cm2),\n    leaf_area = sum(leaf_cm2),\n    leaf_n = n()\n  )\n\n#> The microbiome data is stored in a phyloseq object,\nps_raw <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/output/compiled/phy.rds\") %>%\n  readRDS %>%\n  filter_tax_table(.otu %in% mock_taxa) %>%\n  mutate_sample_data(., \n    Timepoint = factor(Timepoint),\n    sample_sum = sample_sums(.)\n  ) %>%\n  mutate_sample_data(\n    plant_id = str_extract(.sample, 'G[0-9]+\\\\.T[0-9]+\\\\.R[0-9]+')\n  ) %>%\n  left_join_sample_data(\n    rust_summary, by = 'plant_id'\n  ) %>%\n  rename_with_sample_data(janitor::make_clean_names)\n\nps_mock <- ps_raw %>% \n  subset_samples(samp_type == \"Mock\") %>%\n  prune_taxa(mock_taxa, .)\n\n\n\nCheck sample sums,\n\n\nsam <- ps_raw %>% sample_data %>% as_tibble\nsam %>%\n  as_tibble %>%\n  ggplot(aes(sample_sum, fill = samp_type)) +\n  scale_x_log10() +\n  geom_histogram() +\n  scale_fill_brewer(type = 'qual')\n\n\n\n\n\n\nsam %>%\n  filter(sample_sum < 3e3) %>%\n  select(.sample, timepoint, treatment, sample_sum)\n\n\n# A tibble: 1 × 4\n  .sample       timepoint treatment sample_sum\n  <chr>         <fct>     <chr>          <dbl>\n1 G12.T6.R4.TP1 1         Negative        1366\n\nThe sample with less than 3000 reads is in the ‘Negative’ treatment group and so will be ignored in our analysis of the T1 samples.\nLet’s check the distribution of proportions of the mock taxa across samples.\n\n\nps_raw %>% \n  filter_sample_data(samp_type == \"Experiment\", treatment != 'Negative') %>%\n  filter_tax_table(.otu %in% mock_taxa) %>%\n  transform_sample_counts(close_elts) %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance + 1e-5)) +\n  facet_wrap(~timepoint) +\n  scale_x_log10() +\n  stat_slab()\n\n\n\n\nT1 samples have reads of Melampsora, which may be contamination. For our analysis, let’s subset to the mock taxa and just the experimental samples, and set Melampsora in T1 to zero.\n\n\notu_new <- ps_raw %>% \n  filter_tax_table(.otu %in% mock_taxa) %>%\n  filter_sample_data(samp_type == \"Experiment\", treatment != 'Negative') %>%\n  as_tibble %>%\n  mutate(.abundance = ifelse(\n      timepoint == 1 & .otu == 'Melampsora', 0, .abundance\n  )) %>%\n  select(.sample, .otu, .abundance) %>%\n  pivot_wider(names_from = .otu, values_from = .abundance) %>%\n  otu_table(taxa_are_rows = FALSE)\nps <- ps_raw\notu_table(ps) <- otu_new\nrm(otu_new)\n\n\n\nConfirm that Mel is zero’d in the t1 samples,\n\n\nps %>% \n  prune_taxa('Melampsora', .) %>%\n  as_tibble %>%\n  with_groups(timepoint, summarize,\n    across(.abundance, list(median = median, perc_pos = ~mean(. > 0) ))\n  )\n\n\n# A tibble: 2 × 3\n  timepoint .abundance_median .abundance_perc_pos\n  <fct>                 <dbl>               <dbl>\n1 1                         0                   0\n2 2                     12175                   1\n\nBias estimation\nWe estimate bias using metacal::estimate_bias(); see the metacal tutorial for more information. Leopold and Busby (2020) identified the sample Mock.5 as an outlier sample and excluded it when estimating bias. One taxon in this sample, Epicoccum, was undetected, and including it leads to a larger standard error especially for this taxon (as seen in the metacal tutorial). We could improve our bias estimates by setting this taxon’s nominal abundance to 0 in this sample; however, let’s just drop this sample to maintain consistent bias estimates with those used in the original study.\n\n\ncontrol_samples <- ps_mock %>% sample_names %>% setdiff('Mock.5')\nmc_fit <- estimate_bias(\n  ps_mock %>% prune_samples(control_samples, .), \n  mock_actual %>% prune_samples(control_samples, .), \n  boot = TRUE\n)\nbias <- coef(mc_fit) %>% print(digits = 2)\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n         8.57          0.28          1.57          2.79          0.21 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n         0.86          0.54          1.46          0.67 \n\n\n\nmc_fit_summary <- summary(mc_fit)\ncoef_tb <- mc_fit_summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\nT1 samples\nFrom our previous analyses, we know that there is little impact of bias correction on the primary analyses done on these samples, and also that there is fairly little variation in the mean efficiency in the T1 samples. Here we further explore the variation in both the species proportions and the mean efficiency to more fully understand why bias has little impact on DA analysis.\nSetup\nHere we subset to the T1 experimental samples and the commensal taxa. The analysis of T1 samples by Leopold and Busby (2020) first subsets to just the 8 commensal (non-pathogenic) inoculum taxa, and we follow suit here. It excludes Melampsora and OTUs not identified with the 9 inoculum taxa. In addition, we add the sample sums and mean efficiency to the sample data, after subsetting to the commensals.\n\n\n# Bias among the commensals; for convenience, set relative to max\nbias_t1 <- bias[names(bias) != 'Melampsora']\nbias_t1 <- bias_t1 / max(bias_t1)\nmost_efficient_taxon <- which.max(bias_t1) %>% names\nstopifnot(most_efficient_taxon == 'Fusarium')\n\nps_t1 <- ps %>%\n  filter_sample_data(timepoint == 1) %>%\n  filter_tax_table(.otu %in% commensal_taxa) %>%\n  mutate_sample_data(., \n    sample_sum = sample_sums(.),\n    mean_efficiency = mean_efficiency(., bias_t1, type = 'observed')\n  )\nsam_t1 <- ps_t1 %>% sample_data %>% as_tibble\n\n\n\nA small fraction (0.0328) of the observed counts are zero. For calculations that ignore the counting error, we want to ensure there are only positive abundances. We will replace zeros using zCompositions::cmultRepl() following Leopold and Busby (2020), then recompute the mean efficiency (which should only change very slightly).\n\n\nstopifnot(taxa_are_rows(ps_t1) == FALSE)\notu_new <- ps_t1 %>% \n  otu_table %>% \n  as('matrix') %>%\n  zCompositions::cmultRepl(\n    method = 'GBM', \n    output = 'p-counts', \n    suppress.print = TRUE\n  )\nps_t1_repl <- ps_t1\notu_table(ps_t1_repl) <- otu_table(otu_new, taxa_are_rows = FALSE)\nrm(otu_new)\nps_t1_repl <- ps_t1_repl %>%\n  mutate_sample_data(., \n    mean_efficiency_initial = mean_efficiency,\n    mean_efficiency = calibrate(., bias_t1, norm = 'close') %>%\n      perturb(bias_t1, norm = 'none') %>% \n      sample_sums,\n  )\n\n\n\nLet’s create a data frame with the observed and calibrated proportions of each species, with their efficiencies added in.\n\n\nprops <- ps_t1_repl %>%\n  as_tibble %>%\n  left_join(bias_t1 %>% enframe('.otu', 'efficiency'),\n    by = '.otu'\n  ) %>%\n  with_groups(.sample, mutate, \n    prop_obs = close_elts(.abundance),\n    prop_cal = close_elts(.abundance / efficiency),\n  ) %>%\n  mutate(\n    .otu_fct = fct_reorder(.otu, efficiency)\n  )\n\n\n\nVariation in mean efficiency\nLet’s examine the variation in mean efficiency\n\n\nlyrs <- list(\n  geom_histogram(),\n  scale_x_log10(),\n  expand_limits(x = 1.2),\n  scale_fill_brewer(type = \"qual\"),\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    # fill = ''\n  )\n)\n\np1 <- sam_t1 %>%\n  ggplot(aes(mean_efficiency, fill = region)) +\n  lyrs\np2 <- sam_t1 %>%\n  ggplot(aes(mean_efficiency, fill = treatment)) +\n  lyrs\np1 / p2\n\n\n\n\nThe relative efficiency has a geometric range of 13-fold and a geometric standard deviation of 2.41-fold. But the mean efficiency’s geometric range is only 1.62-fold and its geometric standard deviation is just 1.05-fold.\nVariation in proportions vs mean efficiency\nFirst let’s create some summary statistics of the calibrated proportions, to compare to those of the mean efficiency.\n\n\nprops %>%\n  with_groups(.otu_fct, summarize,\n    across(prop_cal, \n      list(gm_mean = gm_mean, gm_sd = gm_sd, gm_range = gm_range),\n      .names = '{.fn}'\n    )\n  ) %>%\n  arrange(desc(.otu_fct)) %>%\n  mutate(across(-.otu_fct, signif, 3)) %>%\n  knitr::kable()\n\n\n.otu_fct\ngm_mean\ngm_sd\ngm_range\nFusarium\n0.12400\n1.49\n13.10\nEpicoccum\n0.19800\n1.46\n20.60\nAlternaria\n0.55700\n1.18\n2.79\nCladosporium\n0.02820\n1.76\n43.30\nAureobasidium\n0.00944\n1.99\n1700.00\nTrichoderma\n0.00368\n3.40\n8190.00\nDioszegia\n0.02650\n1.85\n30.30\nPenicillium\n0.00189\n9.45\n8990.00\n\nNow let’s create the main figure showing the variation in taxa proportions against that in the mean efficiency, with the individual taxa efficiencies also shown for more context.\nCaption: In the pre-infection samples from Leopold and Busby (2020), multiplicative variation in taxa proportions is much larger than that in the mean efficiency. Panel A shows the distribution of the proportions of each commensal isolate (denoted by its genus) across all samples collected prior to pathogen inoculation; Panel C shows the distribution of the (estimated) sample mean efficiency across these same samples on the same scale; and Panel B shows the efficiency of each taxon estimated from DNA mock communities as point estimates and 90% bootstrap percentile confidence intervals. Efficiencies are shown relative to the most efficiently measured taxon (Fusarium).\n\n\nrng <- props %>% pull(prop_cal) %>% range\n## species proportions\np_props <- props %>%\n  ggplot(aes(y = .otu_fct, x = prop_cal)) +\n  scale_x_log10() +\n  stat_slab() +\n  labs(x = 'Proportion', y = NULL)\n## mean efficiency\np_me <- sam_t1 %>%\n  ggplot(aes(y = 'Mean efficiency', x = mean_efficiency)) +\n  scale_x_log10() +\n  expand_limits(x = rng) +\n  stat_slab() +\n  labs(x = 'Efficiency relative to Fusarium', y = NULL)\n# p_me / p_props + plot_layout(heights = c(0.1, 1))\n## Estimated efficiency with bootstrap CIs\nx <- mc_fit$bootreps %>%\n  data.table::as.data.table(keep.rownames = '.id') %>%\n  select(.id, all_of(commensal_taxa)) %>%\n  mutate(across(-.id, ~. / Fusarium)) %>%\n  pivot_longer(-.id, names_to = 'taxon', values_to = 'efficiency') \np_eff <- x %>%\n  mutate(taxon = fct_reorder(taxon, efficiency)) %>%\n  ggplot(aes(y = taxon, x = efficiency)) +\n  stat_pointinterval(.width = 0.9) +\n  scale_x_log10() +\n  labs(x = str_glue('Efficiency relative to Fusarium'), y = NULL)\n\n\n\n\n\np_props + p_eff + p_me + plot_spacer() + \n  plot_layout(heights = c(1, 0.15), widths = c(1, 0.8), ncol = 2) +\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nChange in commensals due to infection\nGoal: Do a linear regression analysis of change in log proportion following pathogen colonization (from T1 to T2).\nNote, I am keeping in the pathogen Melampsora for this analysis. The increase in Mel proportion post infection is a major driver of the impact of bias, since it causes the mean efficiency to increase. If we instead considered the proportions among just the commensals, then we would get different results. The results here, with Mel included, are the most informative for what would happen if we were performing absolute-abundance analysis using total-community normalization.\nSetup\nFor doing simple linear regression, we must replace zeros with positive values. I will use zCompositions::cmultRepl() as in Leopold and Busby (2020) for simplicity and consistency with our other analyses in this case study. I will recompute the mean efficiency with these new compositions; however, zero replacement will have a minimal impact on the mean efficiency.\n\n\nbias_inf <- bias/bias['Fusarium']\nps_inf <- ps %>%\n  mutate_sample_data(., \n    sample_sum = sample_sums(.),\n    mean_efficiency = mean_efficiency(., bias_inf, type = 'observed')\n  )\nstopifnot(taxa_are_rows(ps_inf) == FALSE)\notu_new <- ps_inf %>% \n  otu_table %>% \n  as('matrix') %>%\n  zCompositions::cmultRepl(\n    method = 'GBM', \n    output = 'p-counts', \n    suppress.print = TRUE\n  )\nps_inf_repl <- ps_inf\notu_table(ps_inf_repl) <- otu_table(otu_new, taxa_are_rows = FALSE)\nrm(otu_new)\nps_inf_repl <- ps_inf_repl %>%\n  mutate_sample_data(., \n    sample_sum = sample_sums(.),\n    mean_efficiency = mean_efficiency(., bias_inf, type = 'observed')\n  )\n\n\n\nVariation in mean efficiency\nFrom our previous explorations, we know that the mean efficiency tends to increase post infection due to the higher proportion of Melampsora.\nLet’s see this again,\n\n\nmel <- ps_inf %>% \n  calibrate(bias = bias_inf) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  otu_table %>%\n  as_tibble %>%\n  select(.sample, melampsora_prop = .abundance)\nsam <- ps_inf_repl %>% sample_data %>% as_tibble %>%\n  left_join(mel, by = '.sample')\np_hist <- sam %>%\n  ggplot(aes(fill = timepoint, x = mean_efficiency)) +\n  scale_x_log10() +\n  geom_histogram() +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = 'Timepoint'\n  )\np_mel <- sam %>%\n  ggplot(aes(y = melampsora_prop, x = mean_efficiency, color = timepoint)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Pathogen proportion\",\n    x = \"Mean efficiency\",\n    color = 'Timepoint'\n  )\n\n\n\n\n\np_hist / p_mel +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nLet’s visualize the pre and post infection mean eff’s by host genotype.\n\n\nps_inf_repl %>%\n  sample_data %>%\n  as_tibble %>%\n  ggplot(aes(y = genotype, x = mean_efficiency, \n      color = timepoint)) +\n  scale_x_log10() +\n  geom_boxplot() +\n  geom_quasirandom(groupOnX = FALSE) +\n  scale_color_brewer(type = 'qual', palette = 3)\n\n\n\n\nThe mean efficiency generally increases by a similar factor in each genotype.\nLet’s measure the average fold increase in each genotype.\n\n\nmean_eff_reg <- ps_inf_repl %>%\n  sample_data %>%\n  as_tibble %>%\n  group_by(genotype) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log(mean_efficiency) ~ timepoint, data = .x))\n  ) %>%\n  select(-data) %>% \n  mutate(across(starts_with('fit'), map, tidy)) %>%\n  unnest(fit)\n\n\n\n\n\nx <- mean_eff_reg %>%\n  filter(term == 'timepoint2') %>%\n  mutate(across(c(estimate, std.error), exp))\nx %>% select(genotype:std.error) %>% arrange(genotype) %>% \n  knitr::kable(digits = 3)\n\n\ngenotype\nterm\nestimate\nstd.error\nEast-1\ntimepoint2\n4.974\n1.022\nEast-2\ntimepoint2\n5.244\n1.020\nEast-3\ntimepoint2\n4.466\n1.035\nEast-4\ntimepoint2\n4.352\n1.073\nEast-5\ntimepoint2\n4.299\n1.061\nWest-1\ntimepoint2\n3.952\n1.049\nWest-2\ntimepoint2\n2.490\n1.088\nWest-3\ntimepoint2\n3.226\n1.076\nWest-4\ntimepoint2\n3.447\n1.071\nWest-5\ntimepoint2\n4.222\n1.048\nWest-6\ntimepoint2\n2.620\n1.109\nWest-7\ntimepoint2\n3.212\n1.106\n\nx %>%\n  ggplot(aes(y = genotype, x = estimate)) +\n  expand_limits(x = c(1, 6)) +\n  scale_x_log10() +\n  geom_vline(xintercept = 1, color = 'grey') +\n  geom_point() +\n  geom_linerange(\n    aes(\n      xmin = estimate * std.error^2,\n      xmax = estimate / std.error^2\n    )\n  )\n\n\n\n\nThe FC in mean efficiency ranges from 2.49 to 5.24.\nSimple linear regression of log proportion\nRun a simple linear regression with lm on log proportion,\n\n\nres_lm <- ps_inf_repl %>% \n  as_tibble %>%\n  left_join(bias_inf %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  with_groups(.sample, mutate,\n    log_prop = log(close_elts(.abundance))\n  ) %>%\n  filter(.otu %in% commensal_taxa) %>%\n  mutate(\n    offset_obs = 0,\n    offset_cal = log(efficiency / mean_efficiency),\n  ) %>%\n  with_groups(c(.otu, genotype), nest) %>%\n  mutate(\n    Observed = map(data, \n      ~lm(\n        log_prop ~ timepoint + offset(offset_obs), \n        data = .x,\n      )),\n    Calibrated = map(data, \n      ~lm(\n        log_prop ~ timepoint + offset(offset_cal), \n        data = .x,\n      )),\n  ) %>%\n    select(-data) %>%\n    pivot_longer(c(Observed, Calibrated), names_to = 'type', values_to = 'fit')\nres_lm_tidy <- res_lm %>%\n  mutate(across(fit, map, broom.mixed::tidy, conf.int = TRUE)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\nres_lm_tidy_wide <- res_lm_tidy %>%\n  select(.otu, genotype, type, estimate, std.error, conf.low, conf.high, p.value) %>%\n  pivot_wider(names_from = type, \n    values_from = c(estimate, std.error, conf.low, conf.high, p.value)) %>%\n  glimpse\n\n\nRows: 96\nColumns: 12\n$ .otu                 <chr> \"Aureobasidium\", \"Aureobasidium\", \"Aure…\n$ genotype             <chr> \"West-7\", \"East-1\", \"East-2\", \"West-5\",…\n$ estimate_Observed    <dbl> -2.320913, -4.649869, -5.158821, -3.690…\n$ estimate_Calibrated  <dbl> -1.1540542, -3.0456064, -3.5016735, -2.…\n$ std.error_Observed   <dbl> 0.5799465, 0.3149781, 0.3133921, 0.4267…\n$ std.error_Calibrated <dbl> 0.5161804, 0.3025285, 0.3088991, 0.4121…\n$ conf.low_Observed    <dbl> -3.497099, -5.287509, -5.797989, -4.558…\n$ conf.low_Calibrated  <dbl> -2.200917, -3.658043, -4.131677, -3.088…\n$ conf.high_Observed   <dbl> -1.1447273, -4.0122296, -4.5196540, -2.…\n$ conf.high_Calibrated <dbl> -0.10719181, -2.43316958, -2.87166967, …\n$ p.value_Observed     <dbl> 2.997790e-04, 2.533626e-17, 7.102308e-1…\n$ p.value_Calibrated   <dbl> 3.165942e-02, 2.833514e-12, 1.478059e-1…\n\nCheck that the corrections are the same for each taxon within a genotype, but differ by genotype.\n\n\nres_lm_tidy_wide %>%\n  ggplot(aes(y = .otu, x = estimate_Calibrated - estimate_Observed, color = .otu)) +\n  scale_color_manual(values = pal_genotype, guide = NULL) +\n  facet_wrap(~genotype) +\n  geom_point()\n\n\n\n\nThe corrections are the same within genotypes, as expected, and vary to a small degree between genotypes. They tend to be larger for Eastern genotypes; this matches with the finding that Eastern genotypes are more susceptible to rust, and so we should expect the Melampsora proportions to be larger.\nLet’s visualize the impact of bias correction on the coefficients, in a couple ways. First, let’s plot the uncorrected against the corrected estimates.\n\n\nres_lm_tidy_wide %>%\n  ggplot(aes(x = estimate_Calibrated, y = estimate_Observed, color = .otu)) +\n  scale_color_manual(values = pal_genotype) +\n  facet_wrap(~genotype, ncol = 4) +\n  theme_minimal_grid() +\n  theme() +\n  coord_fixed() +\n  scale_x_continuous(breaks = seq(-6, 2, 2)) +\n  labs(\n    x = 'Estimate with bias correction',\n    y = 'Estimate without bias correction',\n    color = 'Taxon'\n  ) +\n  geom_hline(yintercept = 0, color = 'black') +\n  geom_vline(xintercept = 0, color = 'black') +\n  geom_abline(color = 'darkred') +\n  geom_linerange(\n    aes(\n      xmin = conf.low_Calibrated,\n      xmax = conf.high_Calibrated,\n    )\n  ) +\n  geom_linerange(\n    aes(\n      ymin = conf.low_Observed,\n      ymax = conf.high_Observed,\n    )\n  ) +\n  geom_point(size = 2)\n\n\n\n\nThis figure makes it clear how the constant shift maintains a perfect correlation between estimates. But it is perhaps easier to see the biological impact on the results if we plot the two estimate types in a straight line,\n\n\nres_lm_tidy %>%\n  mutate(\n    across(.otu, fct_reorder, estimate),\n  ) %>%\n  ggplot(aes(y =.otu, color = type,\n      x = estimate, \n      xmin = estimate - 2 * std.error,\n      xmax = estimate + 2 * std.error\n  )) +\n  facet_wrap(~genotype, ncol = 4, scale = 'free_x') +\n  theme(\n    axis.line.y = element_blank(),\n    legend.position = 'top',\n    panel.spacing.x = unit(4, 'mm')\n  ) +\n  scale_x_continuous(labels = formatC) +\n  colorblindr::scale_color_OkabeIto() +\n  labs(\n    x = 'Estimated LFC',\n    y = 'Taxon',\n    color = 'Type'\n  ) +\n  geom_vline(xintercept = 0, size = 0.5, color = 'grey') +\n  geom_pointrange(fatten = 2)\n\n\n\n\nGamma-Poisson regression\nThere are a large fraction of zeros at T1 for the lower abundance and/or efficiency taxa, making it more appropriate to apply gamma Poisson model directly to the counts.\n\n\nlibrary(rstanarm)\noptions(mc.cores = parallel::detectCores())\n\n\n\nConsider the prior on the intercept. Here the offsets will include the read depth, and so we want to set the intercept prior to be for the proportions.\nTODO: Set prior in a well-defined way.\n\n\nx <- ps_inf %>%\n  transform_sample_counts(~close_elts(0.3 + .)) %>%\n  filter_tax_table(.otu %in% commensal_taxa) %>%\n  as_tibble %>%\n  with_groups(c(.otu, genotype), summarize, across(.abundance, gm_mean)) %>%\n  pull(.abundance) %>%\n  summary\nx %>% signif(2)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n4.7e-05 3.4e-04 2.2e-03 2.8e-02 3.9e-02 2.3e-01 \n\nmu <- log(0.01)\nsigma <- 3\nqnorm(p = c(0.025, 0.975), mean = mu, sd = sigma) %>% exp %>% signif(1)\n\n\n[1] 3e-05 4e+00\n\ncustom_prior_intercept <- normal(location = mu, scale = sigma)\n\n\n\n\n\ntbl_gp <- ps_inf %>%\n  filter_tax_table(.otu %in% commensal_taxa) %>%\n  as_tibble %>%\n  left_join(bias_inf %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  mutate(\n    offset_obs = log(sample_sum),\n    offset_cal = log(sample_sum * efficiency / mean_efficiency),\n  ) %>%\n  with_groups(c(.otu, genotype), nest)\n\n\n\n\n\n\n\n\nres_gp <- xfun::cache_rds({\n  tbl_gp %>%\n    mutate(\n      Observed = map(data, \n        ~stan_glm(data = .x,\n          .abundance ~ timepoint + offset(offset_obs),\n          prior_intercept = custom_prior_intercept,\n          family = neg_binomial_2, seed = 42, algorithm = 'sampling'\n        )\n      ),\n      Calibrated = map(data, \n        ~stan_glm(data = .x,\n          .abundance ~ timepoint + offset(offset_cal),\n          prior_intercept = custom_prior_intercept,\n          family = neg_binomial_2, seed = 42, algorithm = 'sampling'\n        )\n      ),\n    ) %>%\n    select(-data) %>%\n    pivot_longer(c(Observed, Calibrated), names_to = 'type', values_to = 'fit')\n}, dir = '_cache/', file = 'res_gp', \nhash = list(tbl_gp, custom_prior_intercept))\n\nres_gp_tidy <- res_gp %>%\n  mutate(across(fit, map, broom.mixed::tidy, conf.int = TRUE)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\nres_gp_tidy %>%\n  filter(term == 'timepoint2') %>%\n  mutate(\n    across(.otu, fct_reorder, estimate),\n  ) %>%\n  ggplot(aes(y =.otu, color = type,\n      x = estimate, \n      xmin = conf.low,\n      xmax = conf.high\n  )) +\n  facet_wrap(~genotype, ncol = 4, scale = 'free_x') +\n  theme(\n    axis.line.y = element_blank(), \n    legend.position = 'top',\n    panel.spacing.x = unit(4, 'mm')\n  ) +\n  scale_x_continuous(labels = formatC) +\n  colorblindr::scale_color_OkabeIto() +\n  labs(\n    x = 'Estimated LFC',\n    y = 'Taxon',\n    color = 'Type'\n  ) +\n  geom_vline(xintercept = 0, size = 0.5, color = 'grey') +\n  geom_pointrange(fatten = 2)\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-03-08\n pandoc   2.14.2 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.6-1      2022-01-07 [1] CRAN (R 4.1.2)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)\n bayesplot          1.8.1      2021-06-14 [1] CRAN (R 4.1.0)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.2     2021-08-05 [1] Bioconductor\n bit                4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64              4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n boot               1.3-28     2021-05-03 [2] CRAN (R 4.1.2)\n broom            * 0.7.11     2022-01-03 [1] CRAN (R 4.1.2)\n broom.mixed        0.2.7      2021-07-07 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n callr              3.7.0      2021-04-20 [1] CRAN (R 4.1.0)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.2.0      2022-02-14 [1] CRAN (R 4.1.2)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorblindr        0.1.0      2021-08-27 [1] Github (clauswilke/colorblindr@e6730be)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n colourpicker       1.1.1      2021-10-04 [1] CRAN (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.5.0      2022-02-14 [1] CRAN (R 4.1.2)\n crosstalk          1.2.0      2021-11-04 [1] CRAN (R 4.1.2)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.2      2021-12-20 [1] CRAN (R 4.1.2)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional     0.3.0      2022-01-05 [1] CRAN (R 4.1.2)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.8      2022-02-08 [1] CRAN (R 4.1.2)\n DT                 0.20       2021-11-15 [1] CRAN (R 4.1.2)\n dygraphs           1.1.1.6    2018-07-11 [1] CRAN (R 4.0.2)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              1.0.2      2022-01-14 [1] CRAN (R 4.1.2)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.2      2022-01-31 [1] CRAN (R 4.1.2)\n GenomeInfoDb       1.28.4     2021-09-05 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist           * 3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n ggridges           0.5.3      2021-01-08 [1] CRAN (R 4.0.4)\n glue               1.6.1      2022-01-22 [1] CRAN (R 4.1.2)\n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n gtools             3.9.2      2021-06-06 [1] CRAN (R 4.1.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n htmlwidgets        1.5.4      2021-09-08 [1] CRAN (R 4.1.1)\n httpuv             1.6.5      2022-01-05 [1] CRAN (R 4.1.2)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.11     2022-01-04 [1] CRAN (R 4.1.2)\n inline             0.3.19     2021-05-31 [1] CRAN (R 4.1.0)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n janitor            2.1.0      2021-01-05 [1] CRAN (R 4.0.4)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.3      2022-01-17 [1] CRAN (R 4.1.2)\n knitr              1.37       2021-12-16 [1] CRAN (R 4.1.2)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n later              1.3.0      2021-08-18 [1] CRAN (R 4.1.1)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lme4               1.1-27.1   2021-06-22 [1] CRAN (R 4.1.0)\n loo                2.4.1      2020-12-09 [1] CRAN (R 4.0.3)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.2      2022-01-26 [1] CRAN (R 4.1.2)\n markdown           1.1        2019-08-07 [1] CRAN (R 4.0.0)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n matrixStats        0.61.0     2021-09-17 [1] CRAN (R 4.1.1)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9010 2022-02-15 [1] Github (mikemc/metacal@f56792d)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n mime               0.12       2021-09-28 [1] CRAN (R 4.1.1)\n miniUI             0.1.1.1    2018-05-18 [1] CRAN (R 4.0.2)\n minqa              1.2.4      2014-10-09 [1] CRAN (R 4.0.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n NADA               1.6-1.1    2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nloptr             1.2.2.3    2021-11-02 [1] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.7.0      2022-02-01 [1] CRAN (R 4.1.2)\n pkgbuild           1.3.1      2021-12-20 [1] CRAN (R 4.1.2)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n prettyunits        1.1.1      2020-01-24 [1] CRAN (R 4.0.0)\n processx           3.5.2      2021-04-30 [1] CRAN (R 4.1.0)\n promises           1.2.0.1    2021-02-11 [1] CRAN (R 4.0.4)\n ps                 1.6.0      2021-02-28 [1] CRAN (R 4.0.4)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp             * 1.0.8      2022-01-13 [1] CRAN (R 4.1.2)\n RcppParallel       5.1.5      2022-01-05 [1] CRAN (R 4.1.2)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              1.0.1      2022-02-03 [1] CRAN (R 4.1.2)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rsconnect          0.8.25     2021-11-19 [1] CRAN (R 4.1.2)\n rstan              2.21.3     2021-12-19 [1] CRAN (R 4.1.2)\n rstanarm         * 2.21.1     2020-07-20 [1] CRAN (R 4.0.2)\n rstantools         2.1.1      2020-07-06 [1] CRAN (R 4.0.2)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.2     2021-10-03 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n shiny              1.7.1      2021-10-02 [1] CRAN (R 4.1.1)\n shinyjs            2.1.0      2021-12-23 [1] CRAN (R 4.1.2)\n shinystan          2.5.0      2018-05-01 [1] CRAN (R 4.0.2)\n shinythemes        1.2.0      2021-01-25 [1] CRAN (R 4.0.4)\n snakecase          0.11.0     2019-05-25 [1] CRAN (R 4.0.0)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n StanHeaders        2.21.0-7   2020-12-17 [1] CRAN (R 4.0.3)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n threejs            0.3.3      2020-01-21 [1] CRAN (R 4.0.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.2.0      2022-02-01 [1] CRAN (R 4.1.2)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8      2018-02-27 [1] CRAN (R 4.0.1)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom              1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.29       2021-12-14 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n xtable             1.8-4      2019-04-21 [1] CRAN (R 4.0.0)\n xts                0.12.1     2020-09-09 [1] CRAN (R 4.0.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.2      2022-01-25 [1] CRAN (R 4.1.2)\n zCompositions      1.4.0      2022-01-13 [1] CRAN (R 4.1.2)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n zoo                1.8-9      2021-03-09 [1] CRAN (R 4.0.5)\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-08-leopold2020host-case-study/leopold2020host-case-study_files/figure-html5/variation-in-proportions-and-mean-efficiency-1.svg",
    "last_modified": "2022-03-13T16:25:26-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-08-lloyd2020evi-case-study/",
    "title": "Analysis of Lloyd et al (2020) for manuscript case study",
    "description": "Perform calculations for the Lloyd et al (2020) case study.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-08",
    "categories": [
      "ref:lloyd2020evid",
      "differential abundance"
    ],
    "contents": "\n\nContents\nSetup\nAnalysis\nSession info\n\nSetup\nLoad libraries,\n\n\nlibrary(here)\nlibrary(tidyverse)\n# library(tidyxl)\nlibrary(unpivotr)\n\n\n\nOur source data is Table 1 from Lloyd et al. (2020), which I’ve manually input into a CSV file. This table has the form of a ‘pivot table’ with nested headers; we can properly read it in and create a ‘tidy’ version table using the unpivotr package, following this example. First we’ll read it in with one row per spreadsheet cell,\n\n\nall_cells <- here('notebook/_data/lloyd2020evid/table1.csv') %>%\n  read_csv(col_names = FALSE) %>%\n  as_cells %>%\n  # filter(!is.na(hr), chr != 'Clade') %>%\n  glimpse\n\n\nRows: 56\nColumns: 4\n$ row       <int> 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1,…\n$ col       <int> 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,…\n$ data_type <chr> \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"chr\", \"…\n$ chr       <chr> NA, NA, \"Clade\", \"Bathyarchaeota, or MCG\", \"Group …\n\nConfirm that this data matches Table 1,\n\n\nall_cells %>% rectify %>% knitr::kable()\n\n\nrow/col\n1(A)\n2(B)\n3(C)\n4(D)\n5(E)\n6(F)\n7(G)\n1\nNA\nWOR marine sediment\nNA\nNA\nNA\nCLB marine sediment\nNA\n2\nNA\nCore 30\nNA\nCore 32\nNA\nIncubation 2\nIncubation 3\n3\nClade\nFRAxC\nqPCR\nFRAxC\nqPCR\nFRAxC\nFRAxC\n4\nBathyarchaeota, or MCG\n10.1\n10.3\n8.9\n10\n6.4\n6.3\n5\nGroup C3, MCG-related\n16.2\nNA\n14.9\nNA\n2.1\n1.8\n6\nThermoprofundales (MBG-D)\n4.6\nNA\n3.4\n4.8\n3.4\n4.4\n7\nThermoprofundales (MG-III)\n3.7\nNA\n2.8\nNA\n1.4\n1.5\n8\nThermoprofundales (20a-9)\n7.1\nNA\n3.7\nNA\n0.8\n0.7\n\nNote, the values of the table are doubling times.\nNow, munge the data into tidy form, with one row per measurement. Additionally, compute the doubling rate as the reciprocal of the doubling time.\n\n\n# abbreviations: exp for experiment, meas for measurement\nx <- all_cells %>%\n  behead(\"up-left\", exp_type) %>%\n  behead(\"up-left\", exp_name) %>%\n  behead(\"up\", meas_type) %>%\n  behead(\"left\", clade) %>%\n  select(clade, starts_with('exp'), meas_type, doubling_time = chr) %>%\n  mutate(\n    across(doubling_time, as.numeric),\n    doubling_rate = 1 / doubling_time,\n  ) %>%\n  arrange(clade, exp_type, exp_name, meas_type) %>%\n  glimpse\n\n\nRows: 30\nColumns: 6\n$ clade         <chr> \"Bathyarchaeota, or MCG\", \"Bathyarchaeota, or …\n$ exp_type      <chr> \"CLB marine sediment\", \"CLB marine sediment\", …\n$ exp_name      <chr> \"Incubation 2\", \"Incubation 3\", \"Core 30\", \"Co…\n$ meas_type     <chr> \"FRAxC\", \"FRAxC\", \"FRAxC\", \"qPCR\", \"FRAxC\", \"q…\n$ doubling_time <dbl> 6.4, 6.3, 10.1, 10.3, 8.9, 10.0, 2.1, 1.8, 16.…\n$ doubling_rate <dbl> 0.15625000, 0.15873016, 0.09900990, 0.09708738…\n\ndir.create('_output')\nsaveRDS(x, '_output/table1-tidy.rds')\n\n\n\nAnalysis\nLet’s compute the error in doubling rate, assuming that the qPCR rate is accurate.\n\n\ny <- x %>%\n  select(-doubling_time) %>%\n  pivot_wider(names_from = meas_type, values_from = doubling_rate) %>%\n  mutate(error = FRAxC - qPCR)\n\n\n\n\n\ny %>% \n  filter(!is.na(qPCR)) %>%\n  select(-exp_type) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nexp_name\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\nCore 30\n0.0990\n0.0971\n0.0019\nBathyarchaeota, or MCG\nCore 32\n0.1124\n0.1000\n0.0124\nThermoprofundales (MBG-D)\nCore 32\n0.2941\n0.2083\n0.0858\n\nCore 30\n\n\ny %>% \n  # filter(str_detect(exp_type, 'WOR')) %>%\n  filter(exp_name == 'Core 30') %>%\n  select(-exp_type, -exp_name) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\n0.0990\n0.0971\n0.0019\nGroup C3, MCG-related\n0.0617\nNA\nNA\nThermoprofundales (20a-9)\n0.1408\nNA\nNA\nThermoprofundales (MBG-D)\n0.2174\nNA\nNA\nThermoprofundales (MG-III)\n0.2703\nNA\nNA\n\nCore 32\n\n\ny %>% \n  filter(exp_name == 'Core 32') %>%\n  select(-exp_type, -exp_name) %>% \n  knitr::kable(digits = 4)\n\n\nclade\nFRAxC\nqPCR\nerror\nBathyarchaeota, or MCG\n0.1124\n0.1000\n0.0124\nGroup C3, MCG-related\n0.0671\nNA\nNA\nThermoprofundales (20a-9)\n0.2703\nNA\nNA\nThermoprofundales (MBG-D)\n0.2941\n0.2083\n0.0858\nThermoprofundales (MG-III)\n0.3571\nNA\nNA\n\nCompute the calculations for the manuscript text,\n\n\nbathy_core30_fraxc <- x %>%\n  filter(exp_name == 'Core 30', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nbathy_core30_qpcr <- x %>%\n  filter(exp_name == 'Core 30', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\nbathy_core32_fraxc <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nbathy_core32_qpcr <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'Bathyarchaeota'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\nmbgd_core32_fraxc <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'MBG-D'), \n    meas_type == 'FRAxC') %>%\n  pull(doubling_rate)\nmbgd_core32_qpcr <- x %>%\n  filter(exp_name == 'Core 32', str_detect(clade, 'MBG-D'), \n    meas_type == 'qPCR') %>%\n  pull(doubling_rate)\n\n\n\nDraft manuscript text:\nOur aim is to compare the growth rates for taxa with both FRAxC and qPCR values for the two sediment cores, as reported in Table 1. The first soil core included qPCR measurements of a single archaeal clade, Bathyarchaeota, for which growth rates by qPCR and FRAxC were nearly identical (doubling rates of 0.099/yr by FRAxC and 0.097/yr by qPCR). The second soil core included qPCR measurements of Bathyarchaeota and a second clade, Thermoprofundales/MBG-D. In this core, FRAxC and qPCR growth rates differed more substantially, with growth rates from FRAxC being larger by 0.012/yr for Bathyarchaeota (0.112/yr by FRAxC and 0.1/yr by qPCR) and by 0.086/yr for Thermoprofundales/MBG-D (0.294/yr by FRAxC and 0.208/yr by qPCR). A low number of experimental samples and noise in both the FRAxC and qPCR measurements place significant uncertainty in these measurements; however, the fact that FRAxC-derived growth rates are larger than qPCR-derived rates in all three cases is consistent with our hypothesis that mean efficiency decreases with depth in a manner that systematically biases FRAxC-derived rates to higher values. The differences in growth rate are small in absolute terms; however, the maximum observed difference of 0.086/yr suggests an error large enough to impact results for some taxa classified as positive growers by Lloyd et al. (2020), for which growth rates ranged between 0.04/yr and 0.5/yr. Overall, the comparison between FRAxC and qPCR measurements gives support to the study conclusions, but suggest that species at the lower end of this range of positive FRAxC-derived rates may in fact be merely persisting or even slowly declining in abundance.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-10\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n backports     1.4.1   2021-12-13 [1] CRAN (R 4.1.2)\n bit           4.0.4   2020-08-04 [1] CRAN (R 4.0.2)\n bit64         4.0.5   2020-08-30 [1] CRAN (R 4.0.2)\n bookdown      0.24    2021-09-02 [1] CRAN (R 4.1.1)\n broom         0.7.10  2021-10-31 [1] CRAN (R 4.1.2)\n bslib         0.3.1   2021-10-06 [1] CRAN (R 4.1.1)\n cachem        1.0.6   2021-08-19 [1] CRAN (R 4.1.1)\n cellranger    1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n cli           3.1.0   2021-10-27 [1] CRAN (R 4.1.1)\n colorspace    2.0-2   2021-08-11 [1] R-Forge (R 4.1.1)\n crayon        1.4.2   2021-10-29 [1] CRAN (R 4.1.1)\n DBI           1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr        2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n digest        0.6.29  2021-12-01 [1] CRAN (R 4.1.2)\n distill       1.3     2021-10-13 [1] CRAN (R 4.1.1)\n downlit       0.4.0   2021-10-29 [1] CRAN (R 4.1.2)\n dplyr       * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n evaluate      0.14    2019-05-28 [1] CRAN (R 4.0.0)\n fansi         0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.0.4)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n fs            1.5.2   2021-12-08 [1] CRAN (R 4.1.2)\n generics      0.1.1   2021-10-25 [1] CRAN (R 4.1.1)\n ggplot2     * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n glue          1.5.1   2021-11-30 [1] CRAN (R 4.1.2)\n gtable        0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n haven         2.4.3   2021-08-04 [1] CRAN (R 4.1.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n highr         0.9     2021-04-16 [1] CRAN (R 4.1.0)\n hms           1.1.1   2021-09-26 [1] CRAN (R 4.1.1)\n htmltools     0.5.2   2021-08-25 [1] CRAN (R 4.1.1)\n httr          1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite      1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n knitr         1.36    2021-09-29 [1] CRAN (R 4.1.1)\n lifecycle     1.0.1   2021-09-24 [1] CRAN (R 4.1.1)\n lubridate     1.8.0   2021-10-07 [1] CRAN (R 4.1.1)\n magrittr      2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n memoise       2.0.1   2021-11-26 [1] CRAN (R 4.1.2)\n modelr        0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n nvimcom     * 0.9-102 2021-11-12 [1] local\n pillar        1.6.4   2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp          1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n readr       * 2.1.1   2021-11-30 [1] CRAN (R 4.1.2)\n readxl        1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n reprex        2.0.1   2021-08-05 [1] CRAN (R 4.1.1)\n rlang         0.4.12  2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown   * 2.11    2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi    0.13    2020-11-12 [1] CRAN (R 4.0.3)\n rvest         1.0.2   2021-10-16 [1] CRAN (R 4.1.1)\n sass          0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n scales        1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.2)\n stringi       1.7.6   2021-11-29 [1] CRAN (R 4.1.2)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n tibble      * 3.1.6   2021-11-07 [1] CRAN (R 4.1.2)\n tidyr       * 1.1.4   2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect    1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n tzdb          0.2.0   2021-10-27 [1] CRAN (R 4.1.2)\n unpivotr    * 0.6.2   2021-08-22 [1] CRAN (R 4.1.2)\n utf8          1.2.2   2021-07-24 [1] CRAN (R 4.1.0)\n vctrs         0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n vroom         1.5.7   2021-11-30 [1] CRAN (R 4.1.2)\n withr         2.4.3   2021-11-30 [1] CRAN (R 4.1.2)\n xfun          0.28    2021-11-04 [1] CRAN (R 4.1.2)\n xml2          1.3.3   2021-11-30 [1] CRAN (R 4.1.2)\n yaml          2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLloyd, Karen G., Jordan T. Bird, Joy Buongiorno, Emily Deas, Richard Kevorkian, Talor Noordhoek, Jacob Rosalsky, and Taylor Roy. 2020. “Evidence for a Growth Zone for Deep-Subsurface Microbial Clades in Near-Surface Anoxic Sediments.” Appl. Environ. Microbiol. 86 (19): 1–15. https://doi.org/10.1128/AEM.00877-20.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-10T08:52:08-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-06-leopold2020host-original-regression-analysis/",
    "title": "Perform Leopold and Busby (2020) regression analysis with and without bias correction",
    "description": "We perform the regression analysis of Leopold and Busby (2020) with and without bias correction, finding that there is negligible impact of bias correction on the results.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-06",
    "categories": [
      "ref:leopold2020host",
      "differential abundance",
      "bias sensitivity"
    ],
    "contents": "\n\nContents\nRun analyses with and without bias correction\nCompute offsets with and without bias correction\nRun analysis with each set of offsets\n\nCompare results\nANOVA summary tables\nFull model\nRegion model\n\nSession info\n\nThis document asks whether bias correction has a significant impact on the regression analysis of Leopold and Busby (2020).\nRun analyses with and without bias correction\n\n\nlibrary(here)\n\nset.seed(42)\n\n\n\nThis script follows the analysis of code/jsdModels.R in https://github.com/dleopold/Populus_priorityEffects.\nWe start by running the setup of libraries and loading the phyloseq object and bias estimate. The code is modified from jsdModels.R to adjust working directories for reading files.\n\n\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(phyloseq)\nlibrary(mvabund)\nlibrary(gt)\n\nthis_dir <- getwd()\nsetwd(here('notebook/_data/leopold2020host/dleopold-Populus_priorityEffects-8594f7c/'))\n\nsource(\"code/Rfunctions.R\")\n\n# load phyloseq data\n(phy <- loadPhyloseq())\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 8 taxa and 247 samples ]\nsample_data() Sample Data:       [ 247 samples by 16 sample variables ]\ntax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]\nrefseq()      DNAStringSet:      [ 8 reference sequences ]\n\n# load bias correction factors - estimated from mock communities\nbias <- read.csv(\"output/tabs/bias.csv\")\n\nsetwd(this_dir)\n\n\n\nCompute offsets with and without bias correction\nBias is accounted for in the original regression analysis through the use of taxon and sample-specific offsets, stored in a matrix effort. These offsets also account for the variation in read depth across samples. To perform the analysis with and without bias correction, we therefore compute two versions of the offsets, using the estimated bias vector and a dummy bias vector where the efficiencies are all set to 1.\n\n\nbias_list <- list(\n  'Corrected' = bias, \n  'Uncorrected' = bias %>% mutate(Bhat = 1)\n)\n\n# 'effort' (offset) is calculated following jsdModels.R\neffort_fun <- function(bias, phy) {\n  (sample_sums(unbias(phy, bias)) %*% \n    t(bias$Bhat[match(taxa_names(phy), bias$Taxon)])\n  ) %>% log \n}\n\neffort_list <- bias_list %>%\n  map(effort_fun, phy = phy)\n\n\n\nThe offset calculation is done as in jsdModels.R. In section ‘Quantification and statistical analysis’), Leopold and Busby (2020) explain\n\nWe accounted for 2 sources of unequal sampling effort, variable sampling depth and the species-specific sequencing biases, by including an offset term (\\(effort\\)) for each species \\(i\\) in each sample \\(j\\), in the form: \\(effort_{ij} = \\log(bias_{i} \\times depth_{j})\\), where \\(bias_i\\) is the sequencing bias correction factor for species \\(i\\), estimated from our mock communities (see above, Estimating Sequencing Bias), and \\(depth_j\\) is the total sum of all species in sample \\(j\\), after dividing each by their species-specific sequencing bias correction factor.\n\nThe call to sample_sums(unbias(phy, bias)) returns the \\(depth_{j}\\) terms as described in this paragraph.\nTo understand why this calculation yields the correct offset, consider that under our model (and in our notation) we have \\[\\begin{align}\n  \\log \\text{reads}_i(a)\n    &= \\log \\text{prop}_i (a) +\n    \\underbrace{\\log \\left[\\frac{\\text{efficiency}_i}{\\text{efficiency}_S(a)} \\cdot \\text{reads}_S(a) \\right]}_{\\text{offset}}.\n\\end{align}\\] It can be shown with some algebra that \\[\\begin{align}\n  \\frac{\\text{reads}_S(a)}{\\text{efficiency}_S(a)} \n  = \\sum_i \\frac{\\text{reads}_i(a)}{\\text{efficiency}_i}.\n\\end{align}\\] The left-hand side is the ratio of total reads to mean efficiency of the sample \\(a\\), and the right-hand side is the \\(depth_{a}\\) of sample \\(a\\) defined by Leopold and Busby (2020). It follows that the ‘effort’ terms computed by Leopold and Busby (2020) are indeed the offsets implied by our model.\nRun analysis with each set of offsets\nWe’ll wrap the analysis from jsdModels.R in a function to call with the corrected and uncorrected ‘effort’ offsets. Toggle to see the code.\n\n\nShow code\n\nanalyze_jsd_models <- function(effort, phy, nBoot=4999) { \n  ##########################\n  ### Fit genotype model ###\n  ##########################\n\n  # Make mvabund object \n  mvDat <- otu_table(phy) %>% data.frame  %>% mvabund\n\n  # Fit joint-species model for genotype effect\n  mv.full <- manyglm(mvDat ~ Genotype*Treatment, \n                     offset=effort, \n                     family=\"negative.binomial\",\n                     data=data.frame(sample_data(phy)))\n\n  # Check model assumptions\n  #plot(mv.full)\n  #meanvar.plot(mvDat~sample_data(phy)$Treatment)\n  #meanvar.plot(mvDat~sample_data(phy)$Genotype)\n\n  # Test with anova.manyglm \n  # Using unstructured correlation matrix and wald tests.  \n  # Including univariate test with adjustment for multiple testing.  \n  mv.anova <- anova(mv.full, nBoot=nBoot, p.uni=\"adjusted\", cor.type=\"shrink\", test=\"wald\")\n  #> saveRDS(mv.anova, \"output/rds/mv.genotype.rds\")\n\n  ########################\n  ### Fit region model ###\n  ########################\n\n  #' # Fit joint-species model for genotype effect\n  mv.region <- manyglm(mvDat ~ Region*Treatment, \n                       offset=effort, \n                       family=\"negative.binomial\",\n                       data=data.frame(sample_data(phy)))\n\n  #' ## Check model assumptions\n  #plot(mv.region)\n  #meanvar.plot(mvDat~sample_data(phy)$Region)\n\n  #' ## Test with anova.manyglm \n  #+ cache=T, results='asis'\n  mv.region.anova <- anova(mv.region, nBoot=nBoot, p.uni=\"adjusted\", cor.type=\"shrink\", test=\"wald\")\n  #> saveRDS(mv.region.anova, \"output/rds/mv.region.rds\")\n\n  mv.results <- bind_cols(\n    mv.anova$table %>% \n      rownames_to_column() %>%\n      filter(rowname!='(Intercept)') %>%\n      mutate(rowname = gsub(\"Genotype\",\"Host\",rowname)),\n    mv.region.anova$table %>% \n      rownames_to_column() %>%\n      filter(rowname!='(Intercept)') %>%\n      select(-rowname),\n    # NOTE: [MRM] I set the name repair function to match the original behavior\n    .name_repair = function(x) make.unique(x, sep = '')\n  ) %>%\n    gt(rowname_col = \"rowname\") %>%\n      tab_spanner(\n        label = \"Genotype\",\n        columns = vars(Res.Df, Df.diff, wald, 'Pr(>wald)')\n      ) %>%\n      tab_spanner(\n        label = \"Ecotype\",\n        columns = vars(Res.Df1, Df.diff1, wald1, 'Pr(>wald)1')\n      ) %>%\n      fmt_number(c(4,8),\n                 decimals = 1) %>%\n      fmt(c(5,9),\n          fns = function(x) {\n            ifelse(x>=0.001,round(x,3),\"< 0.001\")\n          }) %>%\n      cols_label('Pr(>wald)'=md(\"*P*-value\"),\n                 wald=md(\"Wald-χ<sup>2<sup>\"),\n                 Res.Df=md(\"Df.resid\"),\n                 Df.diff=\"Df\",\n                 'Pr(>wald)1'=md(\"*P*-value\"),\n                 wald1=md(\"Wald-χ<sup>2<sup>\"),\n                 Res.Df1=md(\"Df.resid\"),\n                 Df.diff1=\"Df\") %>%\n      cols_move_to_start(3) %>%\n      cols_move(7,5) %>%\n      cols_align(\"center\")\n  #> gtsave(mv.results,\"output/figs/jsdModels.png\")\n\n  list(\n    mv.full = mv.full,\n    mv.anova = mv.anova,\n    mv.region = mv.region,\n    mv.region.anova = mv.region.anova,\n    mv.results = mv.results\n  )\n}\n\n\n\nFinally, we run the analysis. The call is wrapped in xfun::cache_rds() to cache the results; the hash is based on the inputs and the analysis function’s source code.\n\n\nfun_src <- attr(analyze_jsd_models, 'srcref') %>% as('character')\nres <- xfun::cache_rds({\n  effort_list %>% map(analyze_jsd_models, phy = phy)\n}, hash = list(fun_src, effort_list, phy),\n  clean = FALSE\n)\n\n\n\nCompare results\nNext we compare the results of the analysis with and without bias correction.\n\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n\n\nANOVA summary tables\nFirst, let’s compare the results summary tables.\nWith bias correction\n\n\n\n      \n        Genotype\n      \n      \n        Ecotype\n      \n    Df\n      Df.resid\n      Wald-χ2\n      P-value\n      Df\n      Df.resid\n      Wald-χ2\n      P-value\n    Host\n11\n235\n20.1\n< 0.001\n1\n245\n12.4\n< 0.001Treatment\n4\n231\n21.8\n< 0.001\n4\n241\n21.6\n< 0.001Host:Treatment\n44\n187\n23.5\n0.038\n4\n237\n6.1\n0.298\n\nWithout bias correction\n\n\n\n      \n        Genotype\n      \n      \n        Ecotype\n      \n    Df\n      Df.resid\n      Wald-χ2\n      P-value\n      Df\n      Df.resid\n      Wald-χ2\n      P-value\n    Host\n11\n235\n20.3\n< 0.001\n1\n245\n12.4\n< 0.001Treatment\n4\n231\n21.5\n< 0.001\n4\n241\n21.4\n< 0.001Host:Treatment\n44\n187\n23.5\n0.03\n4\n237\n6.2\n0.261\n\nFull model\nWith bias correction\n\n\nres[['Corrected']][['mv.full']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Genotype * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.164          0.167          0.085          0.684  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.016          0.104          0.189          0.089  \n\nDegrees of Freedom: 246 Total (i.e. Null); 187 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2279.7        -1861.5      -4056.8   -1581.0    \nResidual Deviance:    256.4          324.6        250.4     305.9    \nAIC:                 2401.7         1983.5       4178.8    1703.0    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4059.2     -2800.9       -2386.3    -4014.2  \nResidual Deviance:    247.8       250.0         256.2      251.1  \nAIC:                 4181.2      2922.9        2508.3     4136.2  \n\nWithout bias correction\n\n\nres[['Uncorrected']][['mv.full']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Genotype * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.176          0.177          0.067          0.678  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.021          0.110          0.200          0.091  \n\nDegrees of Freedom: 246 Total (i.e. Null); 187 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2296.4        -1869.7      -3997.7   -1579.4    \nResidual Deviance:    256.6          321.8        249.7     306.1    \nAIC:                 2418.4         1991.7       4119.6    1701.4    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4130.5     -2813.6       -2399.7    -4019.2  \nResidual Deviance:    247.9       250.0         256.2      251.1  \nAIC:                 4252.5      2935.6        2521.7     4141.2  \n\nLet’s compare the estimated coefficients for the various response variables.\n\n\ntidy_manyglm <- function(x) {\n  x %>% coef %>%\n    as_tibble(rownames = 'term') %>%\n    pivot_longer(-term, names_to = 'response', values_to = 'estimate')\n}\n\n\n\n\n\ncoef_ests <- res %>%\n  map('mv.full') %>%\n  map_dfr(tidy_manyglm, .id = 'type')\nx <- coef_ests %>%\n  filter(term != '(Intercept)') %>%\n  pivot_wider(names_from = type, values_from = estimate)\nmse <- x %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(2)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Non-intercept coefficients, full model', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nRegion model\nWith bias correction\n\n\nres[['Corrected']][['mv.region']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Region * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.270          0.217          0.118          1.148  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.021          0.154          0.266          0.114  \n\nDegrees of Freedom: 246 Total (i.e. Null); 237 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2398.9        -1901.2      -4140.6   -1674.6    \nResidual Deviance:    259.4          314.0        251.8     296.2    \nAIC:                 2420.9         1923.2       4162.6    1696.6    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4134.5     -2897.9       -2468.6    -4078.0  \nResidual Deviance:    247.9       252.0         257.7      251.9  \nAIC:                 4156.5      2919.9        2490.6     4100.0  \n\nWithout bias correction\n\n\nres[['Uncorrected']][['mv.region']]\n\n\n\nCall:  manyglm(formula = mvDat ~ Region * Treatment, family = \"negative.binomial\",      data = data.frame(sample_data(phy)), offset = effort) \n[1] \"negative.binomial\"\n\nNuisance Parameter(s) phi estimated by the PHI method.\nAureobasidium    Trichoderma       Fusarium    Penicillium  \n        0.287          0.229          0.093          1.142  \n   Alternaria   Cladosporium      Dioszegia      Epicoccum  \n        0.028          0.165          0.280          0.117  \n\nDegrees of Freedom: 246 Total (i.e. Null); 237 Residual\n\n                    Aureobasidium  Trichoderma  Fusarium  Penicillium\n2*log-likelihood:   -2413.6        -1909.5      -4078.9   -1673.6    \nResidual Deviance:    259.9          311.7        250.8     296.2    \nAIC:                 2435.6         1931.5       4100.9    1695.6    \n                    Alternaria  Cladosporium  Dioszegia  Epicoccum\n2*log-likelihood:   -4200.8     -2915.9       -2481.6    -4083.4  \nResidual Deviance:    248.1       252.4         258.1      252.0  \nAIC:                 4222.8      2937.9        2503.6     4105.4  \n\nLet’s compare the estimated coefficients for the various response variables.\n\n\ncoef_ests <- res %>%\n  map('mv.region') %>%\n  map_dfr(tidy_manyglm, .id = 'type')\nx <- coef_ests %>%\n  filter(term != '(Intercept)') %>%\n  pivot_wider(names_from = type, values_from = estimate)\nmse <- x %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(2)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Non-intercept coefficients, region model', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nBias correction has little impact on the estimated coefficients for the non-intercept terms for either model.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-06\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ────────────────────────────────────────────────────────────────────\n package          * version  date (UTC) lib source\n ade4               1.7-18   2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5      2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1    2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1    2021-12-13 [1] CRAN (R 4.1.2)\n Biobase            2.52.0   2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0   2021-05-19 [1] Bioconductor\n biomformat         1.20.0   2021-05-19 [1] Bioconductor\n Biostrings         2.60.1   2021-06-06 [1] Bioconductor\n bitops             1.0-7    2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10   2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1    2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6    2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0    2016-07-27 [1] CRAN (R 4.0.0)\n checkmate          2.0.0    2020-02-06 [1] CRAN (R 4.0.2)\n cli                3.1.0    2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2    2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18   2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2    2021-08-11 [1] R-Forge (R 4.1.1)\n commonmark         1.7      2018-12-01 [1] CRAN (R 4.0.0)\n cowplot          * 1.1.1    2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2    2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2   2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1    2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1    2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29   2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3      2021-10-13 [1] CRAN (R 4.1.1)\n downlit            0.4.0    2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7    2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2    2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14     2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0    2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0    2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0    2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1    2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1    2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2    2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1    2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1   2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6    2021-05-31 [1] Bioconductor\n ggplot2          * 3.3.5    2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.5.1    2021-11-30 [1] CRAN (R 4.1.2)\n gt               * 0.3.1    2021-08-07 [1] CRAN (R 4.1.1)\n gtable             0.3.0    2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3    2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1    2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9      2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1    2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2    2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2    2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9    2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0   2021-05-19 [1] Bioconductor\n iterators          1.0.13   2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4    2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2    2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36     2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2    2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45  2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1    2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0    2021-10-07 [1] CRAN (R 4.1.1)\n magrittr         * 2.0.1    2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54   2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4    2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1    2021-11-26 [1] CRAN (R 4.1.2)\n mgcv               1.8-38   2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8    2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0   2021-05-19 [1] Bioconductor\n munsell            0.5.0    2018-06-12 [1] CRAN (R 4.0.0)\n mvabund          * 4.1.12   2021-05-28 [1] CRAN (R 4.1.2)\n NADA               1.6-1.1  2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153  2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102  2021-11-12 [1] local\n patchwork        * 1.1.1    2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5    2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0   2021-05-19 [1] Bioconductor\n pillar             1.6.4    2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3    2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6    2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4    2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1    2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp               1.0.7    2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5 2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1    2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1    2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1    2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4    2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0   2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0    2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2   2021-07-06 [1] Bioconductor\n rlang              0.4.12   2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11     2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2    2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13     2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2    2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0   2021-05-19 [1] Bioconductor\n sass               0.4.0    2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1    2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2    2021-12-06 [1] CRAN (R 4.1.2)\n statmod            1.4.36   2021-05-10 [1] CRAN (R 4.1.0)\n stringi            1.7.6    2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0    2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13   2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6    2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4    2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1    2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1    2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8    2018-02-27 [1] CRAN (R 4.0.1)\n tweedie            2.3.3    2021-01-20 [1] CRAN (R 4.0.4)\n tzdb               0.2.0    2021-10-27 [1] CRAN (R 4.1.2)\n utf8               1.2.2    2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8    2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7    2020-11-28 [1] CRAN (R 4.0.3)\n withr              2.4.3    2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28     2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3    2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0   2021-05-19 [1] Bioconductor\n yaml               2.2.1    2020-02-01 [1] CRAN (R 4.0.0)\n zCompositions      1.3.4    2020-03-04 [1] CRAN (R 4.0.1)\n zlibbioc           1.38.0   2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n───────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-06-leopold2020host-original-regression-analysis/leopold2020host-original-regression-analysis_files/figure-html5/unnamed-chunk-9-1.svg",
    "last_modified": "2022-01-08T13:39:28-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-05-leopold2020host-priority-effects/",
    "title": "Perform Leopold and Busby (2020) priority-effects analysis with and without bias correction",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2022-01-05",
    "categories": [
      "ref:leopold2020host",
      "differential abundance",
      "bias sensitivity"
    ],
    "contents": "\n\nContents\nRun analyses with and without bias correction\nCompare results\nSession info\n\nThis Rmd determines whether bias correction has an impact on the analysis of priority effects in Leopold and Busby (2020).\nRun analyses with and without bias correction\n\n\nlibrary(here)\n\nset.seed(42)\n\n\n\nhttps://github.com/dleopold/Populus_priorityEffects\nThis script follows the analysis of code/priorityEffects.R\nStart by running the setup of libraries and loading the phyloseq object and bias estimate. The code is verbatim from the Leopold and Busby (2020) code except for the changes in directory necessary for the calls to source() and file reading.\n\n\n# Analysis of the relative advantage of preemptive colonization.\n\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(phyloseq)\nlibrary(foreach)\nlibrary(doMC)\nlibrary(ggthemes)\n\nthis_dir <- getwd()\nsetwd(here('notebook/_data/leopold2020host/dleopold-Populus_priorityEffects-8594f7c/'))\n\nsource(\"code/Rfunctions.R\")\nsource(\"code/colors.R\")\n\n# register cores for parallel processing\nregisterDoMC(parallel::detectCores())\n\n# load phyloseq data\n(phy <- loadPhyloseq())\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 8 taxa and 247 samples ]\nsample_data() Sample Data:       [ 247 samples by 16 sample variables ]\ntax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]\nrefseq()      DNAStringSet:      [ 8 reference sequences ]\n\n# identify focal taxa for plotting \nfocalTaxa <- unique(sample_data(phy)$Treatment)\n\n# Extract OTU data, convert to proportions and long format\nbias <- read.csv(\"output/tabs/bias.csv\")\n\nsetwd(this_dir)\n\n\n\nNext, we wrap the analyses of the original study within a function analyze_priority_effects() to facilitate running the same analyses on the calibrated and uncalibrated profiles. The code in the function is copied verbatim from the source in code/priorityEffects.R except that the call to unbias() in the very first line is skipped so that we can control whether correction is done. Click the toggle to expand the code chunk.\n\n\nShow code\n\nanalyze_priority_effects <- function(phy, nboots = 10000) { \n  df <- phy %>%\n    transform_sample_counts(function(x){x/sum(x)}) %>%\n    otu_table %>% data.frame %>%\n    dplyr::select(all_of(focalTaxa)) %>%\n    bind_cols(sample_data(phy) %>% data.frame %>% \n                dplyr::select(Region,Genotype,Treatment)) %>%\n    pivot_longer(all_of(focalTaxa),names_to=\"Taxa\",values_to=\"proportion\") %>%\n    mutate(Focal=ifelse(Taxa==Treatment,T,F),\n           Region=ifelse(Region==\"East\",\"E\",\"W\") %>%\n             factor(levels=c(\"W\",\"E\")))\n\n  # Define a function to calculate the estimated priority effect strength for each species on each host genotype as the log-ratio of the proportional abundance when arriving early vs not arriving early\n  getPEs <- function(df) {\n    df %>% group_by(Focal,Region,Taxa,Genotype,Treatment) %>%\n      summarize_all(gm_mean) %>% ungroup %>%\n      group_by(Region,Genotype,Taxa) %>%\n      summarise(PE=log(mean(proportion[Focal])/mean(proportion[!Focal])))\n  }\n  meanPEs <- getPEs(df) \n  meanPEs$Genotype %<>% factor(.,levels=unique(.))\n\n  #####################\n  ### Bootstrap CIs ###\n  #####################\n\n  # Get bootstrap confidence intervals on point estimates of priority effects for each species on each genotype\n  # nboots <- 10000\n  bootPEs <- foreach(i=1:nboots, .combine=bind_rows) %dopar% {\n    df %>% group_by(Region, Taxa, Genotype,Focal,Treatment) %>%\n      sample_frac(replace=T) %>%\n      getPEs() %>% mutate(bootID=i)\n  }\n  bootPEs$Genotype %<>% factor(.,levels=unique(bootPEs$Genotype))\n\n  # Get bias corrected and accelerated confidence intervals\n  bootPE.ci <- bootPEs %>% \n    group_by(Genotype,Taxa) %>%\n    summarize(LCI=coxed::bca(PE)[1],\n              UCI=coxed::bca(PE)[2]) %>% full_join(meanPEs)\n\n  ###################\n  ### Region test ###\n  ###################\n\n  # First get the mean priority effect for each species on eastern and western genotypes\n  regionPEs <- meanPEs %>% group_by(Region,Taxa) %>%\n    summarize(meanPE=mean(PE),\n              tstat=t.test(PE,mu=0,alternative=\"greater\") %>% .$statistic)\n\n  # Run bootstrapped t-test using 100 bootstraps at the region level for each of the previously generated genotype-level bootstraps\n  bootRegion <- foreach(i=1:100,.combine=bind_rows) %dopar% {\n    bootPEs %>% \n      group_by(Region,Taxa,bootID) %>%\n      sample_frac(replace=T) %>%\n      left_join(regionPEs,by=c(\"Region\",\"Taxa\")) %>%\n      mutate(center=PE-meanPE) %>%\n      summarize(mu.boot=mean(PE),\n                tstat.obs=mean(tstat),\n                tstat.boot=ifelse(var(center)==0,ifelse(mean(PE)>mean(meanPE),Inf,-Inf),\n                                  t.test(center,mu=0) %>% .$statistic))}\n  # calculate bootstrapped p-values (one-tailed test for significant positive priority effects)\n  bootRegionPvals <- bootRegion %>% drop_na %>%\n    mutate(test = tstat.boot+1>tstat.obs+1) %>% \n    summarize(pval=mean(as.numeric(test))) %>%\n    mutate(stars=gtools:::stars.pval(pval) %>% gsub(\".\",\"+\",fixed = T,.)) \n  regionSig <- bootRegion %>% summarize(mu.boot.max=max(mu.boot)) %>%\n    left_join(bootRegionPvals)\n\n  ############\n  ### PLOT ###\n  ############\n\n  #' Define a function to plot the regional priority effects bootstrap results \n  get_inset <- function(df,inset.ymin,inset.ymax){\n    ggplot(df, \n           aes(x=Region,y=mu.boot)) +\n      geom_violin(scale=\"width\",fill=\"grey75\",color=\"grey75\") + \n      geom_text(data=df %>% dplyr::select(Region,Taxa,stars,mu.boot.max) %>%\n                  slice(1),\n                aes(label=stars,y=mu.boot.max),size=5)+\n      geom_hline(yintercept = 0,alpha=0.4,linetype=\"dotted\")+\n      coord_cartesian(clip='off')+\n      ylim(c(inset.ymin,inset.ymax))+\n      theme_few()+\n      theme(strip.text = element_blank(),\n            axis.title = element_blank(),\n            panel.border = element_blank(),\n            axis.line = element_line(color=\"black\",size=0.2))\n  }\n\n  # create inset plots as a list\n  insets <- bootRegion %>% \n    left_join(dplyr::select(regionSig,Region,Taxa,stars,mu.boot.max)) %>%\n    split(f = .$Taxa) %>%\n    purrr::map(~annotation_custom2(\n      grob = ggplotGrob(get_inset(.,min(bootRegion$mu.boot),max(bootRegion$mu.boot))), \n      data = data.frame(Taxa=unique(.$Taxa)),\n      ymin = 2.4, ymax=Inf, xmin=4, xmax=Inf)\n    )\n\n  # make full plot of bootstrapped priority effects results\n  plt <- ggplot(bootPE.ci,aes(x=Genotype,y=PE))+\n    geom_pointrange(aes(ymin=LCI,ymax=UCI,fill=Genotype,shape=Genotype),\n                    size=0.5,stroke=0.35,fatten=5.5)+\n    scale_shape_manual(\"Host genotype\", values=c(rep(21,7),rep(23,5)))+\n    scale_fill_manual(\"Host genotype\",values=pal.genotype)+\n    geom_hline(yintercept = 0,alpha=0.6,linetype=\"dotted\")+\n    scale_x_discrete(breaks = levels(bootPEs$Genotype),\n                     limits = c(levels(bootPEs$Genotype)[1:7], \"skip1\",\n                                levels(bootPEs$Genotype)[8:12]),\n                     expand=expansion(0.075))+\n    ylab(\"Strength of priority effect\")+\n    labs(tag=\"Eastern              Western\")+\n    coord_cartesian(clip='off')+\n    ylim(c(-1,3.5))+\n    facet_wrap(~Taxa,scales=\"free_x\",nrow=1)+\n    guides(fill = guide_legend(override.aes = list(size=0.8)))+\n    theme_few()+\n    theme(axis.title.x = element_blank(),\n          axis.text.x = element_blank(),\n          axis.ticks.x = element_blank(),\n          strip.text = element_text(size=14,face=\"italic\"),\n          axis.title.y = element_text(size=14),\n          legend.title = element_text(size=14),\n          legend.text = element_text(size=12),\n          legend.margin=margin(6,6,6,12),\n          plot.tag = element_text(angle=90,hjust=0),\n          plot.tag.position = c(0.848,0.115))+\n    insets\n  # ggsave(\"output/figs/Fig.3.pdf\",width=24,height=10,units=\"cm\")\n\n  return(\n    list(\n      meanPEs = meanPEs, \n      bootPEs = bootPEs,\n      bootPE.ci = bootPE.ci,\n      regionPEs = regionPEs,\n      bootRegion = bootRegion,\n      bootRegionPvals = bootRegionPvals,\n      plot = plt\n    )\n  )\n}\n\n\n\nNext, we run the analysis on the phyloseq objects with and without bias correction (calibration). Leopold and Busby (2020) use a custom function unbias() for bias correction, which also implements a zero-replacement procedure. In order to keep the calibrated and uncalibrated analyses comparable, we should apply the same zero-replacement procedure in both cases. We do this by applying unbias() with the supplied bias vector set to all 1s, which corresponds to no bias.\n\n\nbias_list <- list(\n  'Corrected' = bias, \n  'Uncorrected' = bias %>% mutate(Bhat = 1)\n)\nphy_list <- bias_list %>% map(~unbias(phy, .x))\n\n\n\nThe only difference between the two phyloseq objects should be a perturbation by the bias vector, which we can check by using metacal::calibrate().\n\n\ntmp <- metacal::perturb(\n  phy_list$Corrected, \n  bias %>% filter(Taxon != 'Melampsora') %>% select(Taxon, Bhat) %>% deframe,\n  norm = 'keep'\n)\nlist(phy_list$Uncorrected, tmp) %>%\n  map(otu_table) %>%\n  map(transform_sample_counts, function(x) x / sum(x)) %>%\n  {all.equal(.[[1]], .[[2]])}\n\n\n[1] TRUE\n\nThe sample totals are affected by unbias() such that they differ between the corrected and uncorrected objects,\n\n\nphy_list$Corrected %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n   13838.643    13877.175     6882.873 \n\ntmp %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n   13838.643    13877.175     6882.873 \n\nphy_list$Uncorrected %>% sample_sums %>% head(3)\n\n\nG1.T1.R1.TP1 G1.T1.R2.TP1 G1.T1.R4.TP1 \n       24815        24599        11290 \n\nBut since the analysis function converts the counts to proportions in the first step, this difference can’t impact the results.\nFinally, we run the analysis on both the corrected and uncorrected phyloseq objects. The call is wrapped in xfun::cache_rds() to cache the results; the hash is based on the inputs and the analysis function’s source code.\n\n\nfun_src <- attr(analyze_priority_effects, 'srcref') %>% as('character')\nres <- xfun::cache_rds({\n  phy_list %>% map(analyze_priority_effects)\n}, hash = list(fun_src, phy_list, focalTaxa),\n  clean = FALSE\n)\n\n\n\nCompare results\nNext we compare the results of the analysis with and without bias correction.\n\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n\n\n\n\nres %>% names\n\n\n[1] \"Corrected\"   \"Uncorrected\"\n\nres[[1]] %>% names\n\n\n[1] \"meanPEs\"         \"bootPEs\"         \"bootPE.ci\"      \n[4] \"regionPEs\"       \"bootRegion\"      \"bootRegionPvals\"\n[7] \"plot\"           \n\nFirst, let’s compare the main text figure with and without correction,\n\n\nmap2(map(res, 'plot'), names(res), ~.x + ggtitle(.y)) %>%\n  {.[[1]]  / .[[2]]} &\n  theme(plot.title.position = 'plot')\n\n\n\n\nThe results are nearly indistinguishable; bias correction has no significant impact.\nNext, let’s compare the point estimates of the priority effects,\n\n\nx <- res %>%\n  map_dfr('meanPEs', .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = PE)\nmse <- x %>%\n  ungroup %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(3)\nx %>%\n  ggplot(aes(Uncorrected, Corrected, color = Region)) +\n  coord_fixed() +\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Effect of bias correction on priority-effect estimate', \n    subtitle = str_glue('Mean squared difference: {mse}')\n  ) +\n  theme(plot.title.position = 'plot') +\n  scale_color_brewer(type = 'qual', palette = 2)\n\n\n\n\nThere is very little impact on the point estimates. Now, let’s compare the bootstrap confidence intervals with and without correction,\n\n\nres %>%\n  map_dfr('bootPE.ci', .id = 'type') %>%\n  ggplot(aes(x = Genotype, y = PE, color = type, ymin = LCI, ymax =UCI)) +\n  facet_wrap(~Taxa, scales = \"fixed\", ncol = 1) +\n  geom_pointrange(position = position_dodge(width = 0.5)) +\n  scale_color_brewer(type = 'qual') +\n  theme(\n    plot.title.position = 'plot',\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  ) +\n  labs(title = 'Effect of bias correction on priority-effect CIs')\n\n\n\n\nThis fig clearly shows the equivalence of results with uncorrected and corrected taxonomic profiles.\nLet’s do similar for the regional PEs.\n\n\nx <- res %>%\n  map_dfr('regionPEs', .id = 'type') %>%\n  pivot_longer(c(meanPE, tstat)) %>%\n  pivot_wider(names_from = type)\nmse <- x %>%\n  ungroup %>%\n  filter(name == 'meanPE') %>%\n  summarize(\n    mse = mean((Corrected - Uncorrected)^2)\n  ) %>% .[[1]] %>% signif(3)\nx %>%\n  ggplot(aes(Uncorrected, Corrected)) +\n  facet_wrap(~name, scales = 'free') +\n  # coord_fixed() + # doesn't work with free scales\n  geom_abline(color = 'darkred') +\n  geom_point() +\n  labs(title = 'Effect of bias correction on regional priority-effect estimate', \n    subtitle = str_glue('Mean squared difference in meanPE: {mse}')\n  ) +\n  theme(plot.title.position = 'plot')\n\n\n\n\nAgain there is almost no effect, except that the largest t statistic is somewhat larger before bias correction.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-06\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ────────────────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.1     2021-06-06 [1] Bioconductor\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10     2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.0      2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n doMC             * 1.3.7      2020-10-14 [1] CRAN (R 4.1.2)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach          * 1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n ggthemes         * 4.2.4      2021-01-20 [1] CRAN (R 4.0.4)\n glue               1.5.1      2021-11-30 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9      2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators        * 1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr         * 2.0.1      2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal            0.2.0.9008 2021-10-30 [1] Github (mikemc/metacal@c1f21db)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n NADA               1.6-1.1    2020-03-22 [1] CRAN (R 4.0.1)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n truncnorm          1.0-8      2018-02-27 [1] CRAN (R 4.0.1)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28       2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)\n zCompositions      1.3.4      2020-03-04 [1] CRAN (R 4.0.1)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n───────────────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2022-01-05-leopold2020host-priority-effects/leopold2020host-priority-effects_files/figure-html5/unnamed-chunk-7-1.svg",
    "last_modified": "2022-01-08T13:39:28-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-15-momspi-regression-diversity/",
    "title": "MOMS-PI: Regression on diversity",
    "description": "Analyze the impact of bias on a DA analysis of relative abundances versus diversity.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-12-15",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\n\nContents\nSetup\nR setup\nMOMS-PI setup\n\nRegression analysis\nClassify samples into high and low diversity groups\nRegression setup\nLinear regression on log proportion\nAlternate zero-replacement strategy\nInterpretion\n\nRank-based analysis\nGamma-Poisson regression\n\nSanity checks\nOffsets with lm()\nZeros with lm()\n\nSession info\n\nSetup\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\nlibrary(here)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(ggforce)\nlibrary(ggdist)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9009'\n\n\n\ntheme_set(theme_cowplot())\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nMOMS-PI setup\nLoad the MOMS-PI profiles and estimate bias,\n\n\nsource(here('notebook/_code/momspi-setup.R'))\nbias <- bias_all_vec\n\n\n\nTo simplify interpretation of some of the regression models, let’s rarefy samples to 10K reads (we’ll be dropping some samples that are below this limit).\n\n\nmomspi_rare <- xfun::cache_rds({\n  momspi %>% \n    rarefy_even_depth(\n      sample.size = 1e4, \n      rngseed = 42,\n      replace = FALSE,\n      trimOTUs = FALSE\n    )\n}, dir = '_cache/', file = 'momspi_rare', hash = list(momspi))\n# Make sure no taxa have 0 reads, in case this causes issues later on\nstopifnot(all(momspi_rare %>% taxa_sums > 0))\n\n\n\nLet’s also add the new sample sums and estimated mean efficiency and\n\n\nmomspi_rare <- momspi_rare %>% \n  mutate_sample_data(., \n    sample_sum_original = sample_sum,\n    sample_sum = sample_sums(.),\n    mean_efficiency = mean_efficiency(., bias, type = 'observed')\n  )\n\n\n\nLet’s also add the top species in each sample,\n\n\nget_top_species <- function(ps) {\n  x <- ps %>%\n    transform_sample_counts(close_elts) %>%\n    otu_table %>%\n    as_tibble(pivot = TRUE) %>%\n    with_groups(.sample, slice_max, .abundance, n = 1)\n  if (anyDuplicated(x$.sample))\n    stop('Ties present')\n  x %>% select(.sample, top_species = .otu)\n}\ntop_species <- list(\n  'obs' = momspi_rare,\n  'cal' = momspi_rare %>% calibrate(bias)\n  ) %>%\n  map_dfr(get_top_species, .id = 'type')\ntop_species_wide <- top_species %>%\n  pivot_wider(values_from = top_species, names_from = type, \n    names_prefix = 'top_species_') \nmomspi_rare <- momspi_rare %>%\n  left_join_sample_data(top_species_wide, by = '.sample')\n\n\n\nRegression analysis\nClassify samples into high and low diversity groups\nCompute Shannon and Inverse-Simpson diversity indices and add to the sample metadata. Phyloseq::estimate_richness() will complain about the lack of singletons, but we can ignore this since we aren’t using species richness estimators. I will exponentiate the Shannon index to convert it to the q1 Hill number so that (like Inverse Simpson) it has the scale of number of species.\n\n\ndiv <- list(\n  'obs' = momspi_rare,\n  'cal' = momspi_rare %>% calibrate(bias)\n) %>%\n  map(estimate_richness, measures = c('Shannon', 'InvSimpson')) %>%\n  map_dfr(as_tibble, rownames = '.sample', .id = 'type') %>%\n  transmute(\n    .sample, type,\n    div_q1 = exp(Shannon),\n    div_q2 = InvSimpson,\n  ) %>%\n  pivot_longer(starts_with('div_'), names_to = 'index', values_to = 'diversity')\ndiv_wide <- div %>%\n  pivot_wider(values_from = diversity, names_from = c('index', 'type')) \n\n\n\n\n\np <- div_wide %>%\n  mutate(across(starts_with('div'), log2)) %>%\n  ggplot() +\n  geom_autopoint(aes(x = .panel_x, y = .panel_y), alpha = 0.5) +\n  geom_autodensity() +\n  geom_bin2d(aes(x = .panel_x, y = .panel_y)) +\n  facet_matrix(vars(starts_with('div')), layer.diag = 2, layer.lower = 3)\nggrastr::rasterize(p, dpi = 300)\n\n\n\n\nThe observed (Log) order-1 and order-2 diversity show a tight correlation with each other, as do the calibrated diversities, while the correlation is much lower when comparing observed and calibrated numbers. The reason is likely that calibration will tend to increase the diversity of samples that are observed to be dominated by a high-efficiency taxon (like L. iners) and decrease the diversity of samples dominated by a low efficiency tason (like G. vaginalis).\nShannon diversity of the observed profiles is what is most often considered in vaginal microbiome studies, so let’s use this metric to partition the samples.\n\n\ndiv_wide %>%\n  ggplot(aes(x = div_q1_obs)) +\n  scale_x_log10() +\n  annotate('rect', xmin = 0, xmax = 1.5, ymin = -Inf, ymax = Inf, \n    fill = 'blue', alpha = 0.3) +\n  annotate('rect', xmin = 1.5, xmax = 3, ymin = -Inf, ymax = Inf, \n    fill = 'grey', alpha = 0.3) +\n  annotate('rect', xmin = 3, xmax = Inf, ymin = -Inf, ymax = Inf, \n    fill = 'green', alpha = 0.3) +\n  geom_histogram() +\n  geom_vline(xintercept = c(1.5, 3), color = 'black')\n\n\n\n\nI’ll pick the first mode as the ‘Low diversity’ group, treat the second mode as ‘Medium’, and the tail as ‘High’.\n\n\ndiv_wide <- div_wide %>%\n  mutate(\n    div_group = case_when(\n      div_q1_obs < 1.5 ~ 'Low',\n      div_q1_obs > 3 ~ 'High',\n      TRUE ~ 'Medium'\n    ) %>% factor(levels = c('Low', 'Medium', 'High'))\n  )\n\n\n\nRegression setup\nAdd the diversity grouping information, subset to the Low and High samples, and compute the offsets for the Gamma-Poisson model\n\n\nmomspi_div <- momspi_rare %>%\n  left_join_sample_data(div_wide, by = '.sample') %>%\n  filter_sample_data(div_group %in% c('Low', 'High'))\n\n\n\nWe’ll use the criterion from Fettweis et al to pick the taxa to test. Note, we may not get the same exact taxa as them since we’re using a larger set of women and ignoring the medium-diversity samples. Note, the log proportions used in the regression analysis below are with respect to the full species set.\n\n\ntaxa_to_test <- momspi_div %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~ mean(. >= 1e-2) >= 0.05 | mean(. >= 1e-3) >= 0.15) %>%\n  taxa_names %>%\n  print\n\n\n [1] \"Lachnospiraceae_BVAB1\"         \"Aerococcus_christensenii\"     \n [3] \"Atopobium_vaginae\"             \"Campylobacter_ureolyticus\"    \n [5] \"Clostridiales_BVAB2\"           \"Clostridiales_OTU22\"          \n [7] \"Coriobacteriaceae_OTU27\"       \"Corynebacterium_cluster45\"    \n [9] \"Dialister_cluster51\"           \"Dialister_micraerophilus\"     \n[11] \"Dialister_propionicifaciens\"   \"Finegoldia_magna\"             \n[13] \"Gardnerella_vaginalis\"         \"Lactobacillus_crispatus\"      \n[15] \"Lactobacillus_gasseri_cluster\" \"Lactobacillus_iners\"          \n[17] \"Lactobacillus_jensenii\"        \"Megasphaera_OTU70_type1\"      \n[19] \"Mycoplasma_hominis\"            \"Parvimonas_OTU142\"            \n[21] \"Peptoniphilus_indolicus\"       \"Prevotella_amnii\"             \n[23] \"Prevotella_bivia\"              \"Prevotella_cluster2\"          \n[25] \"Prevotella_cluster50\"          \"Prevotella_disiens\"           \n[27] \"Sneathia_amnii\"                \"Sneathia_sanguinegens\"        \n[29] \"TM7_OTU-H1\"                    \"Ureaplasma_cluster23\"         \n\nWhat is the fraction of zeros for the tested species?\n\n\nmomspi_div %>%\n  prune_taxa(taxa_to_test, .) %>%\n  as_tibble %>%\n  with_groups(.otu, summarize,\n    prev = mean(.abundance > 0),\n    frac_zero = mean(.abundance == 0),\n  ) %>%\n  arrange(prev) %>%\n  knitr::kable(digits = 2)\n\n\n.otu\nprev\nfrac_zero\nTM7_OTU-H1\n0.19\n0.81\nPrevotella_amnii\n0.29\n0.71\nMycoplasma_hominis\n0.33\n0.67\nClostridiales_BVAB2\n0.33\n0.67\nSneathia_sanguinegens\n0.34\n0.66\nParvimonas_OTU142\n0.36\n0.64\nPrevotella_cluster50\n0.39\n0.61\nCampylobacter_ureolyticus\n0.39\n0.61\nLactobacillus_gasseri_cluster\n0.39\n0.61\nDialister_propionicifaciens\n0.40\n0.60\nClostridiales_OTU22\n0.42\n0.58\nCoriobacteriaceae_OTU27\n0.42\n0.58\nPrevotella_disiens\n0.44\n0.56\nSneathia_amnii\n0.45\n0.55\nMegasphaera_OTU70_type1\n0.49\n0.51\nLactobacillus_jensenii\n0.51\n0.49\nAerococcus_christensenii\n0.51\n0.49\nLachnospiraceae_BVAB1\n0.53\n0.47\nPeptoniphilus_indolicus\n0.53\n0.47\nDialister_cluster51\n0.55\n0.45\nPrevotella_bivia\n0.56\n0.44\nCorynebacterium_cluster45\n0.57\n0.43\nUreaplasma_cluster23\n0.59\n0.41\nAtopobium_vaginae\n0.61\n0.39\nDialister_micraerophilus\n0.64\n0.36\nFinegoldia_magna\n0.65\n0.35\nLactobacillus_crispatus\n0.71\n0.29\nPrevotella_cluster2\n0.78\n0.22\nGardnerella_vaginalis\n0.81\n0.19\nLactobacillus_iners\n0.96\n0.04\n\nLinear regression on log proportion\nThe simple linear regression is the fastest and simplest approach, and the easiest to understand using results from the manuscript.\nFirst, we need to ensure there are no zeros. I’ll try two approaches; the first is to use a pseudocount of 0.5.\n\n\nstat_test <- function(ps, taxa) {\n  ps %>%\n    filter_sample_data(div_group %in% c('Low', 'High')) %>%\n    transform_sample_counts(close_elts) %>%\n    prune_taxa(taxa, .) %>%\n    as_tibble %>%\n    with_groups(.otu, nest) %>%\n    mutate(\n      fit = map(data,\n        ~lm(log(.abundance) ~ div_group, data = .x)\n      ),\n    ) %>%\n    select(-data)\n}\nres_lm <- list(\n  'Observed' = momspi_div %>% transform_sample_counts(~. + 0.5),\n  'Calibrated' = momspi_div %>% transform_sample_counts(~. + 0.5) %>%\n    calibrate(bias)\n) %>%\n  map_dfr(stat_test, taxa = taxa_to_test, .id = 'type')\nres_lm_tidy <- res_lm %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\n# x should be the outout of a tidier\nplot_estimates <- function(x) {\n  err <- x %>%\n    select(name = type, .otu, value = estimate) %>%\n    pivot_wider() %>%\n    mutate(\n      error = Observed - Calibrated,\n      error_sign = sign(Observed) == sign(Calibrated),\n      sign = case_when(\n        sign(Observed) > 0 & sign(Calibrated) > 0 ~ 'Positive',\n        sign(Observed) < 0 & sign(Calibrated) < 0 ~ 'Negative',\n        TRUE ~ 'Depends',\n      )\n    ) %>%\n    select(.otu, error_sign, sign)\n\n  p1 <- x %>%\n    left_join(err, by = '.otu') %>%\n    ggplot(aes(y = type, x = estimate, fill = sign)) +\n    scale_fill_brewer(type = 'qual', palette = 2,\n      guide = guide_legend(reverse = TRUE)) +\n    geom_vline(xintercept = 0, color = 'grey') +\n    ggdist::geom_dots() +\n    labs(fill = 'Sign of estimate', x = 'Estimated LFC', y = 'Meas. type')\n  p2 <- x %>%\n    mutate(\n      .otu_fct = fct_reorder(.otu, estimate, .fun = max) %>%\n        fct_relabel(function(x) str_replace_all(x, '_', ' '))\n    ) %>%\n    ggplot(aes(y = .otu_fct, x = estimate, color = type)) +\n    # scale_color_brewer(type = 'qual', palette = 7) +\n    colorblindr::scale_color_OkabeIto() +\n    geom_vline(xintercept = 0, color = 'grey') +\n    geom_linerange(size = 1,\n      aes(\n        xmin = estimate - 2*std.error,\n        xmax = estimate + 2*std.error\n      )) +\n    geom_point(size = 1.5) +\n    labs(y = 'Species-level OTU', x = 'Estimated LFC', color = 'Meas. type')\n  p1 / p2 +\n    plot_layout(ncol = 1, heights = c(0.3, 1)) +\n    plot_annotation(tag_levels = 'A') &\n    theme_minimal_hgrid()\n}\n\n\n\n\n\nplot_estimates(res_lm_tidy)\n\n\n\n\nThe data is unlikely to meet the assumptions generally considered necessary for simple linear regression. In particular, the standard errors (and confidence intervals) are likely to be much too small. Bootstrapped intervals could be used to address this issue, if we are interested in understanding the impact of bias on confidence intervals in a more realistic scenario.\nAlternate zero-replacement strategy\nLet’s also try adjust the proportions to the Dirichlet posterior mean, with the prior set to the average proportions across all samples. This amounts to a pseudocount of ntaxa times the mean (observed) proportion of the species, and so adjusts for differences in mean proportion among species.\n\n\nmomspi_div_alt <- momspi_div %>% \n  adjust_dirchlet\n\n\n\n\n\nres_alt_lm <- list(\n  'Observed' = momspi_div_alt,\n  'Calibrated' = momspi_div_alt %>% calibrate(bias)\n) %>%\n  map_dfr(stat_test, taxa = taxa_to_test, .id = 'type')\nres_alt_lm_tidy <- res_alt_lm %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\nplot_estimates(res_alt_lm_tidy)\n\n\n\n\nInterpretion\nCheck the diversity-efficiency relationship\n\n\nsam <- momspi_div %>% sample_data %>% as_tibble\nsam %>%\n  ggplot(aes(y = div_group, x = mean_efficiency)) +\n  scale_x_log10() +\n  ggdist::stat_slab()\n\n\n\n\nFrom this plot, we can see that the mean efficiency is 3-10X lower in the High diversity relative to the low diversity group.\nThe results of a linear regression analysis give us the systematic error in LFCs for the simple linear regression,\n\n\nmean_eff_lm <- lm(log(mean_efficiency) ~ div_group,\n  data = sam\n)\nmean_eff_lm %>% summary\n\n\n\nCall:\nlm(formula = log(mean_efficiency) ~ div_group, data = sam)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-3.02856 -0.24524 -0.01627  0.28631  1.61043 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   -0.34795    0.02371  -14.68   <2e-16 ***\ndiv_groupHigh -1.56081    0.03122  -50.00   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5494 on 1267 degrees of freedom\nMultiple R-squared:  0.6637,    Adjusted R-squared:  0.6634 \nF-statistic:  2500 on 1 and 1267 DF,  p-value: < 2.2e-16\n\nmean_eff_lfc <- mean_eff_lm %>% broom::tidy() %>% \n  filter(term == 'div_groupHigh') %>% pull(estimate)\n\n\n\n\n\nres_lm_tidy %>%\n  select(name = type, .otu, value = estimate) %>%\n  pivot_wider() %>%\n  mutate(\n    error = Observed - Calibrated,\n  ) %>%\n  pull(error) %>%\n  summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.517   1.517   1.517   1.517   1.517   1.517 \n\nmean_eff_lfc \n\n\n[1] -1.560813\n\nCan see that the errors are the same for all species, and nearly equal to the negative LFC in mean efficiency. A small difference is expected from the addition of pseudocounts for the species regression.\nTo understand why the mean efficiency is lower, can try a scatterplot of mean efficiency against diversity with samples colored by most abundant species.\n\n\ndiv1 <- div %>%\n  left_join(\n    momspi_rare %>% sample_data %>% as_tibble,\n    by = '.sample'\n  ) %>%\n  mutate(\n    top_species_plot = fct_lump_n(top_species_cal, 7)\n  )\n\n\n\n\n\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \ndiv1 %>%\n  ggplot(aes(diversity, mean_efficiency, color = top_species_plot)) +\n  facet_grid(type~index) +\n  scale_x_log10() +\n  scale_y_log10() +\n  ggrastr::rasterize(geom_point(alpha = 0.6), dpi = 300) +\n  stat_smooth(aes(group = 'none'), color = 'black') +\n  labs(color = 'Top species', x = 'Diversity', y = 'Mean efficiency') +\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n\nRank-based analysis\nWilcoxon test and Spearman rho are popular ‘non-parametric’ approaches to differential abundance. Wilcoxon is used when the covariate is binary (case vs control) and Spearman is used when the covariate is continuous. Both are approximately equivalent (in terms of p value) to performing a linear regression on rank-transformed data.\nFor the binary-variable case here, we can use a Wilcoxon test; however, I’ll also use a linear model to get confidence intervals.\nZeros: The rank-based tests don’t require log transformation and so are ok with zeros. Therefore we have at least three options:\nleave the zeros\nuse a 0.5 pseudocount\nuse the Dirichlet-posterior pseudocount \nBased on previous experimentation and vague intuition, I suspect that we will see a big difference in the impact of calibration on #1 versus the other two approaches, but only a modest difference between #2 and #3.\nNote, the outcome of the rank-based tests on the ‘Observed’ (uncalibrated) profiles will not depend on the zero replacement strategies, since all zero entries will be set to the same small value and thus still tied for the lowest value (hence giving the same rank). But the ‘Calibrated’ profiles will differ, since the calibrated proportion of a taxon depends on the pre-calibration proportions of all taxa, which will vary from sample to sample.\n\n\nps_set <- list(\n  'None' = momspi_div,\n  'Strategy 1' = momspi_div %>% transform_sample_counts(~. + 0.5),\n  'Strategy 2' = momspi_div_alt \n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(filter_sample_data, div_group %in% c('Low', 'High')) %>%\n  enframe('zero_replacement', 'Observed') %>%\n  mutate(Calibrated = map(Observed, calibrate, bias)) %>%\n  pivot_longer(c(Observed, Calibrated), names_to = 'type', values_to = 'ps')\n\n\n\n\n\nstat_test <- function(ps, taxa, test, ...) {\n  ps %>%\n    prune_taxa(taxa, .) %>%\n    as_tibble %>%\n    with_groups(.otu, nest) %>%\n    mutate(\n      fit = map(data, function(.data) test(data = .data, ...))\n    ) %>%\n    select(-data)\n}\n#> a = stat_test(momspi_div, taxa_to_test, wilcox.test, .abundance ~ div_group)\n#> a %>% slice(1) %>% pull(fit)\nres_rank <- xfun::cache_rds({\n  ps_set %>%\n    mutate(\n      wilcox = map(ps, stat_test, taxa_to_test, wilcox.test, \n        .abundance ~ div_group),\n      lm = map(ps, stat_test, taxa_to_test, lm, \n        rank(.abundance)/length(.abundance) ~ div_group),\n    ) %>%\n    pivot_longer(c(wilcox, lm), names_to = 'test', values_to = 'fit') %>%\n    select(-ps) %>%\n    unnest(fit)\n}, dir = '_cache/', file = 'res_rank', \nhash = list(ps_set, stat_test, taxa_to_test))\n\nres_rank_tidy <- res_rank %>% \n  mutate(across(fit, map, broom::tidy, conf.int = TRUE)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)' | is.na(term))\n\n\n\nCheck agreement between p values -\n\n\nres_rank_tidy %>%\n  select(zero_replacement:.otu, p.value) %>%\n  pivot_wider(names_from = test, values_from = p.value) %>%\n  ggplot(aes(wilcox, lm)) +\n  scale_x_log10() +\n  scale_y_log10() +\n  coord_fixed() +\n  facet_wrap(zero_replacement ~ type, scales = 'fixed') +\n  geom_abline(color = 'darkgrey') +\n  geom_point()\n\n\n\n\n\n\nres_rank_tidy %>%\n  select(zero_replacement:.otu, p.value) %>%\n  pivot_wider(names_from = test, values_from = p.value) %>%\n  ggplot(aes(wilcox, lm)) +\n  scale_x_sqrt() +\n  scale_y_sqrt() +\n  coord_fixed() +\n  facet_wrap(zero_replacement ~ type, scales = 'fixed') +\n  geom_abline(color = 'darkgrey') +\n  geom_point()\n\n\n\n\nSee good agreement except at extremely low p values, which we have here due to the very large sample size.\nPlot the confidence intervals for the lm test, for the three zero-replacement strategies. Sort taxa by ‘max’ effectively sorts based on the ‘Observed’ value, which does not depend on the zero-replacement strategy.\n\n\nres_rank_tidy %>%\n  filter(test == 'lm') %>%\n  mutate(\n    .otu_fct = fct_reorder(.otu, estimate, .fun = max) %>%\n      fct_relabel(function(x) str_replace_all(x, '_', ' '))\n  ) %>%\n  ggplot(aes(y = .otu_fct, x = estimate, color = type)) +\n  facet_wrap(~zero_replacement, ncol = 1) +\n  colorblindr::scale_color_OkabeIto() +\n  geom_vline(xintercept = 0, color = 'grey') +\n  geom_linerange(size = 1,\n    aes(\n      xmin = estimate - 2*std.error,\n      xmax = estimate + 2*std.error\n    )) +\n  geom_point(size = 1.5) +\n  labs(y = 'Species-level OTU', x = 'Change in rank quantile', color = 'Meas. type')\n\n\n\n\nThe outcome is as expected - there is a large difference in the effect of calibration depending on whether zero-replacement is used, with a much smaller difference between the two replacement strategies. In particular, there is very little effect of calibration when zeros are left as zeros, and a fairly dramatic effect when zeros are set to small positive values. Even without zero replacement, however, we see substantial inferential differences for Ureaplasma_cluster23, Corynebacterium_cluster45, and Lactobacillus_gasseri_cluster.\nLet’s confirm that the Wilcoxon and lm p-values agree for these taxa,\n\n\nres_rank_tidy %>%\n  filter(zero_replacement == 'None',\n    .otu %in% c('Ureaplasma_cluster23', 'Corynebacterium_cluster45',\n      'Lactobacillus_gasseri_cluster'),\n    ) %>%\n  select(type, test, .otu, p.value) %>%\n  pivot_wider(names_from = test, values_from = p.value)\n\n\n# A tibble: 6 × 4\n  type       .otu                           wilcox      lm\n  <chr>      <chr>                           <dbl>   <dbl>\n1 Observed   Corynebacterium_cluster45     0.00245 0.00242\n2 Observed   Lactobacillus_gasseri_cluster 0.984   0.984  \n3 Observed   Ureaplasma_cluster23          0.00200 0.00197\n4 Calibrated Corynebacterium_cluster45     0.106   0.106  \n5 Calibrated Lactobacillus_gasseri_cluster 0.117   0.117  \n6 Calibrated Ureaplasma_cluster23          0.307   0.307  \n\nWhy does calibration have a big effect on the estimates when zeros are first replaced with positive values? There is a relatively straightforward explanation that should make us cautious about interpretting the big effect of calibration too literally. Recall that there is a systematic change in the mean efficiency across groups. Consider a taxon with a lot of zero values (which is essentially all of them). After zero replacement, all of the zeros are set to the same positive proportion, which will be the smallest possible for that taxon. Without calibration, these samples will receive the same rank (ties are resolved to the average rank, so the rank will be the number of zeros divided by 2). But with calibration, they will all have different proportions, given by the common value multiplied by the efficiency relative to the sample mean efficiency, and and hence will follow the inverse variation in mean efficiency. The mean efficiency systematically varies (lower in high-diversity samples), and so the ranks from the previously-zero entries will be lower in the high-diversity samples. So the systematic shift in the mean efficiency leads in a rather direct way to a systematic difference in the ranks of these previously-zero entries, where the ranks are lower in the high-diversity group. If there are a lot of zeros, this effect will be large and could create a big shift towards lower estimates.\nThe same thing should be occuring in the analysis of log proportions using lm() above—the same argument applies, but with the log instead of the rank transform being applied.\nWe be cautious about taking the big effect of calibration as a sign that bias has a big effect on the original results. We have a lot of uncertainty about what the ‘observed’ proportions should be in each sample with a zero (or near-zero) value. If we consider two samples, where the mean efficiency differs by 10X, and the taxon was a zero, then the deterministic zero imputation will say with certainty that (after calibration) the taxon is lower by 10X in the sample with the higher mean efficiency. But if we have uncertainty greater than 10X in the pre-calibration proportion, we’ll have uncertainty after calibration about which sample has the higher value, perhaps to nearly the maximum amount (of a coin flip). I suspect that an analysis that accounts for this uncertainty would find a smaller expected impact of calibration.\nWhy does calibration typically have a minor impact when zeros are not replaced? My leading hypothesis is that the answer has to do with the multimodal distribution of (log) proportions of most taxa. Many of these taxa are completely absent (zero) in a large fraction of samples. Let’s consider a taxon that is zero or has a large proportion, and is zero in a substantial fraction (say over 20%) of samples. I suspect that for these taxa the average-rank differences are being driven by differential prevalence (fraction of non-zero samples). Differential prevalence is not affected by calibration when we do not replace zeros.\nOther taxa may have multiple modes, such as zero, small positive proportion, and large positive proportion; others might be generally present but with small and large modes. I suspect we could get a similar non-impact of calibration in this latter case, which would not depend on zero replacement.\nIntuition check: Confirm that the mean efficiency doesn’t depend on the zero-replacement strategy.\n\n\nadd_mean <- function(x, bias) {\n  sample_data(x)$mean_efficiency <- x %>%\n    transform_sample_counts(close_elts) %>%\n    perturb(bias, norm = 'none') %>% \n    sample_sums\n  x\n}\n\nx <- ps_set %>%\n  filter(type == 'Calibrated') %>%\n  mutate(\n    across(ps, map, sample_data),\n    across(ps, map, as_tibble),\n  ) %>%\n  unnest(ps) %>%\n  pivot_wider(names_from = zero_replacement, values_from = .mean_efficiency)\n\n\n\n\n\n\n\n\nx %>%\n  select(None, `Strategy 1`, `Strategy 2`) %>%\n  mutate(across(everything(), log10)) %>%\n  cor\n\n\n                None Strategy 1 Strategy 2\nNone       1.0000000  0.9999691  0.9998998\nStrategy 1 0.9999691  1.0000000  0.9999802\nStrategy 2 0.9998998  0.9999802  1.0000000\n\nAs expected, the mean efficiency is unaffected by zero replacement.\nGamma-Poisson regression\nI will try a third approach that circumvents the need for zero replacement. Count-based GLMs naturally account for the uncertainty associated with small or zero count observations. Gamma-Poisson (or negative binomial) regression with a suitably-chosen offset provides a count-based GLM where the response of the latent linear model is the log proportion. Thus we can use it to analyze the effect of sample condition on the average log proportion, treating log proportion as a truly continuous, always positive variable, while fitting the model to the discrete counts (including zeros).\nFor the final regression analysis, we might consider skipping the rarefy step, which is not needed when doing GP regression.\nI’ll use the rstanarm package to do the regression. See https://mc-stan.org/rstanarm/reference/neg_binomial_2.html and https://mc-stan.org/docs/2_20/functions-reference/nbalt.html for information about the function and model used.\n\n\nlibrary(rstanarm)\noptions(mc.cores = parallel::detectCores())\n\n\n\nSince we have subsampled to a constant 10K reads in all samples, the offset for the ‘Observed’ case is constant, and rstanarm will throw an error if we use a constant offset. Therefore we will not use an offset in this case, but rather adjust the prior mean on the intercept to account for the offset due to read depth. Let’s check the (geometric) mean abundances across taxa to make sure they fall within this prior,\n\n\nmomspi_div %>%\n  prune_taxa(taxa_to_test, .) %>%\n  as_tibble %>%\n  with_groups(.otu, summarize, across(.abundance, ~gm_mean(. + 0.3))) %>%\n  pull(.abundance) %>%\n  summary\n\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n  0.7003   1.3852   2.4277  14.6015   3.5487 301.6883 \n\nI will set the mean to log(20) = 3, or a geometric-mean on the count scale of 20 corresponding, to a proportion of 0.002, and set the scale to 3. Then the central 66% interval will span from counts of around 1 to 400. Since we have a larger number of samples, the prior should not have a very large effect on the posterior as long as it is fairly wide.\n\n\ntbl_gp <- momspi_div %>%\n  prune_taxa(taxa_to_test, .) %>%\n  as_tibble %>%\n  left_join(bias %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  with_groups(.otu, nest)\ncustom_prior_intercept <- normal(location = log(20), scale = 3)\n\n\n\n\n\n\n\n\nres_gp <- xfun::cache_rds({\n  tbl_gp %>%\n    mutate(\n      Observed = map(data, \n        ~stan_glm(data = .x, \n          .abundance ~ div_group,\n          prior_intercept = custom_prior_intercept,\n          family = neg_binomial_2, seed = 42, algorithm = 'sampling'\n        )\n      ),\n      Calibrated = map(data, \n        ~stan_glm(data = .x, \n          .abundance ~ div_group + offset(log(efficiency/mean_efficiency)),\n          prior_intercept = custom_prior_intercept,\n          family = neg_binomial_2, seed = 42, algorithm = 'sampling'\n        )\n      ),\n    ) %>%\n    select(-data) %>%\n    pivot_longer(c(Observed, Calibrated), names_to = 'type', values_to = 'fit')\n}, dir = '_cache/', file = 'res_gp', \nhash = list(tbl_gp, custom_prior_intercept))\n\nres_gp_tidy <- res_gp %>%\n  mutate(across(fit, map, broom.mixed::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\nplot_estimates(res_gp_tidy)\n\n\n\n\nLet’s compare the impact of calibration on the slope point estimates to the LFC in the mean efficiency,\n\n\ndiffs <- res_gp_tidy %>%\n  pivot_wider(names_from = type, values_from = c(estimate, std.error)) %>%\n  # pivot_wider(names_from = type, values_from = estimate) %>%\n  mutate(difference = estimate_Calibrated - estimate_Observed)\n\ndiffs %>% pull(difference) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n -1.830  -1.417  -1.198  -1.207  -1.132  -0.202 \n\n\n\ndiffs %>%\n  ggplot(aes(difference)) +\n  geom_dots() +\n  geom_vline(xintercept = mean_eff_lfc) +\n  expand_limits(x = 0)\n\n\n\n\nThe mode is negative aligns with the negative LFC of the mean efficiency. But 2 to 4 taxa have substantially less negative differences, and two taxa (Gardnerella_vaginalis and Lachnospiraceae_BVAB1) have positive differences.\nSanity checks\nOffsets with lm()\nCheck that using offsets gives us the same result as using calibrated profiles. Note, I’m updating the mean efficiency and sample sums after adding the pseudocounts. This should tend to push the mean efficiency torwards more moderate values and so may reduce the differene between groups.\n\n\nres_lm_offset <- momspi_div %>%\n  transform_sample_counts(~. + 0.5) %>%\n  mutate_sample_data(., \n    mean_efficiency = mean_efficiency(., bias, type = 'observed'),\n    sample_sum = sample_sums(.)\n  ) %>%\n  #> prune_taxa(taxa_to_test, .) %>%\n  as_tibble %>%\n  left_join(bias %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  with_groups(.sample, mutate, \n    prop = close_elts(.abundance),\n    prop_cal = close_elts(.abundance / efficiency),\n  ) %>%\n  filter(.otu %in% taxa_to_test) %>%\n  with_groups(.otu, nest) %>%\n  mutate(\n    Observed = map(data, \n      ~lm(data = .x, log(prop) ~ div_group)\n    ),\n    Calibrated = map(data, \n      ~lm(data = .x, log(prop_cal) ~ div_group)\n    ),\n    Observed_offset = map(data, \n      ~lm(data = .x, log(.abundance) ~ div_group + offset(log(sample_sum)))\n    ),\n    Calibrated_offset = map(data, \n      ~lm(data = .x, \n        log(.abundance) ~ div_group + offset(log(sample_sum * efficiency /\n            mean_efficiency)),\n      )\n    ),\n  )\nres_lm_offset_tidy <- res_lm_offset %>%\n  select(-data) %>%\n  pivot_longer(c(starts_with('Observed'), starts_with('Calibrated')), \n    names_to = 'type', values_to = 'fit') %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\n\n\n\nres_lm_offset_tidy %>%\n  select(.otu, type, estimate) %>%\n  pivot_wider(names_from = type, values_from = estimate) %>%\n  as_matrix(rownames = .otu) %>%\n  cor\n\n\n                  Observed Observed_offset Calibrated\nObserved                 1               1          1\nObserved_offset          1               1          1\nCalibrated               1               1          1\nCalibrated_offset        1               1          1\n                  Calibrated_offset\nObserved                          1\nObserved_offset                   1\nCalibrated                        1\nCalibrated_offset                 1\n\nZeros with lm()\nSee what happens if use pseudocounts after calibration, instead of before.\n\n\nstat_test <- function(ps, taxa) {\n  ps %>%\n    filter_sample_data(div_group %in% c('Low', 'High')) %>%\n    transform_sample_counts(close_elts) %>%\n    prune_taxa(taxa, .) %>%\n    as_tibble %>%\n    with_groups(.otu, nest) %>%\n    mutate(\n      fit = map(data,\n        ~lm(log(.abundance) ~ div_group, data = .x)\n      ),\n    ) %>%\n    select(-data)\n}\nres_lm_after <- list(\n  'Observed' = momspi_div,\n  'Calibrated' = momspi_div %>% calibrate(bias, norm = 'keep')\n) %>%\n  map(transform_sample_counts, ~. + 0.5) %>%\n  map_dfr(stat_test, taxa = taxa_to_test, .id = 'type')\nres_lm_after_tidy <- res_lm_after %>%\n  mutate(across(fit, map, broom::tidy)) %>%\n  unnest(fit) %>% \n  filter(term != '(Intercept)')\n\n\n\n\n\nplot_estimates(res_lm_after_tidy)\n\n\n\n\nAs expected, see smaller effects of calibration for many taxa. Interesting to see that some taxa, including L iners and Ureaplasma, where there remains a large effect. It remains that the calibrated estimates are always lower; I guess that it remains a mathematical fact that the directional change must be the same for all taxa.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-02-03\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.6-1      2022-01-07 [1] CRAN (R 4.1.2)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)\n bayesplot          1.8.1      2021-06-14 [1] CRAN (R 4.1.0)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.2     2021-08-05 [1] Bioconductor\n bit                4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64              4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n bookdown           0.24       2021-09-02 [1] CRAN (R 4.1.1)\n boot               1.3-28     2021-05-03 [2] CRAN (R 4.1.2)\n broom              0.7.11     2022-01-03 [1] CRAN (R 4.1.2)\n broom.mixed        0.2.7      2021-07-07 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n Cairo              1.5-14     2021-12-21 [1] CRAN (R 4.1.2)\n callr              3.7.0      2021-04-20 [1] CRAN (R 4.1.0)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.1      2022-01-20 [1] CRAN (R 4.1.2)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorblindr        0.1.0      2021-08-27 [1] Github (clauswilke/colorblindr@e6730be)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n colourpicker       1.1.1      2021-10-04 [1] CRAN (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n crosstalk          1.2.0      2021-11-04 [1] CRAN (R 4.1.2)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.2      2021-12-20 [1] CRAN (R 4.1.2)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional     0.3.0      2022-01-05 [1] CRAN (R 4.1.2)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n DT                 0.20       2021-11-15 [1] CRAN (R 4.1.2)\n dygraphs           1.1.1.6    2018-07-11 [1] CRAN (R 4.0.2)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              1.0.2      2022-01-14 [1] CRAN (R 4.1.2)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs               * 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.4     2021-09-05 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist           * 3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggforce          * 0.3.3      2021-03-05 [1] CRAN (R 4.0.4)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n ggrastr            1.0.1      2021-12-08 [1] CRAN (R 4.1.2)\n ggridges           0.5.3      2021-01-08 [1] CRAN (R 4.0.4)\n glue               1.6.1      2022-01-22 [1] CRAN (R 4.1.2)\n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n gtools             3.9.2      2021-06-06 [1] CRAN (R 4.1.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here             * 1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n htmlwidgets        1.5.4      2021-09-08 [1] CRAN (R 4.1.1)\n httpuv             1.6.5      2022-01-05 [1] CRAN (R 4.1.2)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.11     2022-01-04 [1] CRAN (R 4.1.2)\n inline             0.3.19     2021-05-31 [1] CRAN (R 4.1.0)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.3      2022-01-17 [1] CRAN (R 4.1.2)\n knitr              1.37       2021-12-16 [1] CRAN (R 4.1.2)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n later              1.3.0      2021-08-18 [1] CRAN (R 4.1.1)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lme4               1.1-27.1   2021-06-22 [1] CRAN (R 4.1.0)\n loo                2.4.1      2020-12-09 [1] CRAN (R 4.0.3)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.2      2022-01-26 [1] CRAN (R 4.1.2)\n markdown           1.1        2019-08-07 [1] CRAN (R 4.0.0)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n matrixStats        0.61.0     2021-09-17 [1] CRAN (R 4.1.1)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9009 2022-01-30 [1] Github (mikemc/metacal@5154eeb)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n mime               0.12       2021-09-28 [1] CRAN (R 4.1.1)\n miniUI             0.1.1.1    2018-05-18 [1] CRAN (R 4.0.2)\n minqa              1.2.4      2014-10-09 [1] CRAN (R 4.0.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nloptr             1.2.2.3    2021-11-02 [1] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.5      2022-01-25 [1] CRAN (R 4.1.2)\n pkgbuild           1.3.1      2021-12-20 [1] CRAN (R 4.1.2)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n polyclip           1.10-0     2019-03-14 [1] CRAN (R 4.0.0)\n prettyunits        1.1.1      2020-01-24 [1] CRAN (R 4.0.0)\n processx           3.5.2      2021-04-30 [1] CRAN (R 4.1.0)\n promises           1.2.0.1    2021-02-11 [1] CRAN (R 4.0.4)\n ps                 1.6.0      2021-02-28 [1] CRAN (R 4.0.4)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp             * 1.0.8      2022-01-13 [1] CRAN (R 4.1.2)\n RcppParallel       5.1.5      2022-01-05 [1] CRAN (R 4.1.2)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              1.0.0      2022-01-26 [1] CRAN (R 4.1.2)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rsconnect          0.8.25     2021-11-19 [1] CRAN (R 4.1.2)\n rstan              2.21.3     2021-12-19 [1] CRAN (R 4.1.2)\n rstanarm         * 2.21.1     2020-07-20 [1] CRAN (R 4.0.2)\n rstantools         2.1.1      2020-07-06 [1] CRAN (R 4.0.2)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.2     2021-10-03 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n shiny              1.7.1      2021-10-02 [1] CRAN (R 4.1.1)\n shinyjs            2.1.0      2021-12-23 [1] CRAN (R 4.1.2)\n shinystan          2.5.0      2018-05-01 [1] CRAN (R 4.0.2)\n shinythemes        1.2.0      2021-01-25 [1] CRAN (R 4.0.4)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n StanHeaders        2.21.0-7   2020-12-17 [1] CRAN (R 4.0.3)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n threejs            0.3.3      2020-01-21 [1] CRAN (R 4.0.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n tweenr             1.0.2      2021-03-23 [1] CRAN (R 4.0.5)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom              1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.29       2021-12-14 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n xtable             1.8-4      2019-04-21 [1] CRAN (R 4.0.0)\n xts                0.12.1     2020-09-09 [1] CRAN (R 4.0.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.2      2022-01-25 [1] CRAN (R 4.1.2)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n zoo                1.8-9      2021-03-09 [1] CRAN (R 4.0.5)\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────────\n\n\n\n\n",
    "preview": "posts/2021-12-15-momspi-regression-diversity/momspi-regression-diversity_files/figure-html5/unnamed-chunk-7-1.svg",
    "last_modified": "2022-02-06T08:44:22-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-11-01-momspi-summary/",
    "title": "MOMS-PI: Key dynamics",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-11-01",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\n\nContents\nSetup\nR setup\nEstimate bias from Brooks et al. (2015)\nLoad the MOMSPI data\nChecks\n\nCalibrate the MOMSPI measurements\nObserved and calibrated proportions\nSample summary statistics\n\nVisual analysis of mean efficiency distribution and role of key species\nVariation in mean efficiency and individual species\nFold changes in mean efficiency\nExample community trajectory\nSession info\n\nThis document is part of a series of analyses of the impact of taxonomic bias on vaginal community dynamics in MOMSPI dataset (Fettweis et al. (2019)), using the bias estimated from the Brooks et al. (2015) mock community data. The purpose of this document is to demonstrate the key dynamics we want to highlight in the manuscript.\nSetup\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9008'\n\n\n\ntheme_set(theme_cowplot())\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nEstimate bias from Brooks et al. (2015)\nWe can estimate the efficiencies for the control species used in the cellular mocks of Brooks et al. (2015) by running the example code in the docs for metacal::estimate_bias(). This code uses the observed and actual species-level abundance tables which were produced by McLaren, Willis, and Callahan (2019) from the SI files of Brooks et al. (2015) and are included in the metacal package.\n\n\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  as(\"matrix\")\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  as(\"matrix\")\n\n# Estimate bias with bootstrapping for error estimation\nmc_fit <- estimate_bias(observed, actual, margin = 1, boot = TRUE)\nsummary(mc_fit)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 7 × 4\n  taxon                    estimate gm_mean gm_se\n  <chr>                       <dbl>   <dbl> <dbl>\n1 Atopobium_vaginae           0.285   0.285  1.04\n2 Gardnerella_vaginalis       0.160   0.159  1.05\n3 Lactobacillus_crispatus     2.29    2.29   1.03\n4 Lactobacillus_iners         4.68    4.69   1.02\n5 Prevotella_bivia            1.79    1.79   1.04\n6 Sneathia_amnii              4.59    4.60   1.04\n7 Streptococcus_agalactiae    0.250   0.250  1.03\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\nrm(actual, observed, dr)\n\n\n\n\n\ncontrol_species <- mc_fit %>% coef %>% names\ncontrol_genera <- control_species %>% str_extract('^[^_]+')\n\n\n\nLoad the MOMSPI data\nTODO: replace this code chunk with one that pulls data from the github repo into _data/\nLoad the MOMSPI Stirrups profiles into phyloseq\n\n\npath_momspi <- '~/research/momspi'\n\notu <- path(path_momspi, \"output\", \"stirrups-profiles\", \"abundance-matrix.csv.bz2\") %>%\n  read_csv(\n    col_types = cols(.default = col_double(), sample_name = col_character())\n  ) %>%\n  otu_table(taxa_are_rows = FALSE)\nsam <- path(path_momspi, \"output\", \"stirrups-profiles\", \"sample-data.csv.bz2\") %>%\n  read_csv(col_types = \"ccccccic\") %>%\n  mutate(across(host_visit_number, factor, ordered = TRUE)) %>%\n  sample_data\ntax <- path(path_momspi, \"output\", \"stirrups-profiles\", \"taxonomy.csv.bz2\") %>%\n  read_csv(col_types = cols(.default = col_character())) %>%\n  tax_table %>%\n  mutate_tax_table(\n    species = case_when(!is.na(genus) ~ .otu)\n  )\nmomspi_raw <- phyloseq(otu, sam, tax) %>%\n  mutate_tax_table(across(.otu, str_replace, \n      \"(?<=Lactobacillus_crispatus)_cluster\", \"\")) %>%\n  mutate_sample_data(., sample_sum = sample_sums(.))\ntaxa_names(momspi_raw) %>% str_subset(\"crispatus\")\n\n\n[1] \"Lactobacillus_crispatus\"       \"Lactobacillus_crispatus_type1\"\n\nstopifnot(all(control_species %in% taxa_names(momspi_raw)))\n\n\n\nL crisp type 1 is just a few reads so we can ignore it (check)\n\n\np1 <- momspi_raw %>% sample_sums %>% qplot + scale_x_log10() +\n  labs(x = 'sample sum')\np2 <- momspi_raw %>% taxa_sums %>% qplot + scale_x_log10() +\n  labs(x = 'otu sum')\np1 + p2\n\n\n\n\nLet’s filter samples with fewer than 1000 reads (also requirement used by the authors)\n\n\nmomspi <- momspi_raw %>% \n  filter_sample_data(sample_sum >= 1e3)\n\n\n\nNote, we might want to be conservative in terms of composition shifts by making the min prop of species 1e-3. However this might add up to a large effect if we apply it to all species. Could instead filter to 1e4 reads and threshold at 1e-4, or 3e-4\nLet’s see if we can filter the super-low-count species without affecting any remaining samples too much:\n\n\nx <- (momspi %>% filter_taxa2(~sum(.) >= 2e2) %>% sample_sums) / (momspi %>% sample_sums)\nsummary(x)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.99    1.00    1.00    1.00    1.00    1.00 \n\nDropping OTUs with less than 200 reads has a negligible impact on the samples, so let’s do that.\n\n\nmomspi <- momspi %>% filter_taxa2(~sum(.) >= 2e2)\n\n\n\nFinally, let’s impute zeros using the Dirichlet posterior mean, with the prior respecting the average proportions across samples.\n\n\ntaxa_mean_prop <- momspi %>%\n  otu_table %>%\n  transform_sample_counts(close_elts) %>%\n  orient_taxa(as = 'cols') %>%\n  as('matrix') %>%\n  colMeans\nstopifnot(sum(taxa_mean_prop) == 1)\nprior_vec <- taxa_mean_prop * ntaxa(momspi)\nstopifnot(identical(length(prior_vec), ntaxa(momspi)))\n# Note the need for the seq_along trick to get phyloseq to allow this\n# adjustment\nmomspi <- momspi %>% transform_sample_counts(~ prior_vec[seq_along(.x)] + .x)\n\n\n\nChecks\nhow many subjects?\n\n\ncts <- momspi %>% sample_data %>% as_tibble %>% count(host_subject_id)\nnrow(cts)\n\n\n[1] 577\n\nhow does the number of visits vary by subject?\n\n\ncts %>% pull(n) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    2.00    3.00    3.39    4.00    9.00 \n\ncts %>%\n  ggplot(aes(x = n)) +\n  geom_histogram(binwidth = 1)\n\n\n\n\nCalibrate the MOMSPI measurements\nOwing to the large sample size of the mock community experiment, the standard errors in the estimated bias for the control species are quite small, and our uncertainty in the true bias of the MOMSPI study is much larger than what these standard errors imply. Therefore I will use the point estimate of the bias for the control species as if it were known exactly, but we should consider this to just be a hypothesis of what the bias truly is in the MOMSPI study. This hypothetical nature applies even more strongly when we extrapolate to other species.\nSince don’t have a way to directly estimate the efficiencies of the other OTUs, we’ll impute them as follows.\nSet the efficiencies of the 7 control species to the directly estimated values\nCompute efficiencies for the 6 control genera to the efficiency of the control species (if only one) or the geometric mean efficiency (if more than one; here this is just Lactobacillus)\nUse these genera-level efficiencies for the efficiencies of OTUs that are not control species but are in the same genus as one\nFor other OTUs, use the geometric mean of the genera efficiencies; this is similar to using the mean of the 7 control species but gives Lactobacillus equal weight to the other genera.\n\n\nbias_species <- coef(mc_fit) %>% \n  enframe(\"species\", \"efficiency\") %>%\n  print\n\n\n# A tibble: 7 × 2\n  species                  efficiency\n  <chr>                         <dbl>\n1 Atopobium_vaginae             0.285\n2 Gardnerella_vaginalis         0.160\n3 Lactobacillus_crispatus       2.29 \n4 Lactobacillus_iners           4.68 \n5 Prevotella_bivia              1.79 \n6 Sneathia_amnii                4.59 \n7 Streptococcus_agalactiae      0.250\n\nbias_genus <- bias_species %>%\n  mutate(genus = str_extract(species, \"^[^_]+\"), .before = 1) %>%\n  with_groups(genus, summarize, across(efficiency, gm_mean)) %>%\n  print\n\n\n# A tibble: 6 × 2\n  genus         efficiency\n  <chr>              <dbl>\n1 Atopobium          0.285\n2 Gardnerella        0.160\n3 Lactobacillus      3.27 \n4 Prevotella         1.79 \n5 Sneathia           4.59 \n6 Streptococcus      0.250\n\n# Match on genus or species, depending on which is available; then set others\n# to average genus efficiency\nbias_all <- tax_table(momspi) %>% as_tibble %>%\n  left_join(bias_species, by = \"species\") %>%\n  left_join(bias_genus, by = \"genus\") %>%\n  mutate(\n    efficiency = case_when(\n      !is.na(efficiency.x) ~ efficiency.x,\n      !is.na(efficiency.y) ~ efficiency.y,\n      TRUE ~ gm_mean(bias_genus$efficiency)\n    )\n  ) %>%\n  select(-efficiency.x, -efficiency.y) %>%\n  # standardize to L. iners, the most efficiently measured\n  mutate(\n    across(efficiency, ~ . / max(.))\n  ) %>%\n  glimpse\n\n\nRows: 282\nColumns: 10\n$ .otu       <chr> \"Clostridiaceae_1_OTU17\", \"Lachnospiraceae_BVAB1\"…\n$ domain     <chr> NA, NA, NA, NA, NA, NA, \"Bacteria\", \"Bacteria\", \"…\n$ phylum     <chr> NA, NA, NA, NA, NA, NA, \"Firmicutes\", \"Firmicutes…\n$ class      <chr> NA, NA, NA, NA, NA, NA, \"Bacilli\", \"Clostridia\", …\n$ order      <chr> NA, NA, NA, NA, NA, NA, \"Lactobacillales\", \"Clost…\n$ family     <chr> NA, NA, NA, NA, NA, NA, \"Aerococcaceae\", \"Veillon…\n$ genus      <chr> NA, NA, NA, NA, NA, NA, \"Abiotrophia\", \"Acidamino…\n$ control    <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ species    <chr> NA, NA, NA, NA, NA, NA, \"Abiotrophia_defectiva\", …\n$ efficiency <dbl> 0.175212, 0.175212, 0.175212, 0.175212, 0.175212,…\n\nbias_all_vec <- bias_all %>% select(.otu, efficiency) %>% deframe \n\n\n\nObserved and calibrated proportions\nCompute observed and calibrated proportions with all taxa.\n\n\nmomspi_obs <- momspi %>% \n  transform_sample_counts(close_elts)\n# note, calibrate() automatically subsets to just the focal taxa if we haven't\n# already\nmomspi_cal <- momspi_obs %>% calibrate(bias_all_vec)\n\n\n\nSample summary statistics\nMean efficiencies\nMost abundant species\nProportion of Lactobacillus \nTo compute the mean efficiencies, we can use metacal::perturb() to multiply efficiencies by the actual proportions for each sample (using norm = \"none\" to avoid renormalizing the results), then summing up the values from each sample with phyloseq::sample_sums(). It’s also useful to get the mean efficiency among just the control species.\n\n\ntmp1 <- momspi_cal %>%\n  perturb(bias_all_vec, norm = \"none\") %>% \n  sample_sums %>%\n  enframe('.sample', 'mean_efficiency')\ntmp2 <- momspi_cal %>%\n  filter_tax_table(.otu %in% control_species) %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(bias_species %>% deframe, norm = \"none\") %>% \n  sample_sums %>%\n  enframe('.sample', 'mean_efficiency_controls')\nmean_eff <- left_join(tmp1, tmp2, by = '.sample')\n\n\n\nFor each sample, let’s get the most abundant species in the calibrated and uncalibrated profiles.\n\n\nget_top_species <- function(ps) {\n  x <- ps %>%\n    otu_table %>%\n    as_tibble(pivot = TRUE) %>%\n    with_groups(.sample, slice_max, .abundance, n = 1) %>%\n    # add count to check for ties\n    add_count(.sample)\n  if (anyDuplicated(x$.sample))\n    stop('Ties present')\n  x %>% select(.sample, .otu, .abundance)\n}\ntop_species <- list(\n  Uncalibrated = momspi_obs,\n  Calibrated = momspi_cal\n  ) %>%\n  map_dfr(get_top_species, .id = 'type')\n\n\n\nWhich species tend to be dominant?\n\n\ntop_species %>%\n  filter(type == 'Uncalibrated') %>%\n  count(.otu) %>%\n  arrange(desc(n)) %>%\n  print(n=20)\n\n\n# A tibble: 53 × 2\n   .otu                                     n\n   <chr>                                <int>\n 1 Lactobacillus_iners                    779\n 2 Lactobacillus_crispatus                425\n 3 Lachnospiraceae_BVAB1                  238\n 4 Gardnerella_vaginalis                  137\n 5 Lactobacillus_gasseri_cluster           68\n 6 Prevotella_cluster2                     53\n 7 Atopobium_vaginae                       52\n 8 Lactobacillus_jensenii                  50\n 9 Sneathia_amnii                          23\n10 Prevotella_bivia                        16\n11 Streptococcus_cluster29                 16\n12 Mycoplasma_girerdii                     11\n13 Mycoplasma_hominis                       6\n14 Corynebacterium_cluster58                5\n15 Lactobacillus_delbrueckii                5\n16 Bifidobacterium_longum_infantis_suis     4\n17 Finegoldia_magna                         4\n18 Prevotella_disiens                       4\n19 Staphylococcus_cluster47                 4\n20 Streptococcus_agalactiae                 4\n# … with 33 more rows\n\n\n\ntop_species %>%\n  filter(type == 'Calibrated') %>%\n  count(.otu) %>%\n  arrange(desc(n)) %>%\n  print(n=20)\n\n\n# A tibble: 60 × 2\n   .otu                              n\n   <chr>                         <int>\n 1 Gardnerella_vaginalis           525\n 2 Lactobacillus_iners             491\n 3 Lactobacillus_crispatus         386\n 4 Lachnospiraceae_BVAB1           183\n 5 Atopobium_vaginae                63\n 6 Lactobacillus_jensenii           51\n 7 Lactobacillus_gasseri_cluster    45\n 8 Streptococcus_cluster29          28\n 9 Streptococcus_anginosus          20\n10 Prevotella_cluster2              16\n11 Mycoplasma_girerdii              15\n12 Streptococcus_agalactiae         11\n13 Finegoldia_magna                  9\n14 Ureaplasma_cluster23              9\n15 Corynebacterium_cluster58         7\n16 Mycoplasma_hominis                7\n17 Clostridiales_OTU22               5\n18 Lactobacillus_delbrueckii         5\n19 Prevotella_bivia                  5\n20 Anaerococcus_OTU147               4\n# … with 40 more rows\n\nThe most important species/OTU that we do not have direct bias information on at the species or genus level is Lachnospiraceae BVAB1.\nThe proportion of Lactobacillus in each sample - will simply do all control genera.\n\n\ngenus_prop <- momspi_cal %>%\n  subset_taxa(genus %in% control_genera) %>%\n  tax_glom('genus') %>%\n  as_tibble %>%\n  select(.sample, genus, .abundance) %>%\n  pivot_wider(names_from = genus, values_from = .abundance)\n\n\n\nLet’s join the most abundant species and key genera proportions to the mean efficiecies for further analysis. For plotting, we’ll create a version of the top taxa that only colors the taxa that are most often dominant.\n\n\ntmp <- top_species %>% \n  select(-.abundance) %>% \n  pivot_wider(names_from = type, values_from = .otu, \n    names_glue = 'top_{str_to_lower(type)}')\nmean_eff1 <- mean_eff %>%\n  left_join(sample_data(momspi_cal) %>% as_tibble, by = '.sample') %>%\n  left_join(genus_prop, by = '.sample') %>%\n  left_join(tmp, by = '.sample') %>%\n  mutate(\n    top_plot = fct_lump_n(top_calibrated, 7)\n  )\nrm(tmp)\n\n\n\nVisual analysis of mean efficiency distribution and role of key species\nWe can make a plot similar to that used for the Leopold et al analysis.\n\n\n# First let's look at the distribution of mean efficiencies\np1 <- mean_eff1 %>%\n  ggplot(aes(mean_efficiency, fill = top_plot)) +\n  geom_histogram() +\n  # annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  expand_limits(x = range(bias_all_vec)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = 'Most abundant species'\n  )\n# Next let's plot Lactobacillus proportion against mean efficiency, as another\n  # look at the relationship between Lacto and mean efficiency.\np2 <- mean_eff1 %>%\n  ggplot(aes(mean_efficiency, Lactobacillus, color = top_plot)) +\n  geom_point() +\n  scale_x_log10() +\n  expand_limits(x = range(bias_all_vec)) +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.03, 0.1, 0.3, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Lactobacillus proportion\",\n    x = \"Mean efficiency\",\n    color = 'Most abundant species'\n  )\n\n\n\n\n\n# The yellow makes the L crispatus points a bit hard to see, so let's swap it's\n# color with the rarer L. gasseri in the final figure.\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \n(p1 + ggtitle(\"Distribution of sample mean efficiencies\")) / \n  (p2 + \n    ggtitle(\"Lactobacillus proportion vs. mean efficiency\") + \n    theme(legend.position = 'none')\n  ) +\n  plot_annotation(tag_levels = \"A\") +\n  plot_layout(guides = 'collect') &\n  scale_fill_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  ) &\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n# The x-axis is very close but not completely aligned; I think I need to\n# manually set the x limits to get perfect alignment, but that leads to some\n# samples being dropped in the histogram plot; some investigation is needed\n# to go that route.\n\n\n\nThis plot shows that Lactobacillus dominance drives a bimodal distribution in the mean efficiencies, and that Gardnerella dominance drives the low end. Note that the ‘other’ and ‘BVAB1’ dominated samples are lumped around the middle because of our assumption in imputing the efficiencies.\nFor the caption/methods: Note that the most abundant species is that inferred from the calibrated data; could just say that the calibrated data is treated as the actual composition.\nThe Lacto proportion doesn’t seem that much more illuminating than the histogram colored by dominant species, so let’s make a version with just that for the manuscript.\n\n\ncolors_top <- RColorBrewer::brewer.pal(8, 'Accent')[c(1,2,3,5,4,6,7,8)] \np1 + \n#  ggtitle(\"Distribution of sample mean efficiencies\") +\n  scale_fill_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  ) +\n  scale_color_manual(\n    values = colors_top,\n    labels = function(x) str_replace_all(x, '_', ' ')\n  )\n\n\n\n\nVariation in mean efficiency and individual species\n\n\nfocal_taxa <- momspi %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~ mean(. >= 1e-2) >= 0.05 | mean(. >= 1e-3) >= 0.15) %>%\n  taxa_names %>%\n  print\n\n\n [1] \"Lachnospiraceae_BVAB1\"         \"Aerococcus_christensenii\"     \n [3] \"Atopobium_vaginae\"             \"Campylobacter_ureolyticus\"    \n [5] \"Clostridiales_BVAB2\"           \"Coriobacteriaceae_OTU27\"      \n [7] \"Corynebacterium_cluster45\"     \"Dialister_cluster51\"          \n [9] \"Dialister_micraerophilus\"      \"Dialister_propionicifaciens\"  \n[11] \"Finegoldia_magna\"              \"Gardnerella_vaginalis\"        \n[13] \"Lactobacillus_crispatus\"       \"Lactobacillus_gasseri_cluster\"\n[15] \"Lactobacillus_iners\"           \"Lactobacillus_jensenii\"       \n[17] \"Megasphaera_OTU70_type1\"       \"Mycoplasma_hominis\"           \n[19] \"Parvimonas_OTU142\"             \"Peptoniphilus_indolicus\"      \n[21] \"Prevotella_amnii\"              \"Prevotella_bivia\"             \n[23] \"Prevotella_cluster2\"           \"Prevotella_cluster50\"         \n[25] \"Prevotella_disiens\"            \"Sneathia_amnii\"               \n[27] \"Sneathia_sanguinegens\"         \"Staphylococcus_cluster47\"     \n[29] \"TM7_OTU-H1\"                    \"Ureaplasma_cluster23\"         \n\n\n\nx <- momspi_cal %>%\n  transform_sample_counts(close_elts) %>%\n  filter_tax_table(.otu %in% focal_taxa) %>%\n  as_tibble\n\n\n\n\n\ntaxa_summary <- x %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(.otu, summarize,\n    across(.abundance, \n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  )\ntaxa_summary %>% arrange(-mean) %>% print(n=Inf)\n\n\n# A tibble: 30 × 5\n   .otu                            mean median    sd   var\n   <chr>                          <dbl>  <dbl> <dbl> <dbl>\n 1 Gardnerella_vaginalis          -2.81  -2.82  1.90  3.60\n 2 Lactobacillus_iners            -3.85  -3.88  2.72  7.41\n 3 Atopobium_vaginae              -4.77  -5.15  1.97  3.86\n 4 Lachnospiraceae_BVAB1          -5.64  -6.31  2.35  5.54\n 5 Lactobacillus_crispatus        -5.75  -6.85  3.18 10.1 \n 6 Prevotella_cluster2            -6.18  -6.42  2.06  4.24\n 7 Megasphaera_OTU70_type1        -6.57  -7.38  2.35  5.53\n 8 Ureaplasma_cluster23           -7.17  -7.62  2.55  6.50\n 9 Dialister_micraerophilus       -7.39  -7.28  2.00  3.99\n10 Finegoldia_magna               -7.40  -7.64  2.33  5.45\n11 Lactobacillus_jensenii         -7.42  -8.31  2.93  8.59\n12 Dialister_cluster51            -7.65  -7.95  2.10  4.40\n13 Corynebacterium_cluster45      -7.96  -8.08  2.44  5.95\n14 Lactobacillus_gasseri_cluster  -8.01  -8.65  2.60  6.74\n15 Aerococcus_christensenii       -8.11  -8.33  2.14  4.58\n16 Prevotella_bivia               -8.12  -8.46  2.24  5.03\n17 Staphylococcus_cluster47       -8.31  -8.52  2.42  5.88\n18 Peptoniphilus_indolicus        -8.36  -8.72  2.33  5.42\n19 Coriobacteriaceae_OTU27        -8.40  -8.96  2.17  4.71\n20 Mycoplasma_hominis             -8.79  -9.21  2.05  4.21\n21 Clostridiales_BVAB2            -8.86  -9.40  2.10  4.42\n22 Dialister_propionicifaciens    -8.90  -9.30  2.41  5.80\n23 Campylobacter_ureolyticus      -8.91  -9.39  2.34  5.50\n24 TM7_OTU-H1                     -9.02  -9.44  2.13  4.55\n25 Sneathia_amnii                 -9.13  -9.66  2.11  4.45\n26 Prevotella_disiens             -9.23  -9.71  2.27  5.15\n27 Parvimonas_OTU142              -9.32  -9.99  2.27  5.17\n28 Prevotella_amnii               -9.43  -9.92  2.09  4.38\n29 Prevotella_cluster50           -9.82 -10.3   2.18  4.76\n30 Sneathia_sanguinegens         -10.3  -10.8   2.12  4.50\n\n\n\nme_summary <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  summarize(\n    across(mean_efficiency,\n      .fns = c(sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.892 0.796\n\nThe mean efficiency has a smaller dispersion than individual species, but it is of a similar magnitude, so there is still potential for it to have a substantial impact.\nWhat about variation within women?\n\n\ntaxa_summary_within <- x %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(c(.otu, host_subject_id), summarize,\n    across(.abundance,\n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3) %>%\n  with_groups(.otu, summarize,\n    sd_mean = sd(mean),\n    mean_sd = mean(sd)\n  )\ntaxa_summary_within %>% print(n=Inf)\n\n\n# A tibble: 30 × 3\n   .otu                          sd_mean mean_sd\n   <chr>                           <dbl>   <dbl>\n 1 Aerococcus_christensenii         1.67    1.37\n 2 Atopobium_vaginae                1.51    1.23\n 3 Campylobacter_ureolyticus        1.79    1.55\n 4 Clostridiales_BVAB2              1.55    1.39\n 5 Coriobacteriaceae_OTU27          1.67    1.36\n 6 Corynebacterium_cluster45        1.76    1.72\n 7 Dialister_cluster51              1.58    1.42\n 8 Dialister_micraerophilus         1.46    1.43\n 9 Dialister_propionicifaciens      1.83    1.63\n10 Finegoldia_magna                 1.74    1.60\n11 Gardnerella_vaginalis            1.57    1.07\n12 Lachnospiraceae_BVAB1            1.87    1.39\n13 Lactobacillus_crispatus          2.89    1.18\n14 Lactobacillus_gasseri_cluster    2.17    1.33\n15 Lactobacillus_iners              2.25    1.45\n16 Lactobacillus_jensenii           2.47    1.41\n17 Megasphaera_OTU70_type1          1.92    1.32\n18 Mycoplasma_hominis               1.52    1.36\n19 Parvimonas_OTU142                1.69    1.48\n20 Peptoniphilus_indolicus          1.71    1.67\n21 Prevotella_amnii                 1.48    1.40\n22 Prevotella_bivia                 1.57    1.63\n23 Prevotella_cluster2              1.48    1.47\n24 Prevotella_cluster50             1.60    1.53\n25 Prevotella_disiens               1.67    1.58\n26 Sneathia_amnii                   1.56    1.36\n27 Sneathia_sanguinegens            1.58    1.39\n28 Staphylococcus_cluster47         1.76    1.71\n29 TM7_OTU-H1                       1.63    1.29\n30 Ureaplasma_cluster23             1.97    1.57\n\n\n\nme_summary_within <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  with_groups(host_subject_id, summarize,\n    across(mean_efficiency,\n      .fns = c(mean = mean, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3) %>%\n  summarize(\n    sd_mean = sd(mean),\n    mean_sd = mean(sd)\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n  sd_mean mean_sd\n    <dbl>   <dbl>\n1   0.715   0.485\n\nNote, a better way to do this would perhaps be to use anova / linear modeling, or whatever method from those would properly weight the number of samples from each woman.\nwhat about the variation between the first samples from each woman?\n\n\ntaxa_summary_first <- x %>%\n  with_groups(host_subject_id, slice_min, host_visit_number, n = 1) %>%\n  mutate(across(.abundance, log)) %>%\n  with_groups(.otu, summarize,\n    across(.abundance,\n      .fns = c(mean = mean, median = median, sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  )\ntaxa_summary_first %>% arrange(-mean) %>% print(n=Inf)\n\n\n# A tibble: 30 × 5\n   .otu                            mean median    sd   var\n   <chr>                          <dbl>  <dbl> <dbl> <dbl>\n 1 Gardnerella_vaginalis          -2.62  -2.49  1.89  3.57\n 2 Lactobacillus_iners            -3.87  -4.04  2.74  7.50\n 3 Atopobium_vaginae              -4.54  -4.87  2.01  4.05\n 4 Lachnospiraceae_BVAB1          -5.58  -6.16  2.42  5.87\n 5 Lactobacillus_crispatus        -5.86  -6.88  3.24 10.5 \n 6 Prevotella_cluster2            -6.33  -6.65  2.05  4.21\n 7 Megasphaera_OTU70_type1        -6.51  -7.06  2.29  5.24\n 8 Ureaplasma_cluster23           -7.20  -7.66  2.49  6.19\n 9 Dialister_micraerophilus       -7.46  -7.39  1.98  3.93\n10 Dialister_cluster51            -7.62  -7.92  2.15  4.62\n11 Lactobacillus_jensenii         -7.66  -8.45  2.90  8.43\n12 Finegoldia_magna               -7.87  -8.16  2.21  4.90\n13 Aerococcus_christensenii       -8.01  -8.18  2.17  4.69\n14 Coriobacteriaceae_OTU27        -8.14  -8.65  2.29  5.26\n15 Lactobacillus_gasseri_cluster  -8.24  -8.76  2.64  6.98\n16 Prevotella_bivia               -8.37  -8.73  2.18  4.77\n17 Corynebacterium_cluster45      -8.47  -8.69  2.36  5.55\n18 Mycoplasma_hominis             -8.56  -8.92  2.22  4.92\n19 Staphylococcus_cluster47       -8.59  -8.91  2.38  5.65\n20 Clostridiales_BVAB2            -8.65  -9.17  2.20  4.85\n21 Peptoniphilus_indolicus        -8.74  -9.12  2.18  4.77\n22 Sneathia_amnii                 -8.97  -9.47  2.12  4.50\n23 TM7_OTU-H1                     -9.04  -9.39  2.21  4.88\n24 Parvimonas_OTU142              -9.11  -9.76  2.34  5.49\n25 Prevotella_amnii               -9.30  -9.79  2.18  4.74\n26 Campylobacter_ureolyticus      -9.30  -9.79  2.26  5.09\n27 Dialister_propionicifaciens    -9.40  -9.77  2.29  5.25\n28 Prevotella_disiens             -9.53  -9.85  2.15  4.61\n29 Prevotella_cluster50          -10.1  -10.4   2.09  4.35\n30 Sneathia_sanguinegens         -10.1  -10.6   2.15  4.63\n\n# taxa_summary %>% arrange(-mean) %>% print(n=Inf)\n\n\n\nThese sd’s are similar to the overall sds, which makes sense given most pairwise comparisons are between women.\n\n\nme_summary_first <- mean_eff1 %>%\n  with_groups(host_subject_id, slice_min, host_visit_number, n = 1) %>%\n  mutate(across(mean_efficiency, log)) %>%\n  summarize(\n    across(mean_efficiency,\n      .fns = c(sd = sd, var = var),\n      .names = '{.fn}'\n    )\n  ) %>%\n  print\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.956 0.914\n\nme_summary\n\n\n# A tibble: 1 × 2\n     sd   var\n  <dbl> <dbl>\n1 0.892 0.796\n\nThis is somewhat larger, but again similar.\nTentative: We see that the (log-e) mean efficiency sd is around 0.9, while the sd of individual taxa ranges from 2-3.5 (between women and overall). Within women, the mean efficiency sd and that of individual taxa are both smaller, such that the relative importance of each seems similar.\nVisualize, for the first sample from each woman:\n\n\nbind_rows(\n  x, \n  mean_eff1 %>% mutate(.otu = 'Mean efficiency', .abundance = mean_efficiency)\n) %>%\n  with_groups(c(.otu, host_subject_id), slice_min, host_visit_number, n = 1) %>%\n  mutate(\n    across(.abundance, log),\n    across(.otu, fct_reorder, .abundance)\n  ) %>%\n  ggplot(aes(y = .otu, x = .abundance)) +\n  ggdist::stat_slab()\n\n\n\n\nFold changes in mean efficiency\nHow often do shifts in the mean efficiency occur within a single subject? How often do shifts from Lacto to non-Lacto dominance occur within a single subject? How often do shifts from Lacto to Gardnerella dominance occur within a single subject?\nLet’s start by computing the pairwise changes in the sample mean efficiency between consecutive samples within women, and between the first samples of different women (first samples only to limit the number of sample pairs).\nSince we may be missing some host visits, let’s create a new host visit number that has no gaps:\n\n\nmean_eff2 <- mean_eff1 %>%\n  with_groups(host_subject_id, mutate, \n    host_visit_rank = rank(host_visit_number))\n\n\n\n\n\ntb <- crossing(\n  sample.1 = mean_eff2$.sample, \n  sample.2 = mean_eff2$.sample\n  ) %>%\n  left_join(mean_eff2, by = c(sample.1 = '.sample')) %>%\n  left_join(mean_eff2, by = c(sample.2 = '.sample'), suffix = c('.1', '.2')) %>%\n  mutate(\n    comparison_type = case_when(\n      host_subject_id.1 == host_subject_id.2 & host_visit_rank.2 == host_visit_rank.1 + 1 ~ \n        'Between consecutive visits',\n      host_subject_id.1 != host_subject_id.2 & host_visit_rank.2 == 1 & host_visit_rank.1 == 1 ~\n        \"Between subjects' first visits\"\n    )\n  ) %>%\n  filter(!is.na(comparison_type)) %>%\n  mutate(\n    switch_class = case_when(\n      top_plot.1 == top_plot.2 ~ 'No change',\n      str_detect(top_plot.1, 'Gardnerella') & str_detect(top_plot.2, 'Lactobacillus') ~ 'Gard. to Lacto.',\n      str_detect(top_plot.1, 'Lactobacillus') & str_detect(top_plot.2, 'Gardnerella') ~ 'Lacto. to Gard.',\n      str_detect(top_plot.1, 'Lactobacillus') & str_detect(top_plot.2, 'Lactobacillus') ~ 'Lacto. to Lacto.',\n      TRUE ~ 'Other',\n    )\n  )\n\n# tb_within <- tb %>%\n#   filter(host_subject_id.1 == host_subject_id.2, host_visit_rank.2 == host_visit_rank.1 + 1)\n# tb_between <- tb %>%\n#   filter(host_subject_id.1 != host_subject_id.2, host_visit_rank.2 == 1, host_visit_rank.1 == 1)\n\n\n\nLet’s look at the distribution of FCs in mean efficiency, coloring by whether there is a shift in dominant species.\n\n\ntb %>%\n  ggplot(aes(mean_efficiency.2 / mean_efficiency.1, fill = switch_class)) +\n  facet_wrap(~comparison_type, ncol = 1, scales = 'free_y') +\n  geom_histogram() +\n  scale_x_log10() +\n  # expand_limits(x = range(bias_all_vec)) +\n  labs(\n    x = \"Fold change in mean efficiency\", \n    y = \"Number of sample pairs\",\n    fill = 'Change in most\\nabundant species'\n  ) +\n  scale_fill_brewer(type = 'qual', palette = 3)\n\n\n\n\nUnsurprisingly, shifts in the mean efficiency tend to be larger between different subjects. Note, the between-subject panel is perfectly symmetric, but the consecutive-visits panel is not.\n\n\ntb %>%\n  count(comparison_type, switch_class) %>%\n  with_groups(comparison_type, mutate, prop = close_elts(n)) %>%\n  knitr::kable(digits = 3)\n\n\ncomparison_type\nswitch_class\nn\nprop\nBetween consecutive visits\nGard. to Lacto.\n61\n0.044\nBetween consecutive visits\nLacto. to Gard.\n63\n0.046\nBetween consecutive visits\nLacto. to Lacto.\n51\n0.037\nBetween consecutive visits\nNo change\n829\n0.601\nBetween consecutive visits\nOther\n375\n0.272\nBetween subjects’ first visits\nGard. to Lacto.\n50750\n0.153\nBetween subjects’ first visits\nLacto. to Gard.\n50750\n0.153\nBetween subjects’ first visits\nLacto. to Lacto.\n50046\n0.151\nBetween subjects’ first visits\nNo change\n68572\n0.206\nBetween subjects’ first visits\nOther\n112234\n0.338\n\nExample community trajectory\nPick a woman with multiple visits and a large change in mean efficiency to illustrate the potential impact of bias on species trajectories. We expect large changes in efficiency to be drive by changes in dominance from Gard to Lactobacillus (or vice versa).\nTo pick a woman, let’s first examine the distribution of geometric standard deviations of mean efficiency across subjects, and pick a subject at the upper end who has multiple visits.\n\n\nme <- mean_eff1 %>%\n  mutate(across(mean_efficiency, log)) %>%\n  with_groups(host_subject_id, summarize,\n    across(mean_efficiency,\n      .fns = c(mean = mean, sd = sd, var = var),\n      .names = '{.fn}'\n    ),\n    n = n()\n  ) %>%\n  filter(n >= 3)\n\n\n\n\n\nme %>% slice_max(sd, n = 10)\n\n\n# A tibble: 10 × 5\n   host_subject_id   mean    sd   var     n\n   <chr>            <dbl> <dbl> <dbl> <int>\n 1 EP591995        -1.03   1.48  2.18     3\n 2 EP996091        -1.03   1.45  2.11     3\n 3 EP418446        -1.17   1.44  2.08     3\n 4 EP972345        -1.09   1.42  2.03     3\n 5 EP694022        -1.30   1.39  1.94     3\n 6 EP974070        -0.970  1.38  1.90     3\n 7 EP280575        -1.59   1.35  1.81     5\n 8 EP174763        -1.80   1.33  1.76     3\n 9 EP292135        -1.50   1.26  1.58     3\n10 EP438714        -1.57   1.25  1.56     3\n\nLet’s pick subject ‘EP280575’, who has the most visits within the top 10.\n\n\nsid <- 'EP280575'\nps_obs <- momspi %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~max(.) > 1e-3)\nps_cal <- momspi_cal %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(taxa_names(ps_obs), .)\nx <- list(Calibrated = ps_cal, Observed = ps_obs) %>%\n  map_dfr(as_tibble, .id = \"type\") %>%\n  mutate(across(.otu, fct_relabel, function(x) str_replace_all(x, '_', ' ')))\n\n\n\n\n\ntaxa_to_plot <- x %>% \n  filter(type == 'Calibrated') %>%\n  with_groups(.otu, summarize, \n    med = median(log10(.abundance)),\n    max = max(log10(.abundance)),\n  ) %>%\n  filter(max > -2.5) %>%\n  arrange(-max) %>%\n  pull(.otu) %>%\n  print\n\n\n [1] Lactobacillus iners                    \n [2] Gardnerella vaginalis                  \n [3] Lachnospiraceae BVAB1                  \n [4] Atopobium vaginae                      \n [5] Ureaplasma cluster23                   \n [6] Enterobacteriaceae cluster31           \n [7] Megasphaera OTU70 type1                \n [8] Finegoldia magna                       \n [9] Lactobacillus gasseri cluster          \n[10] Prevotella cluster2                    \n[11] Coriobacteriaceae OTU27                \n[12] Clostridiales BVAB2                    \n[13] Corynebacterium cluster45              \n[14] Prevotella amnii                       \n[15] Dialister cluster51                    \n[16] Prevotellaceae OTU61                   \n[17] Corynebacterium imitans lipophiloflavum\n25 Levels: Aerococcus christensenii ... Ureaplasma cluster23\n\nx %>%\n  filter(.otu %in% taxa_to_plot) %>%\n  mutate(.otu = factor(.otu, taxa_to_plot)) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\n\n\n\n\nFor the final plot, I’ll pick the most abundant 3 taxa (which are driving the mean efficiency) and two more taxa that show the different behaviors.\n\n\ntaxa_to_plot <- c(\n  'Gardnerella_vaginalis', 'Lachnospiraceae_BVAB1', 'Lactobacillus_iners',\n  'Ureaplasma_cluster23', 'Megasphaera_OTU70_type1') %>%\n  str_replace_all('_', ' ')\np_sp <- x %>%\n  filter(.otu %in% taxa_to_plot) %>%\n  mutate(.otu = factor(.otu, taxa_to_plot)) %>%\n  filter(as.integer(.otu) <= 6) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\np_me <- mean_eff1 %>%\n  filter(host_subject_id == sid) %>%\n  ggplot(aes(host_visit_number, mean_efficiency)) +\n  scale_y_log10() +\n  labs(y = 'Efficiency', title = 'Mean efficiency') +\n  geom_line(aes(group = 1))\np_me / p_sp &\n  annotate('rect', xmin = 3, xmax = 4, ymin = Inf, ymax = 0, alpha = 0.1) &\n  labs(x = 'Host visit') &\n  plot_layout(heights = c(0.1, 1)) &\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nFor comparison, let’s also look at a long trajectory where there is no major change in mean efficiency.\n\n\nme %>% slice_min(sd, n = 10)\n\n\n# A tibble: 10 × 5\n   host_subject_id    mean      sd        var     n\n   <chr>             <dbl>   <dbl>      <dbl> <int>\n 1 EP090829        -0.0318 0.00244 0.00000595     3\n 2 EP853831        -0.374  0.00544 0.0000296      4\n 3 EP733790        -0.395  0.00555 0.0000308      4\n 4 EP495882        -0.373  0.00567 0.0000321      3\n 5 EP646235        -0.373  0.00665 0.0000443      4\n 6 EP131838        -0.0920 0.00805 0.0000648      3\n 7 EP573960        -0.378  0.0145  0.000211       3\n 8 EP694646        -0.379  0.0165  0.000273       5\n 9 EP494740        -0.0644 0.0172  0.000296       4\n10 EP205465        -0.0468 0.0176  0.000309       4\n\n\n\nsid <- 'EP694646'\n\nps_obs <- momspi %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  filter_taxa2(~max(.) > 1e-3)\nps_cal <- momspi_cal %>%\n  filter_sample_data(host_subject_id == sid) %>%\n  transform_sample_counts(close_elts) %>%\n  prune_taxa(taxa_names(ps_obs), .)\nx <- list(Calibrated = ps_cal, Observed = ps_obs) %>%\n  map_dfr(as_tibble, .id = \"type\") %>%\n  mutate(across(.otu, fct_relabel, function(x) str_replace_all(x, '_', ' ')))\nntaxa(ps_obs)\n\n\n[1] 6\n\n\n\np_sp <- x %>%\n  mutate(.otu = fct_reorder(.otu, -.abundance)) %>%\n  ggplot(aes(host_visit_number, .abundance, color = type)) +\n  scale_y_log10() +\n  facet_wrap(~.otu, ncol = 1, scales = 'free_y') +\n  geom_line(aes(group = type)) +\n  labs(y = 'Proportion', title = 'Species proportions') +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top')\np_me <- mean_eff1 %>%\n  filter(host_subject_id == sid) %>%\n  ggplot(aes(host_visit_number, mean_efficiency)) +\n  scale_y_log10() +\n  labs(y = 'Efficiency', title = 'Mean efficiency') +\n  geom_line(aes(group = 1))\np_me / p_sp &\n  labs(x = 'Host visit') &\n  plot_layout(heights = c(0.1, 1)) &\n  plot_annotation(tag_levels = 'A')\n\n\n\n\nNote that the variation in mean efficiency is very small.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-01-11\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.1     2021-06-06 [1] Bioconductor\n bit                4.0.4      2020-08-04 [1] CRAN (R 4.0.2)\n bit64              4.0.5      2020-08-30 [1] CRAN (R 4.0.2)\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom              0.7.10     2021-10-31 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.0      2021-10-27 [1] CRAN (R 4.1.1)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n distributional     0.2.2      2021-02-02 [1] CRAN (R 4.0.4)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs               * 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)\n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggdist             3.0.1      2021-11-30 [1] CRAN (R 4.1.2)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.5.1      2021-11-30 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.9      2021-11-23 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)\n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)\n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9008 2021-10-30 [1] Github (mikemc/metacal@c1f21db)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n vroom              1.5.7      2021-11-30 [1] CRAN (R 4.1.2)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.28       2021-11-04 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nBrooks, J Paul, David J Edwards, Michael D Harwich, Maria C Rivera, Jennifer M Fettweis, Myrna G Serrano, Robert A Reris, et al. 2015. “The truth about metagenomics: quantifying and counteracting bias in 16S rRNA studies.” BMC Microbiol. BioMed Central. https://doi.org/10.1186/s12866-015-0351-6.\n\n\nFettweis, Jennifer M., Myrna G. Serrano, Jamie Paul Brooks, David J. Edwards, Philippe H. Girerd, Hardik I. Parikh, Bernice Huang, et al. 2019. “The vaginal microbiome and preterm birth.” Nat. Med. 25 (6): 1012–21. https://doi.org/10.1038/s41591-019-0450-2.\n\n\nMcLaren, Michael R, Amy D Willis, and Benjamin J Callahan. 2019. “Consistent and correctable bias in metagenomic sequencing experiments.” Elife 8 (September): 46923. https://doi.org/10.7554/eLife.46923.\n\n\n\n\n",
    "preview": "posts/2021-11-01-momspi-summary/momspi-summary_files/figure-html5/unnamed-chunk-4-1.svg",
    "last_modified": "2022-01-11T14:54:57-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-27-illustrate-the-problem/",
    "title": "Illustrate the basic problem",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-27",
    "categories": [
      "ref:brooks2015thet",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nR setup\nBrooks et al\nSetup\nPlots\n\nLeopold and Busby 2020\nSetup\nPlots\n\nSession info\n\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\nBrooks et al\nSetup\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nLoad data from the cellular mock communities of Brooks et al 2015 from metacal,\n\n\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n\n\nNote that the single-species samples present.\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nPlots\nIdea is to focus on a single species and show that the error in log proportions is inconsistent, and therefore there is error in the fold changes. L. crispatus is a species MM and BC commonly use to illustrate the inconsistent error, as since it has an intermediate efficiency, we see its error varying in sign/direction. However, the errors in fold changes don’t depend on this aspect, but only the variation in mean efficiency, and is therefore the same for all species.\nData frame for comparing measured and actual proportions:\n\n\nbrooks_prop <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nbrooks_fc <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\n\n\nset.seed(42)\nspecies <- 'Lactobacillus_crispatus'\n\nsamples <- actual %>%\n  as_tibble %>%\n  filter(.otu == species, .abundance > 0) %>%\n  pull(.sample)\n\np1 <- brooks_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- brooks_fc %>%\n  filter(.otu == species, sample1 %in% samples, sample2 %in% samples) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n# p2\n\n\n\n\n\n(p1 + labs(x = 'Actual', y = 'Measured', title = 'Proportion')) + \n  (p2 + labs(x = 'Actual', y = 'Measured', title = 'Fold change')) + \n  plot_annotation(tag_levels = 'A')\n\n\n\n\nLeopold and Busby 2020\nThis dataset is for DNA mocks rather than cellular mocks; however the magnitude of bias is similar. This dataset has a couple advantages for illustration purposes:\nEach species has a wider range of actual proportions than in the Brooks dataset.\nThe ratios between species varies, whereas in the Brooks dataset it is always 1:1. \nSetup\n\n\n## From the metacal 2.0 tutorial\n# Download data from https://zenodo.org/record/3872145\ndata_path <- here::here(\"notebook/_data\", \"leopold2020host\")\n# To use a temporary directory:\n# data_path <- file.path(tempdir(), \"leopold2020\")\nif (!dir.exists(data_path)) {\n  dir.create(data_path, recursive = TRUE)\n  download.file(\n    \"https://zenodo.org/record/3872145/files/dleopold/Populus_priorityEffects-v1.2.zip\",\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\")\n  )\n  unzip(\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\"), \n    exdir = data_path\n  )\n}\n#> The microbiome data is stored in a phyloseq object,\nps <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/output/compiled/phy.rds\") %>%\n  readRDS\n\nsample_data(ps) <- sample_data(ps) %>%\n  transform(\n    Timepoint = factor(Timepoint)\n  )\n\nmock_actual <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/data/MockCommunities.csv\") %>%\n  read.csv(row.names = 1) %>%\n  select(-Sym4) %>%\n  as(\"matrix\") %>%\n  otu_table(taxa_are_rows = FALSE) %>%\n  transform_sample_counts(function(x) close_elts(1 / x))\nmock_taxa <- taxa_names(mock_actual)\nsam <- sample_data(ps) %>% as(\"data.frame\") %>% as_tibble(rownames = \"Sample\")\ntax <- tax_table(ps) %>% as(\"matrix\") %>% as_tibble(rownames = \"Taxon\")\nps.mock <- ps %>% \n  subset_samples(Samp_type == \"Mock\") %>%\n  prune_taxa(mock_taxa, .)\nleopold_actual <- mock_actual\nleopold_observed <- ps.mock %>% otu_table\nrm(mock_actual, mock_taxa, sam, tax, ps.mock)\n\n\n\nPlots\n\n\nleopold_prop <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nleopold_fc <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\nNote, in this case all species are (nominally) in all samples, but that Epicoccum is observed in 0 reads in one sample.\n\n\nspecies <- 'Cladosporium'\n# species <- 'Alternaria'\n# species <- 'Trichoderma'\n\np1 <- leopold_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- leopold_fc %>%\n  filter(.otu == species) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\np1 + p2\n\n\n\n\nSame but for the ratios between two species:\n\n\nx <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'taxa', filter = FALSE)\n\nleopold_ratio <- x %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  filter(otu1 != otu2)\n\nleopold_ratio_fc <- x %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(otu1 != otu2, sample1 != sample2)\n\n\n\n\n\nspecies1 <- 'Cladosporium'\nspecies2 <- 'Fusarium'\n# species2 <- 'Melampsora'\n# species <- 'Trichoderma'\n\np3 <- leopold_ratio %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual ratio', y = 'Measured ratio', color = 'Species') +\n  theme(legend.position = 'none')\np4 <- leopold_ratio_fc %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\n(p1 + p2) / (p3 + p4)\n\n\n\n\nNote, the ratio-view isn’t always obviously better; e.g. when Mel is involved; perhaps because of noise?\nTo make things more directly comparable, it might be best to use faceting and to fix the axes to have the same span.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.1 (2021-08-10)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-10-27                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.1     2021-06-06 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n bookdown           0.24       2021-09-02 [1] CRAN (R 4.1.1)                   \n broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                   \n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                   \n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                \n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                   \n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs               * 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)                   \n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                   \n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.7      2021-10-15 [1] CRAN (R 4.1.1)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                   \n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                   \n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                   \n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                   \n metacal          * 0.2.0.9005 2021-10-04 [1] Github (mikemc/metacal@773cbf3)  \n mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                   \n nvimcom          * 0.9-102    2021-10-25 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)                   \n readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                     \n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)                   \n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                   \n tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                   \n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.27       2021-10-18 [1] CRAN (R 4.1.1)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-10-27-illustrate-the-problem/illustrate-the-problem_files/figure-html5/brooks_lcrisp_prop_and_fc-1.svg",
    "last_modified": "2021-10-27T09:28:34-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-25-brooks2015thet-calibration/",
    "title": "Illustrate calibration types in the mock communities from Brooks et al (2015)",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-25",
    "categories": [
      "ref:brooks2015thet"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\n\n\n# Load data from the cellular mock communities of Brooks et al 2015\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n# Estimate bias with bootstrapping for error estimation\nmc_fit <- estimate_bias(observed, actual, boot = TRUE)\ncontrol_species <- mc_fit %>% coef %>% names\nsummary(mc_fit)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 7 × 4\n  taxon                    estimate gm_mean gm_se\n  <chr>                       <dbl>   <dbl> <dbl>\n1 Atopobium_vaginae           0.285   0.285  1.04\n2 Gardnerella_vaginalis       0.160   0.160  1.05\n3 Lactobacillus_crispatus     2.29    2.29   1.03\n4 Lactobacillus_iners         4.68    4.69   1.02\n5 Prevotella_bivia            1.79    1.78   1.04\n6 Sneathia_amnii              4.59    4.59   1.04\n7 Streptococcus_agalactiae    0.250   0.250  1.03\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\nare the single-species samples present?\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nYes.\nCalibration\nCalibration from community control\nDemonstrate that calibration using a single mock community can create a substantial improvement.\n\n\nsmpls <- actual %>%\n  as_tibble %>%\n  with_groups(.sample, summarize, n_species = sum(.abundance > 0)) %>%\n  filter(n_species == 7) %>%\n  pull(.sample)\n\n\n\n\n\ncontrol_samples <- smpls[1]\nbias_from_control <- estimate_bias(\n  observed %>% prune_samples(control_samples, .),\n  actual %>% prune_samples(control_samples, .),\n  ) %>%\n  coef\ncalibrated <- calibrate(observed, bias_from_control)\n\n\n\nCalibration using a reference species\nOne way to do this is to get the correction for each pair of samples, then join it with the table from previous. Another is to make the calibrated OTU table, then redo the pairwise ratio stuff.\nBasic Idea: Multiply the ratio of focal to ref species by the true proportion of the ref. One way to achieve this with phyloseq objects is to construct the correction matrix, then multiply this by the observed proportions\n\n\nref_species <- 'Lactobacillus_crispatus'\n\nref_actual <- actual %>% prune_taxa(ref_species, .) %>% c\nref_observed <- observed %>% prune_taxa(ref_species, .) %>% c\n\ncorrection_matrix <- matrix(\n  ref_actual / ref_observed, \n  nrow = nsamples(observed), ncol= ntaxa(observed),\n  byrow = FALSE\n)\n\ncalibrated_ref <- otu_table(observed * correction_matrix, taxa_are_rows = FALSE)\n\n\n\nPlot comparing calibrated and uncalibrated fold changes\n\n\nx <- list(\n  Actual = actual, \n  Uncalibrated = observed %>% transform_sample_counts(close_elts),\n  Calibrated_community = calibrated,\n  Calibrated_reference = calibrated_ref\n  ) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type')\n\n\n\n\n\nlvls <- mc_fit %>% coef %>% sort %>% names\n\nbrooks2015_fcs <- x %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  pivot_longer(contains('calibrated'), \n    names_to = 'type', values_to = 'Measured'\n  ) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2) %>%\n  mutate(\n    across(type, fct_relevel, 'Uncalibrated'),\n    across(\n      type, fct_recode,\n      'Calibrated (community)' = 'Calibrated_community',\n      'Calibrated (reference)' = 'Calibrated_reference'\n      ),\n    across(.otu, factor, levels = rev(lvls)),\n    # across(.otu, fct_relabel, adjust_species_names)\n  )\n\n\n\nCheck on number of rows in these data frames,\n\n\n# expected in 'x'\nn1 <- observed %>% nsamples %>% print\n\n\n[1] 80\n\nn2 <- observed %>% ntaxa\nall.equal(n1 * n1 * n2 * 4, x %>% nrow)\n\n\n[1] TRUE\n\nx %>% nrow\n\n\n[1] 179200\n\nbrooks2015_fcs %>% nrow\n\n\n[1] 17586\n\nLet’s plot just the sample-pairs with L. crispatus present, so that the same samples are shown in all panels.\n\n\n# Find subset of pairs to plot\nsample_pairs <- brooks2015_fcs %>%\n  filter(is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  select(sample1, sample2) %>%\n  unite(pair, sample1, sample2) %>%\n  distinct %>%\n  pull(pair)\n\n# Species labels\nspecies_label <- function(species) {\n  species %>%\n    str_replace('(?<=^[A-Z])[a-z]+_', '. ')\n}\nspecies_label(lvls)\n\n\n[1] \"G. vaginalis\"  \"S. agalactiae\" \"A. vaginae\"    \"P. bivia\"     \n[5] \"L. crispatus\"  \"S. amnii\"      \"L. iners\"     \n\np <- brooks2015_fcs %>%\n  unite(pair, sample1, sample2) %>%\n  filter(pair %in% sample_pairs, is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(\n    values = colors_brooks, \n    labels = species_label(colors_brooks %>% names)\n  ) +\n  facet_wrap(~type) +\n  scale_x_log10() +\n  scale_y_custom +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(), alpha = 0.5) +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'bottom')\np\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-10-25-brooks2015thet-calibration/brooks2015thet-calibration_files/figure-html5/brooks2015thet_fc_calibration-1.png",
    "last_modified": "2021-10-27T08:15:19-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-18-evaluate-robustness-example/",
    "title": "Evaluate robustness example",
    "description": "Evaluate the robustness of an estimate and inference to bias.",
    "author": [
      {
        "name": "Amy D. Willis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "bias sensitivity",
      "ref:callahan2017repl"
    ],
    "contents": "\n\nContents\nRobustness of an analysis to bias\nExample: relative abundance of Gardnerella\n\nData setup\nSession info\n\nRobustness of an analysis to bias\nWe can investigate the sensitivity of any analysis to taxonomic bias by simulating possible efficiency vectors, calibrating our observed MGS measurements by these efficiencies, and rerunning our analysis on the simulated and calibrated data. Specifically, we can take the observed proportion of each species in our dataset \\(\\hat{\\text{prop}}_{i}(a)\\), and “undo” the efficiencies to obtain the calibrated proportions \\[\\begin{align}\n  \\text{calibrated prop}_{i}(a)\n  &= \\left( \\frac{\\hat{\\text{prop}}_{i}(a)}{\\text{efficiency}_{i}} \\right) \\bigg / \\sum_{i'} \\left( \\frac{\\hat{\\text{prop}}_{i'}(a)}{\\text{efficiency}_{i'}} \\right),\n\\end{align}\\] and the calibrated read counts \\[\\begin{align}\n  \\text{reads}_{i}(a)\n  &= \\text{total reads}(a) \\times \\text{calibrated prop}_{i}(a).\n\\end{align}\\] We can then rerun our data analysis using the calibrated read counts in place of our original data. If we do this repeatedly, each time using different realizations of the efficiency vector, we can investigate how the results of our analysis change. If the change is minimal, this suggests that our results are robust to unequal detection efficiencies in the different species. The converse would suggest that we need to be careful interpreting our results.\nExample: relative abundance of Gardnerella\nWe illustrate this method using vaginal microbiome data from pregnant women published in a study by Callahan et al. (2017) seeking to replicate associations of specific genera (Lactobacillus, Gardnerella, and Ureaplasma) with preterm birth in two cohorts. For example, suppose we are interested in investigating if the genus Gardnerella is more abundant in the vaginal microbiome of women who give birth preterm, and we investigate this model by running corncob using preterm birth as a covariate in the mean and dispersion model. We could investigate the robustness of our findings using the following structure:\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n\nIn brief, this approach uses the library simulator to generate random efficiencies and “undo” them as described above, then runs corncob on these generated datasets before finally obtaining the estimated coefficients on preterm birth and the p-value for the hypothesis test that the coefficient on preterm birth is zero. Let’s take a look at the components of the code.\nFirst, we load the relevant libraries and our data (see Data setup),\n\n\n# library(here)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(speedyseq)\nlibrary(corncob)\n# devtools::install_github(\"jacobbien/simulator\")\nlibrary(simulator)\ncal <- readRDS(\n  here::here(\"notebook/_data\", \"callahan2017repl\", \"callahan2017repl_phyloseq_clean.rds\")\n)\n\n\n\nThen we can create the function that generates random efficiencies and accordingly alters the observed counts:\n\n\nundo_efficiencies <- function(ps, sig_sq_e) {\n\n  ps_ms <- ps %>% group_by(.sample) %>% mutate(mm = sum(.abundance)) %>% ungroup\n  ps_tax <- ps %>% select(`.otu`, `kingdom`:`species`) %>% distinct %>% tax_table\n  ps_sample <- ps %>% select(`.sample`, `subject_id`:`outcome`) %>% distinct %>% sample_data\n\n  new_model(name = \"eff_undo\", label = sprintf(\"sig_sq_e = %s\", sig_sq_e),\n            params = list(ps_ms = ps_ms, ps_tax = ps_tax, ps_sample = ps_sample, sig_sq_e = sig_sq_e),\n            simulate = function(ps_ms, ps_tax, ps_sample, sig_sq_e, nsim) {\n              replicate(nsim,\n                        {\n                          effs_tib <- ps_ms %>%\n                            select(genus) %>% distinct %>%\n                            mutate(\"efficiency\" = rnorm(nrow(.), mean = 0, sd = sqrt(sig_sq_e)) %>% exp)\n\n                          ps_tib <- ps_ms %>%\n                            full_join(effs_tib) %>%\n                            group_by(.sample) %>%\n                            mutate(p_ijs = (.abundance / efficiency) / sum(.abundance / efficiency)) %>%\n                            mutate(w_ij = round(mm * p_ijs)) %>%\n                            ungroup\n\n                          phyloseq(ps_tib %>%\n                                     select(`.otu`, `.sample`, `w_ij`) %>%\n                                     pivot_wider(names_from=`.otu`, values_from=`w_ij`) %>%\n                                     otu_table(taxa_are_rows = F),\n                                   ps_tax,\n                                   ps_sample) %>%\n                            tax_glom(\"genus\")\n                        },\n                        simplify=F)\n            })\n}\n\n\n\nNext, we specify how we use our data to construct our estimates. We are using bbdml from the library corncob to model the relative abundance of ASV 8 (Gardnerella) using preterm birth as a covariate to model the mean and dispersion, but this is only one type of analysis that we might be interested in.\n\n\ncorncob_Gardnerella <- new_method(\"corncob\", \"Corncob\",\n                               method = function(model, draw) {\n\n                                 fit <- bbdml(formula = ASV8 ~ preterm,\n                                              formula_null= ~1,\n                                              phi.formula= ~ preterm,\n                                              phi.formula_null= ~1,\n                                              data = draw %>%\n                                                merge_samples2(\"subject_id\", fun_otu = sum))\n\n                                 list(fit = fit,\n                                      summary = summary(fit))\n                               })\n\n\n\nFinally, we construct methods to obtain the estimated coefficient on preterm birth in the mean relative abundance model, and its p-value.\n\n\nbetahat_fit <- new_metric(\"betahat\", \"beta-hat\",\n metric = function(model, out) {\n   out$summary$coefficients[2,1]\n })\npvalue_fit <- new_metric(\"pvalue\", \"p-value\",\n                         metric = function(model, out) {\n                           out$summary$coefficients[2,4]\n                         })\n\n\n\nNow that we have all of the pieces, we can run them together as follows. The below code runs 100 simulations split across 4 cores; for testing, the commented code runs just 4 iterations.\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  # simulate_from_model(nsim = 4, index = 1) %>%\n  # run_method(list(corncob_Gardnerella)) %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/model.Rdata\n#> ..Simulated 25 draws in 6.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r1.Rdata\n#> ..Simulated 25 draws in 5.37 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r2.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r3.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r4.Rdata\n#> ..Simulated 25 draws in 8.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r1.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r2.Rdata\n#> ..Simulated 25 draws in 6.43 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r3.Rdata\n#> ..Simulated 25 draws in 6.47 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r4.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r1.Rdata\n#> ..Simulated 25 draws in 6.77 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r2.Rdata\n#> ..Simulated 25 draws in 5.97 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r3.Rdata\n#> ..Simulated 25 draws in 6.62 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r4.Rdata\n#> ..Simulated 25 draws in 7.09 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r1.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r2.Rdata\n#> ..Simulated 25 draws in 6.12 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r3.Rdata\n#> ..Simulated 25 draws in 5.89 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r4.Rdata\n#> ..Simulated 25 draws in 5.66 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r1.Rdata\n#> ..Simulated 25 draws in 5.49 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r2.Rdata\n#> ..Simulated 25 draws in 5.31 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r3.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r4.Rdata\n#> ..Simulated 25 draws in 5.67 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r1.Rdata\n#> ..Simulated 25 draws in 6.16 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r2.Rdata\n#> ..Simulated 25 draws in 5.3 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r3.Rdata\n#> ..Simulated 25 draws in 5.54 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r4.Rdata\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n\nHere’s how the estimated coefficient on preterm birth changes under different draws from a distribution given by \\(\\text{efficiency}_{i} \\overset{iid}{\\sim} \\text{LogNormal}(0, \\sigma^2_e)\\), and how the p-value for testing the null hypothesis that the coefficient on preterm birth is zero:\n\n\nev_df <- our_sim %>% evals %>% as.data.frame\nmodel_df <- our_sim %>% model %>% as.data.frame\nev_with_model_params <- dplyr::right_join(model_df, ev_df, by = c(\"name\" = \"Model\")) %>% tibble\nf_names <- list('p-value' = \"p-value\",\n                'beta-hat' = expression(hat(beta)))\nf_labeller <- function(variable, value){return(f_names[value])}\n\n\n\n\n\nev_with_model_params %>%\n  pivot_longer(cols = betahat:pvalue, names_to=\"eval\") %>%\n  mutate(eval = ifelse(eval == \"pvalue\", \"p-value\", \"beta-hat\")) %>%\n  ggplot(aes(x = sig_sq_e, group = sig_sq_e, y = value)) +\n  geom_boxplot() +\n  geom_abline(aes(slope = slope, intercept = intercept), color = \"blue\",\n              tibble(eval = c(\"p-value\", \"beta-hat\"), slope = c(0,0), intercept = c(0.05, 0))) +\n  xlab(expression(sigma[e]^2)) +\n  # ggtitle(\"Corncob results for testing\\nH0: Mean Gardnerella relative abundance is equal for preterm & full-term\") +\n  facet_wrap(~eval, scales=\"free_y\", nrow = 2, labeller = f_labeller) +\n  ylab(\"\") +\n  cowplot::theme_cowplot()\n\n\n\n\nWhile the estimate of the coefficient does not change on average, we see more variation in its estimate as the variation in the efficiencies increases. For some realizations from a model with large variation in the efficiencies, we even see a change in the sign of \\(\\hat{\\beta}\\) from positive to negative. Furthermore, we see a corresponding increase in the range of p-values, suggesting that more variation in the efficiencies can lead to either deattenuated estimates (larger p-values) or more precise non-zero estimates (smaller p-values).\nA major advantage of this approach is that any distribution of efficiency vectors can be investigated. For example, we could specifically investigate how Gardnerella being low- or high-efficiency impacts our results. We could also investigate more sophisticated distributions for the efficiencies, such as correlated efficiencies across phylogeny.\nData setup\nThe following code was used to download and prepare the data from Callahan et al. (2017) for analysis; it is not evaluated when this document is knit. The first code chunk downloads the ASV abundance matrix, sample metadata, and taxonomy assignments for the vaginal samples.\n\n\nlibrary(tidyverse)\nlibrary(speedyseq)\n\n# Download --------------------------------------------------------------------\ndl_path <- here::here(\"notebook/_data\", \"callahan2017repl\")\nlink <- \"https://stacks.stanford.edu/file/druid:yb681vm1809/RepRefine_Scripts.tar.gz\"\nif (!dir.exists(dl_path)) {\n  dir.create(dl_path)\n  download.file(link, file.path(dl_path, basename(link)))\n  system2(\"tar\", args = c(\"-xvf\", file.path(dl_path, basename(link)), \"-C\", dl_path))\n}\nload(file.path(dl_path, \"RepRefine_Scripts\", \"input\", \"processed.rda\"))\n# This loads:\n# df: the sample metadata\n# st: the sequence table (in counts)\n# ft: the sequence table normalized to frequencies / proportions\n# tax: taxonomy assignment matrix\n# \n# To confirm relationship between ft and st, run \n# all.equal(ft, st %>% apply(1, function(x) x / sum(x)) %>% t)\n# \n# The taxonomy matrix has an extra column with a duplicate name of \"Species\"\n# that is all NAs, so let's remove that\ntax <- tax[, -8]\n# Import into phyloseq --------------------------------------------------------\nsam <- sample_data(df)\nst <- otu_table(st, taxa_are_rows = FALSE)\ntax <- tax_table(tax)\nps <- phyloseq(sam, st, tax)\n# Check that all samples and taxa made it into the phyloseq object\nstopifnot(all.equal(colnames(st), taxa_names(ps)))\nstopifnot(all.equal(rownames(sam), sample_names(ps)))\n# Add ASV sequences to the refseq() slot\nseqs <- taxa_names(ps) %>% rlang::set_names() %>% Biostrings::DNAStringSet()\nps <- merge_phyloseq(ps, seqs)\n# Rename the ASVs to simpler names (ASV1, ASV2, ...). The full sequences remain\n# in `refseq(ps)`.\ntaxa_names(ps) <- paste0(\"ASV\", seq(ntaxa(ps)))\n# Clean up objects\nrm(tax, df, sam, st, ft, seqs)\n\n\n\nNext, we use munging functions from janitor and speedyseq to select the metadata of primary interest, standardize format of column names, and convert categorical variables to factors.\n\n\nps1 <- ps %>% \n  select_sample_data(SubjectID, Cohort, Race, preterm, Outcome) %>%\n  rename_with_sample_data(janitor::make_clean_names) %>%\n  rename_with_tax_table(janitor::make_clean_names) %>%\n  mutate_sample_data(\n    across(c(subject_id, cohort, race, outcome), factor),\n  )\n\n\n\nFinally, we save the phyloseq object for use in the analysis.\n\n\nsaveRDS(ps1, file.path(dl_path, \"callahan2017repl_phyloseq_clean.rds\"))\nrm(ps, ps1)\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.1 (2021-08-10)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-10-25                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package          * version    date       lib source                              \n#>  ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                      \n#>  ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                      \n#>  assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                      \n#>  backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  Biobase            2.52.0     2021-05-19 [1] Bioconductor                        \n#>  BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                        \n#>  biomformat         1.20.0     2021-05-19 [1] Bioconductor                        \n#>  Biostrings         2.60.1     2021-06-06 [1] Bioconductor                        \n#>  bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                      \n#>  bookdown           0.22       2021-04-22 [1] CRAN (R 4.1.0)                      \n#>  broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                      \n#>  bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                      \n#>  cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                      \n#>  cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                      \n#>  cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                      \n#>  codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                      \n#>  colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                   \n#>  corncob          * 0.2.0      2021-03-11 [1] CRAN (R 4.0.5)                      \n#>  cowplot            1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)   \n#>  crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                      \n#>  data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                      \n#>  dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                      \n#>  digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                      \n#>  distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                      \n#>  downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                      \n#>  dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                      \n#>  ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                      \n#>  fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                      \n#>  farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                      \n#>  fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                      \n#>  forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                      \n#>  foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                      \n#>  generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                      \n#>  GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                        \n#>  GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                        \n#>  ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                      \n#>  glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                      \n#>  gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                      \n#>  haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                      \n#>  here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                      \n#>  highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                      \n#>  hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                      \n#>  httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                      \n#>  igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                      \n#>  IRanges            2.26.0     2021-05-19 [1] Bioconductor                        \n#>  iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                      \n#>  jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                      \n#>  labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                      \n#>  lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                      \n#>  lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                      \n#>  lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                      \n#>  magrittr         * 2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                      \n#>  MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                      \n#>  Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                      \n#>  multtest           2.48.0     2021-05-19 [1] Bioconductor                        \n#>  munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                      \n#>  nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                      \n#>  nvimcom          * 0.9-102    2021-10-25 [1] local                               \n#>  permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                      \n#>  phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                        \n#>  pillar             1.6.3      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                      \n#>  plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                      \n#>  purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                      \n#>  R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                      \n#>  Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                      \n#>  RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                      \n#>  readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                      \n#>  reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                      \n#>  reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                      \n#>  rhdf5              2.36.0     2021-05-19 [1] Bioconductor                        \n#>  rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                        \n#>  Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                        \n#>  rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                      \n#>  rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                      \n#>  rvest              1.0.1      2021-07-26 [1] CRAN (R 4.1.0)                      \n#>  S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                        \n#>  sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                      \n#>  scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                      \n#>  sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                      \n#>  simulator        * 0.2.3      2021-10-25 [1] Github (jacobbien/simulator@aef35ab)\n#>  speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)   \n#>  stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                      \n#>  stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                      \n#>  survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                      \n#>  tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                      \n#>  tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                      \n#>  tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                      \n#>  utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                      \n#>  vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                      \n#>  withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                      \n#>  xfun               0.26       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                      \n#>  XVector            0.32.0     2021-05-19 [1] Bioconductor                        \n#>  yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                      \n#>  zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                        \n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\nCallahan, Benjamin J, Daniel B DiGiulio, Daniela S Aliaga Goltsman, Christine L Sun, Elizabeth K Costello, Pratheepa Jeganathan, Joseph R Biggio, et al. 2017. “Replication and refinement of a vaginal microbial signature of preterm birth in two racially distinct cohorts of US women.” Proc. Natl. Acad. Sci. U. S. A. 114 (37): 9966–71. https://doi.org/10.1073/pnas.1705899114.\n\n\n\n\n",
    "preview": "posts/2021-10-18-evaluate-robustness-example/evaluate-robustness-example_files/figure-html5/summary_plot-1.svg",
    "last_modified": "2021-10-25T19:17:34-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-09-momspi-patient-exploration-and-summary/",
    "title": "MOMS-PI patient exploration and analysis of fold changes",
    "description": {},
    "author": [
      {
        "name": "Jacob T. Nearing",
        "url": {}
      },
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-09",
    "categories": [
      "ref:brooks2015thet",
      "ref:fettweis2019thev"
    ],
    "contents": "\nThis is a link post to an analysis of the MOMS-PI vaginal microbiome profiles. The analysis computes, for each species, the fold changes between subsequent visits within individual women. It then plots species trajectories for several women, with and without calibration, and visualizes and computes some summary statistics for the observed versus actual fold changes for the species in the mock community.\nLink to analysis\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-19T14:40:29-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-03-simulate-regression-example/",
    "title": "Simulate regression example",
    "description": "Simulate an example of how bias impacts a regression analysis.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-08-03",
    "categories": [],
    "contents": "\n\nContents\nSimulate data\nActual\nabundances\nTaxonomic bias and\nmeasured abundances\nCompute mean efficiencies\n\nPlots\nEstimated and actual\nabundances\nRegression coefficients\nManuscript\nfigure\nStandard\nerrors\n2022-10-08 Modified main figure\n\n\n\n\n# library(here)\nlibrary(tidyverse)\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nlibrary(ggdist)\nlibrary(ggbeeswarm)\n\nlibrary(speedyseq)\nlibrary(metacal)\n\nset.seed(42)\n\n\n\nSimulate data\n\n\nn_species <- 10\nn_samples <- 50\n\nspecies <- str_c(\"Sp. \", seq(n_species))\n\n\n\nActual abundances\nLog abundances are independent and follow a simple linear model,\nlog abundance = a_0 + a_1 * X + epsilon\n\n\nn_samples <- 50\nx <- c(\n  rep(0, n_samples / 2),\n  rep(1, n_samples / 2)\n)\nX <- rbind(1, x)\n\nSigma <- diag(1, nrow = n_species)\nrownames(Sigma) <- colnames(Sigma) <- species\na_0 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na_1 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na <- cbind(a_0, a_1)\nnames(a_0) <- names(a_1) <- rownames(a) <- species\n\nepsilon <- MASS::mvrnorm(\n  n = n_samples,\n  mu = rep(0, n_species), \n  Sigma = diag(0.5, nrow = n_species)\n) %>%\n  t\n\ny <- a %*% X + epsilon\ncolnames(y) <- str_glue(\"sa{1:n_samples}\")\n\n\n\nFor the data frame of true coefficients, convert from log-e to\nlog-2.\n\n\ntrue_coeffs <- list('(Intercept)' = a_0, x1 = a_1) %>%\n  map_dfr(enframe, \".otu\", \"truth\", .id = \"term\") %>%\n  mutate(across(truth, ~ . / log(2))) %>%\n  print\n\n\n#> # A tibble: 20 × 3\n#>    term        .otu     truth\n#>    <chr>       <chr>    <dbl>\n#>  1 (Intercept) Sp. 1  -0.0905\n#>  2 (Intercept) Sp. 2   2.91  \n#>  3 (Intercept) Sp. 3  -0.137 \n#>  4 (Intercept) Sp. 4   2.18  \n#>  5 (Intercept) Sp. 5  -0.153 \n#>  6 (Intercept) Sp. 6   0.583 \n#>  7 (Intercept) Sp. 7   0.913 \n#>  8 (Intercept) Sp. 8   0.524 \n#>  9 (Intercept) Sp. 9  -0.815 \n#> 10 (Intercept) Sp. 10  1.98  \n#> 11 x1          Sp. 1   1.90  \n#> 12 x1          Sp. 2  -3.52  \n#> 13 x1          Sp. 3  -3.83  \n#> 14 x1          Sp. 4  -0.410 \n#> 15 x1          Sp. 5   0.917 \n#> 16 x1          Sp. 6  -0.192 \n#> 17 x1          Sp. 7  -0.402 \n#> 18 x1          Sp. 8  -2.00  \n#> 19 x1          Sp. 9   3.30  \n#> 20 x1          Sp. 10  1.88\n\n\n\nsam <- tibble(.sample = colnames(y), x) %>%\n  mutate(across(x, factor))\nactual_abun <- phyloseq(\n  otu_table(y, taxa_are_rows = TRUE) %>% transform_sample_counts(exp),\n  sample_data(sam)\n)\n\n\n\n\n\nactual_abun %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance, fill = x)) +\n  scale_x_log10() +\n  stat_dots()\n\n\n\n\nTaxonomic bias and\nmeasured abundances\nDraw efficiencies from a log normal distribution; set relative to the\ngeometric mean efficiency.\n\n\nlog_efficiency <- MASS::mvrnorm(\n  mu = rep(0, n_species),\n  Sigma = diag(3, nrow = n_species)\n) %>%\n  # {. - min(.)}\n  {. - mean(.)}\nefficiency <- exp(log_efficiency)\n# names(efficiency) <- species\n\n\n\n\n\nlog_efficiency %>% summary\n\n\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#> -3.7952 -1.4314  0.0123  0.0000  0.9551  5.0904\n\nmax(efficiency) / min(efficiency)\n\n\n#> [1] 7226.731\n\nefficiency %>% qplot + scale_x_log10()\n\n\n\n\nTo create an association of log mean efficiency and the covariate, I\nwill set set it so that the species with the largest slope coefficient\nalso has the largest efficiency. This scenario is inspired by the\nleopold2020host and brooks2015thet experiments.\n\n\nidx_slope <- which.max(a_1)\nidx_eff <- which.max(efficiency)\nnames(efficiency) <- species\nnames(efficiency)[idx_eff] <- species[idx_slope]\nnames(efficiency)[idx_slope] <- species[idx_eff]\n\n\n\nData frame with all species parameters,\n\n\nspecies_params <- true_coeffs %>%\n  pivot_wider(names_from = term, values_from = truth) %>%\n  rename(intercept = '(Intercept)') %>%\n  left_join(efficiency %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  mutate(log2_efficiency = log2(efficiency)) %>%\n  print\n\n\n#> # A tibble: 10 × 5\n#>    .otu   intercept     x1 efficiency log2_efficiency\n#>    <chr>      <dbl>  <dbl>      <dbl>           <dbl>\n#>  1 Sp. 1    -0.0905  1.90      0.0225          -5.48 \n#>  2 Sp. 2     2.91   -3.52      1.15             0.200\n#>  3 Sp. 3    -0.137  -3.83      0.213           -2.23 \n#>  4 Sp. 4     2.18   -0.410     0.0748          -3.74 \n#>  5 Sp. 5    -0.153   0.917     2.98             1.58 \n#>  6 Sp. 6     0.583  -0.192     0.339           -1.56 \n#>  7 Sp. 7     0.913  -0.402     0.892           -0.165\n#>  8 Sp. 8     0.524  -2.00      1.73             0.787\n#>  9 Sp. 9    -0.815   3.30    162.               7.34 \n#> 10 Sp. 10    1.98    1.88      9.62             3.27\n\n\n\nspecies_params %>%\n  ggplot(aes(x1, log2_efficiency)) +\n  geom_text(aes(label = str_extract(.otu, '[0-9]+')))\n\n\n\n\nQuestion: Is it true that the first species is driving the\nassociation?\nThe measured (i.e. estimated) proportions and abundances are given by\nperturbing the actual abundances by the efficiencies, and normalizing to\nproportions or to the original (correct) total.\n\n\nmeasured_prop <- actual_abun %>% perturb(efficiency)\nmeasured_abun <- actual_abun %>% perturb(efficiency, norm = \"keep\")\n\n\n\nCompute mean efficiencies\n\n\nmean_eff <- actual_abun %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(efficiency, norm = \"none\") %>%\n  sample_sums %>%\n  enframe(\".sample\", \"mean_efficiency\") %>%\n  left_join(sam, by = \".sample\") %>%\n  mutate(log2_mean_efficiency = log2(mean_efficiency))\n\n\n\n\n\nmean_eff %>%\n  ggplot(aes(y = as.factor(x), x = mean_efficiency)) +\n  scale_x_log10() +\n  stat_dotsinterval()\n\n\n\n\nPlots\nEstimated and actual\nabundances\n\n\nlvls <- a_1 %>% sort(decreasing = TRUE) %>% names\n\nabun <- bind_rows(\n  Actual = actual_abun %>% as_tibble,\n  Measured = measured_abun %>% as_tibble,\n  .id = 'type'\n) %>%\n  rename(abundance = .abundance) %>%\n  mutate(\n    log2_abundance = log2(abundance),\n    across(.otu, factor, levels = lvls)\n  )\n\n\n\n\n\np_species_all <- abun %>%\n  ggplot(aes(x, log2_abundance, color = type)) +\n  labs(y = \"Log efficiency\", x = \"Condition (x)\") +\n  facet_grid(.otu~type, scales = \"fixed\") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\", fun.data = mean_se) +\n  stat_smooth(aes(x = as.integer(x)), formula = y~x,\n    method = \"lm\", size = 0.9, fill = 'grey', se = FALSE\n  ) +\n  theme(legend.position = \"none\")\np_species_all \n\n\n\n\n\n\np_mean_eff <- mean_eff %>%\n  ggplot(aes(x, log2(mean_efficiency))) +\n  labs(y = \"Log efficiency\", x = \"Condition (x)\") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\", fun.data = mean_se) +\n  stat_smooth(aes(x = as.integer(x)), formula = y~x,\n    method = \"lm\", size = 0.9, color = 'black', fill = 'grey', se = FALSE\n  )\np_mean_eff \n\n\n\n\n\n\np_mean_eff + p_species_all +\n  plot_layout(ncol = 1, heights = c(0.2, 1)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nRegression coefficients\n\n\nlm_fit_mean_eff <- mean_eff %>%\n  {lm(log2_mean_efficiency ~ 1 + x, .)}\nlm_results_mean_eff <- lm_fit_mean_eff %>%\n  broom::tidy(conf.int = TRUE)\n\n\n\n\n\nlm_fits <- abun %>%\n  group_by(.otu, type) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log2_abundance ~ 1 + x, .))\n  )\nlm_results <- lm_fits %>%\n  mutate(\n    fit = map(fit, broom::tidy, conf.int = TRUE)\n  ) %>%\n  select(-data) %>%\n  unnest(fit) %>%\n  ungroup %>%\n  left_join(true_coeffs, by = c(\".otu\", \"term\"))\n\nlm_results_slope <- lm_results %>%\n  filter(term == \"x1\") %>%\n  mutate(\n    across(.otu, fct_reorder, estimate)\n  ) %>%\n  arrange(.otu)\n\n\n\n\n\n# params for arrows showing error\ndelta <- lm_results_mean_eff %>% filter(term == \"x1\") %>% pull(estimate)\nstart <- lm_results_slope %>% filter(type == 'Actual', .otu == 'Sp. 9') %>%\n  pull(estimate)\n\np_coef_ci <- lm_results_slope %>% \n  ggplot(aes(y = .otu, x = estimate, color = type)) +\n  labs(x = \"Mean LFD\", y = NULL, color = \"Type\") +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_pointinterval(aes(xmin = conf.low, xmax = conf.high)) +\n  theme(legend.position = 'top') +\n  guides(color = guide_legend(reverse = TRUE)) +\n  annotate(\n    geom = 'segment', color = \"darkred\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = start, xend = start - delta, \n    y = 10.5, yend = 10.5,\n    size = .7\n  ) +\n  annotate(\n    geom = 'text', color = \"darkred\",\n    label = 'Effect of bias',\n    x = start - delta/2,\n    y = 10.8,\n  ) +\n  coord_cartesian(clip = 'off')\n\np_coef_ci_with_true_coef <- p_coef_ci +\n  geom_point(data = ~filter(., type == \"Actual\"),\n    aes(x = truth),\n    color = 'black', shape = '+', size = 4)\n\np_coef_ci_mean_eff <- lm_results_mean_eff %>% \n  filter(term == \"x1\") %>%\n  ggplot(aes(y = \"Mean efficiency\", x = estimate)) +\n  expand_limits(\n    x = c(\n      min(lm_results_slope$conf.low), \n      max(lm_results_slope$conf.high)\n  )) +\n  labs(x = \"Mean LFD\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_point() +\n  annotate(\n    geom = 'segment', color = \"darkred\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = 0, xend = delta, \n    y = 1.0, yend = 1.0,\n    size = .7\n  )\n\np_coef_dot <- lm_results_slope %>% \n  ggplot(aes(y = type, x = estimate, fill = type)) +\n  labs(x = \"Mean LFD\", y = \"Type\") +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  stat_dots()\n\np_coef_ci_mean_eff / p_coef_ci_with_true_coef / p_coef_dot + \n  plot_layout(heights = c(0.2, 1, 0.3)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nThe true coefficients fall within the ‘Actual’ CIs, confirming that\nour simulations worked. For the manuscript figure, we won’t include the\ntrue data-generating coefficients, since our aim is to illustrate the\nrelationship between coefficients estimated on the ‘Actual’ and\n‘Measured’ measurements.\nManuscript figure\nChose species that show the full range of qualitative behaviors in\nterms of the effect of taxonomic bias on the estimated slope\ncoefficient.\nSpecies 9: Bias causes a substantial decrease in the magnitude of\nthe slope\nSpecies 10: Bias causes a substantial decrease in the magnitude of\nthe slope, such that the estimate is no longer distinguishable from\nzero.\nSpecies 5: Bias causes a sign error\nSpecies 7: Bias cases a small negative slope that would not have\nbeen distinguishable from zero to become significantly (in a biological\nand statistical sense) negative\nSpecies 2: Bias cases a substantially negative slope to become more\nnegative (increased magnitude)\n\n\nspecies_to_plot <- str_c(\"Sp. \", c('9', '10', '5', '7', '2'))\np_species_focal <- p_species_all\np_species_focal$data <- p_species_focal$data %>% \n  filter(.otu %in% species_to_plot)\n\n# Bold these species in coeffcient CI plot\np_coef_ci1 <- p_coef_ci +\n  theme(\n    axis.text.y = element_text(\n      face = ifelse(levels(p_coef_ci$data$.otu) %in% species_to_plot, \n        \"bold\", \"plain\")\n    )\n  )\n\n# Set range of mean eff panel to match\nrng <- p_species_focal$data %>%\n  pull(log2_abundance) %>%\n  {max(.) - min(.)}\nm <- p_mean_eff$data %>% pull(mean_efficiency) %>% log2 %>% mean\np_mean_eff1 <- p_mean_eff + \n  expand_limits(y = c(m - rng/2, m + rng/2))\n\n\n\n\n\n(p_mean_eff1 + ggtitle(\"Mean efficiency\")) +\n  (p_coef_ci_mean_eff + ggtitle(\"LFD in mean efficiency\")) + \n  (p_species_focal + ggtitle(\"Actual and measured\\nabundances of select species\")) + \n  (p_coef_ci1 + ggtitle(\"Mean LFD estimated from\\nactual or measured abundances\") +\n    theme(legend.box.margin = margin(b = -15))\n  ) + \n  plot_layout(ncol = 2, heights = c(0.2, 1)) +\n  plot_annotation(tag_levels = 'A') &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto() &\n  theme(\n    plot.title = element_text(face = \"plain\")\n  )\n\n\n\n\nStandard errors\n\n\nlm_results %>%\n  mutate(across(.otu, factor, levels = lm_results_slope$.otu %>% levels)) %>%\n  ggplot(aes(y = .otu, x = std.error, color = type)) +\n  facet_wrap(~term) +\n  geom_point() +\n  colorblindr::scale_color_OkabeIto()\n\n\n\n\nCan see that the standard error is generally increased in the\nmeasured abundance estimates except for Species 9, whose residual\nvariation we expect to be correlated with the log mean efficiency and\nhence negatively correlated with the measurement error.\nLet’s confirm that the relationship between the SEs in the measured\nresponse, the actual response, and the mean efficiency agree with our\ntheoretical expectation. To do so, we must compute the sample covariance\nof the residual of the actual response and the mean efficiency for each\nspecies.\n\n\naug_mean_eff <- lm_fit_mean_eff %>% \n  broom::augment() %>% \n  add_column(.sample = mean_eff$.sample)\naug <- lm_fits %>%\n  mutate(\n    .sample = map(data, pull, '.sample'),\n    augment = map(fit, broom::augment),\n  ) %>%\n  select(-data, -fit) %>%\n  unnest(c(.sample, augment)) %>%\n  ungroup %>%\n  left_join(aug_mean_eff, by = c(\".sample\", \"x\"), suffix = c('.abun', '.mean_eff'))\n\n\n\n\n\ncov_actual_with_mean_eff <- aug %>%\n  filter(type == 'Actual') %>%\n  with_groups(.otu, summarize,\n    cov = cov(.resid.abun, .resid.mean_eff)\n  ) %>%\n  print\n\n\n#> # A tibble: 10 × 2\n#>    .otu       cov\n#>    <fct>    <dbl>\n#>  1 Sp. 9   0.565 \n#>  2 Sp. 1  -0.111 \n#>  3 Sp. 10 -0.163 \n#>  4 Sp. 5  -0.0326\n#>  5 Sp. 6  -0.0115\n#>  6 Sp. 7  -0.0672\n#>  7 Sp. 4  -0.172 \n#>  8 Sp. 8  -0.105 \n#>  9 Sp. 2   0.0449\n#> 10 Sp. 3   0.0338\n\n\n\nstd_err_mean_eff <- lm_fit_mean_eff %>% broom::tidy() %>%\n  filter(term == 'x1') %>% pull(std.error)\nstd_errs <- lm_results_slope %>%\n  select(type, .otu, std.error) %>%\n  pivot_wider(names_from = type, values_from = std.error, \n    names_prefix = \"se_\") %>%\n  left_join(cov_actual_with_mean_eff, by = '.otu') %>%\n  print\n\n\n#> # A tibble: 10 × 4\n#>    .otu   se_Actual se_Measured     cov\n#>    <fct>      <dbl>       <dbl>   <dbl>\n#>  1 Sp. 3      0.292       0.341  0.0338\n#>  2 Sp. 2      0.311       0.354  0.0449\n#>  3 Sp. 8      0.244       0.336 -0.105 \n#>  4 Sp. 4      0.252       0.357 -0.172 \n#>  5 Sp. 6      0.278       0.340 -0.0115\n#>  6 Sp. 7      0.290       0.363 -0.0672\n#>  7 Sp. 5      0.269       0.337 -0.0326\n#>  8 Sp. 1      0.283       0.367 -0.111 \n#>  9 Sp. 10     0.289       0.383 -0.163 \n#> 10 Sp. 9      0.270       0.130  0.565\n\n\n\nstd_errs %>%\n  mutate(.otu,\n    se2_Measured = se_Measured^2,\n    pred = se_Actual^2 + std_err_mean_eff^2 -\n      cov * 2 / ((n_samples - 2) * var(x))\n      # cov * 2 * (n_samples - 1) / (n_samples * (n_samples - 2) * var(x))\n  )\n\n\n#> # A tibble: 10 × 6\n#>    .otu   se_Actual se_Measured     cov se2_Measured   pred\n#>    <fct>      <dbl>       <dbl>   <dbl>        <dbl>  <dbl>\n#>  1 Sp. 3      0.292       0.341  0.0338       0.116  0.116 \n#>  2 Sp. 2      0.311       0.354  0.0449       0.125  0.125 \n#>  3 Sp. 8      0.244       0.336 -0.105        0.113  0.113 \n#>  4 Sp. 4      0.252       0.357 -0.172        0.128  0.128 \n#>  5 Sp. 6      0.278       0.340 -0.0115       0.115  0.115 \n#>  6 Sp. 7      0.290       0.363 -0.0672       0.132  0.132 \n#>  7 Sp. 5      0.269       0.337 -0.0326       0.114  0.114 \n#>  8 Sp. 1      0.283       0.367 -0.111        0.135  0.135 \n#>  9 Sp. 10     0.289       0.383 -0.163        0.147  0.147 \n#> 10 Sp. 9      0.270       0.130  0.565        0.0170 0.0170\n\nThe prediction for the squared standard error from the theoretical\ncalculation agrees with what we observe.\nTODO: Sort out why it is this version, and not the other, that gives\nagreement. Perhaps the standard errors being returned by R are using the\nMLE estimate of sigma instead of the OLS estimate?\n2022-10-08 Modified main figure\nNew panel showing simulated efficiencies and mean LFDs, to replace\nthe panel showing the change in mean efficiency (former panel B).\n\n\np_params <- species_params %>%\n  ggplot(aes(x1, log2_efficiency)) +\n  theme(axis.line = element_blank()) +\n  # panel_border(remove = TRUE) +\n  # theme_minimal_grid() +\n  coord_cartesian(clip = 'off') +\n  geom_vline(xintercept = 0, color = 'grey') +\n  geom_hline(yintercept = 0, color = 'grey') +\n  geom_text(\n    aes(label = str_c('Sp. ', str_extract(.otu, '[0-9]+'))), \n    size = 4) +\n  labs(\n    x = 'Expected LFD',\n    y = 'Log efficiency'\n  )\np_params \n\n\n\n\nAnnotate mean efficiency plot,\n\n\n# params for arrow showing change\narrow_params <- mean_eff %>%\n  with_groups(x, summarize, across(log2_mean_efficiency, mean)) %>%\n  pull(log2_mean_efficiency)\n\np_mean_eff2 <- p_mean_eff +\n  annotate(\n    geom = 'segment', color = \"darkred\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = 2.5, xend = 2.5, \n    y = arrow_params[1], \n    yend = arrow_params[2], \n    size = .7\n  )\np_mean_eff2 \n\n\n\n\nAssemble with improved titles,\n\n\n\n(p_params + ggtitle(\"Simulated log efficiencies\\nand expected LFDs\")) +\n  (p_mean_eff2 + ggtitle(\"Mean efficiency across\\nsamples in each condition\")) +\n  # (p_coef_ci_mean_eff + ggtitle(\"LFD in mean efficiency\")) + \n  (p_species_focal + ggtitle(\"Actual and measured\\nabundances of select species\")) + \n  (p_coef_ci1 + ggtitle(\"Mean LFD estimated from\\nactual or measured abundances\") +\n    theme(legend.box.margin = margin(b = -15))\n  ) + \n  plot_layout(ncol = 2, heights = c(0.4, 1)) +\n  plot_annotation(tag_levels = 'A') &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto() &\n  theme(\n    plot.title = element_text(face = \"plain\")\n  )\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-08-03-simulate-regression-example/simulate-regression-example_files/figure-html5/unnamed-chunk-6-1.svg",
    "last_modified": "2022-10-08T15:58:19-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-10-vaginal-microbiome-example/",
    "title": "Hypothetical example of spurious fold changes in proportions in the vaginal microbiome",
    "description": "This doc develops a hypothetical example in which bias leads to a spurious differential abundance result. It is based on a real case of bias measured among three species of vaginally-associated bacteria.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-05-10",
    "categories": [],
    "contents": "\n\nContents\nSetup\nSimulate data\nPlots\nSession info\n\n\nChangelog\n2021-07-17: Cleaned up the doc and updated to use the cleaner code and include the caption from /article.Rmd\nSetup\n\n\nset.seed(42)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE,\n  cache = FALSE,\n  echo = TRUE\n)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nclose_elts <- function(x) x / sum(x)\n\n\n\nSimulate data\n\n\nbias <- tibble(taxon = c(\"Lactobacillus\", \"Gardnerella\", \"Atopobium\", \"Spike-in\"),\n  efficiency = c(4.68, 0.16, 0.285, 1)) %>%\n  mutate(across(efficiency, ~. / min(.)))\n# efficiency associated with the targeted measurement of Lactobacillus\ntargeted_efficiency <- 2\na0 <- tribble(\n  ~taxon, ~timepoint, ~abundance,\n  \"Lactobacillus\", \"T1\", 5,\n  \"Lactobacillus\", \"T2\", 0.5,\n  \"Gardnerella\", \"T1\", 2,\n  \"Gardnerella\", \"T2\", 8,\n  \"Atopobium\", \"T1\", 3,\n  \"Atopobium\", \"T2\", 1.5,\n) %>%\n  # Shrink abundance to have similar scale as proportions\n  mutate(across(abundance, ~ . / max(.))) %>%\n  left_join(bias, by = \"taxon\") %>%\n  with_groups(timepoint, mutate,\n    total_abundance = sum(abundance),\n    proportion = close_elts(abundance),\n    biased_abundance = efficiency * abundance,\n    biased_proportion = close_elts(biased_abundance),\n    biased_count = biased_proportion * 1e3,\n    abundance_estimate_bulk = biased_proportion * total_abundance,\n    #> abundance_estimate_spikein = biased_count / biased_count[taxon == \"Spike-in\"],\n    abundance_estimate_targeted = biased_count * targeted_efficiency *\n      abundance[taxon == \"Lactobacillus\"] / biased_count[taxon == \"Lactobacillus\"],\n  )\na1 <- a0 %>%\n  select(-total_abundance) %>%\n  pivot_longer(-c(taxon, efficiency, timepoint), names_to = \"type\")\n# data frame for plots\nptb <- a1 %>%\n  filter(\n    type %in% c(\"proportion\", \"biased_proportion\"),\n  ) %>%\n  mutate(\n    across(type, fct_relevel, \"proportion\", \"biased_proportion\"),\n    across(type, fct_recode,\n      \"Actual\" = \"proportion\",\n      \"Observed\" = \"biased_proportion\"),\n  )\n\n\n\nPlots\nPanels showing the error in measurement and in differential abundance\n\n\nshared_layers <- list(\n  geom_path(aes(group = taxon),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))),\n  geom_point(size = 2),\n  scale_color_brewer(type = \"qual\", palette = 1, guide = \"none\"),\n  labs(y = \"Proportion\", color = \"Taxon\"),\n  scale_y_log10(),\n  coord_cartesian(clip = \"off\"),\n  # scale_y_log10(breaks = c(1e-2, 3e-2, 1e-1, 3e-1, 1)) +\n  expand_limits(y = 1e-2),\n  theme(plot.margin = unit(c(0, 1.3, 0, 0), units = \"in\"))\n)\n# How much to nudge the taxon labels and proportions\nnudge.taxon <- 0.48\nnudge.prop <- 0.24\n# In future iterations, consider labelling the taxa in both facets\np.meas <- ptb %>%\n  ggplot(aes(type, value, color = taxon)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  shared_layers +\n  geom_text(data = ~filter(., type == \"Actual\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., type == \"Observed\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Type\",\n    title = \"Measurement error at each time point\"\n  )\np.fc <- ptb %>%\n  ggplot(aes(timepoint, value, color = taxon)) +\n  facet_wrap(~type, nrow = 1, scales = \"fixed\") +\n  shared_layers +\n  geom_text(data = ~filter(., timepoint == \"T1\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Time point\",\n    title = \"Actual and observed fold changes\"\n  )\n\n\n\nPanel showing the efficiencies of individual taxa and the sample means\n\n\n# First, compute the mean efficiency, then join with the taxon efficiencies in\n# a table for plotting.\nsme <- a0 %>%\n  with_groups(timepoint, summarize, mean_efficiency = sum(proportion * efficiency))\nsme0 <- sme %>%\n  mutate(label = str_glue(\"mean ({timepoint})\")) %>%\n  select(label, efficiency = mean_efficiency)\nsme1 <- sme %>%\n  mutate(taxon = \"Mean\", type = \"Mean\") %>%\n  select(taxon, efficiency = mean_efficiency, timepoint, type)\nbias1 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(type = \"Taxon\")\nlvls = c(\"Atopobium\", \"Gardnerella\", \"Lactobacillus\", \"Mean\")\netb1 <- bind_rows(bias1, sme1) %>%\n  mutate(across(taxon, factor, levels = lvls))\n\nlvls = c(\"Gardnerella\", \"Atopobium\", \"Lactobacillus\")\nbias2 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(\n    type = \"Taxon\",\n    across(taxon, factor, levels = lvls),\n    x = as.integer(taxon)\n  ) %>%\n  left_join(sme, by = \"timepoint\")\n\nclrs <- c(RColorBrewer::brewer.pal(n = 3, \"Accent\"), rep(\"#585858\", 2))\np.eff <- bias2 %>%\n  ggplot(aes(x = x, y = efficiency, color = taxon)) +\n  geom_point(size = 2) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = taxon), x = 3.3, hjust = 0) +\n  geom_segment(aes(xend = x, yend  = efficiency, y = mean_efficiency),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))) +\n  geom_segment(data = sme,\n    aes(x = 1, xend = 3, y = mean_efficiency, yend = mean_efficiency),\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  geom_text(data = sme0 %>% mutate(timepoint = \"T2\"),\n    aes(label = label, y = efficiency), x = 3.3, hjust = 0,\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  scale_color_manual(values = clrs) +\n  labs(y = \"Relative efficiency\", x = NULL, color = \"Taxon\",\n    title = \"Taxonomic bias of protocol\"\n  ) +\n  # Set the vertical span to match the other plots\n  scale_y_log10(limits = c(1, 100) / 2,\n    breaks = etb1$efficiency,\n    labels = signif(etb1$efficiency, 2)\n  ) +\n  xlim(c(0.0, 4)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  coord_cartesian(clip = \"off\") +\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.title.x = element_blank(),\n    legend.position = \"none\",\n    plot.margin = unit(c(0, 1.0, 0, 0), units = \"in\")\n  )\n\n\n\nPlot as a multi-panel figure\n\n\np.meas + p.eff + p.fc + plot_spacer() + \n  plot_layout(byrow = TRUE, ncol = 2, widths = c(1, 0.6)) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nCaption (copied from main article version 47ce39c): Taxonomic bias can distort differential abundance results even when it is consistent for each taxon across samples. Panel A shows the actual and observed proportions for hypothetical community samples from two time points, which differ in their relative abundance of three taxa. Panel B shows taxonomic bias in terms of the relative efficiencies of the three taxa against the mean efficiency of each sample; the difference between the taxon’s efficiency and the sample’s mean (vertical arrows) determines the fold error seen in Panel A. Panel C rearranges the plot from Panel A to show the actual and observed fold changes between time points. The efficiencies of individual taxa were estimated by @mclaren2019cons from mock community data from @brooks2015thet. The abundances are hypothetical but inspired by observations from the human vaginal microbiome; see main text.\nSome ideas for improvement:\nExperiment with ways to make the connections even clearer between the efficiency differences and the error.\nTry making the arrows vertical, so that they are directly connected to the fold changes in proportion and in efficiency.\nCan also split the third plot into T1 and T2.\nMight consider changing “Time point T1” to “Sample S1”, to fit the primary language of the text.\nCan mention in the text that these could be samples from different women, or the same woman at different times.\nalso use a shape scale for the taxa, to give a second way besides color to distinguish them\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.0 (2021-05-18)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-07-17                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package      * version date       lib source        \n#>  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n#>  backports      1.2.1   2020-12-09 [1] CRAN (R 4.0.3)\n#>  base64enc      0.1-3   2015-07-28 [1] CRAN (R 4.0.0)\n#>  bookdown       0.22    2021-04-22 [1] CRAN (R 4.1.0)\n#>  broom          0.7.6   2021-04-05 [1] CRAN (R 4.0.5)\n#>  bslib          0.2.5.1 2021-05-18 [1] CRAN (R 4.1.0)\n#>  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n#>  cli            3.0.0   2021-06-30 [1] CRAN (R 4.1.0)\n#>  colorspace     2.0-2   2021-06-24 [1] CRAN (R 4.1.0)\n#>  cowplot      * 1.1.1   2020-12-30 [1] CRAN (R 4.0.4)\n#>  crayon         1.4.1   2021-02-08 [1] CRAN (R 4.0.4)\n#>  DBI            1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n#>  dbplyr         2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n#>  digest         0.6.27  2020-10-24 [1] CRAN (R 4.0.3)\n#>  distill        1.2     2021-01-13 [1] CRAN (R 4.1.0)\n#>  downlit        0.2.1   2020-11-04 [1] CRAN (R 4.0.3)\n#>  dplyr        * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n#>  ellipsis       0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n#>  evaluate       0.14    2019-05-28 [1] CRAN (R 4.0.0)\n#>  fansi          0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n#>  farver         2.1.0   2021-02-28 [1] CRAN (R 4.0.4)\n#>  forcats      * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n#>  fs             1.5.0   2020-07-31 [1] CRAN (R 4.0.2)\n#>  generics       0.1.0   2020-10-31 [1] CRAN (R 4.0.3)\n#>  ggplot2      * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n#>  glue           1.4.2   2020-08-27 [1] CRAN (R 4.0.2)\n#>  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n#>  haven          2.4.1   2021-04-23 [1] CRAN (R 4.1.0)\n#>  here         * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n#>  highr          0.9     2021-04-16 [1] CRAN (R 4.1.0)\n#>  hms            1.1.0   2021-05-17 [1] CRAN (R 4.1.0)\n#>  htmltools      0.5.1.1 2021-01-22 [1] CRAN (R 4.0.3)\n#>  httr           1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n#>  jquerylib      0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n#>  jsonlite       1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n#>  knitr          1.33    2021-04-24 [1] CRAN (R 4.1.0)\n#>  labeling       0.4.2   2020-10-20 [1] CRAN (R 4.0.3)\n#>  lifecycle      1.0.0   2021-02-15 [1] CRAN (R 4.0.4)\n#>  lubridate      1.7.10  2021-02-26 [1] CRAN (R 4.0.4)\n#>  magrittr       2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n#>  modelr         0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n#>  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n#>  nvimcom      * 0.9-102 2021-07-17 [1] local         \n#>  patchwork    * 1.1.1   2020-12-17 [1] CRAN (R 4.0.3)\n#>  pillar         1.6.1   2021-05-16 [1] CRAN (R 4.1.0)\n#>  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n#>  purrr        * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n#>  R6             2.5.0   2020-10-28 [1] CRAN (R 4.0.3)\n#>  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 4.0.0)\n#>  Rcpp           1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n#>  readr        * 1.4.0   2020-10-05 [1] CRAN (R 4.0.3)\n#>  readxl         1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n#>  reprex         2.0.0   2021-04-02 [1] CRAN (R 4.0.5)\n#>  rlang          0.4.11  2021-04-30 [1] CRAN (R 4.1.0)\n#>  rmarkdown    * 2.8     2021-05-07 [1] CRAN (R 4.1.0)\n#>  rprojroot      2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n#>  rstudioapi     0.13    2020-11-12 [1] CRAN (R 4.0.3)\n#>  rvest          1.0.0   2021-03-09 [1] CRAN (R 4.0.5)\n#>  sass           0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n#>  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n#>  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.0)\n#>  stringi        1.6.2   2021-05-17 [1] CRAN (R 4.1.0)\n#>  stringr      * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n#>  tibble       * 3.1.2   2021-05-16 [1] CRAN (R 4.1.0)\n#>  tidyr        * 1.1.3   2021-03-03 [1] CRAN (R 4.0.4)\n#>  tidyselect     1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n#>  tidyverse    * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n#>  utf8           1.2.1   2021-03-12 [1] CRAN (R 4.0.5)\n#>  vctrs          0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n#>  withr          2.4.2   2021-04-18 [1] CRAN (R 4.0.5)\n#>  xfun           0.23    2021-05-15 [1] CRAN (R 4.1.0)\n#>  xml2           1.3.2   2020-04-23 [1] CRAN (R 4.0.0)\n#>  yaml           2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-05-10-vaginal-microbiome-example/vaginal-microbiome-example_files/figure-html5/vaginal-example-proportions-timepoints-1.svg",
    "last_modified": "2021-08-12T12:56:57-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/",
    "title": "Illustration of a spurious differential abundance result due to bias",
    "description": "Create illustration of a spurious differential abundance using the Leopold and Busby (2020) dataset.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-04-26",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9001'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 × 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.77   1.06\n2 Dioszegia        0.295   0.294  1.10\n3 Epicoccum        1.01    1.01   1.50\n4 Fusarium         3.07    3.06   1.14\n5 Penicillium      0.223   0.223  1.09\n6 Cladosporium     0.899   0.898  1.13\n7 Trichoderma      0.578   0.578  1.09\n8 Alternaria       1.47    1.47   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\nRegression analysis\nFirst let’s pick a subset of samples to work with.\n\n\nsam %>%\n  count(Samp_type, Timepoint)\n\n\n# A tibble: 4 × 3\n  Samp_type  Timepoint     n\n  <chr>      <fct>     <int>\n1 Experiment 1           250\n2 Experiment 2           298\n3 Mock       <NA>         10\n4 Single     <NA>          9\n\nsam %>%\n  filter(Samp_type == \"Experiment\") %>%\n  count(Treatment, Timepoint)\n\n\n# A tibble: 12 × 3\n   Treatment     Timepoint     n\n   <chr>         <fct>     <int>\n 1 Alternaria    1            52\n 2 Alternaria    2            53\n 3 Aureobasidium 1            50\n 4 Aureobasidium 2            48\n 5 Cladosporium  1            49\n 6 Cladosporium  2            48\n 7 Dioszegia     1            48\n 8 Dioszegia     2            49\n 9 Fusarium      1            49\n10 Fusarium      2            50\n11 Negative      1             2\n12 Negative      2            50\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Timepoint == 2) %>%\n  count(Region, Treatment)\n\n\n# A tibble: 12 × 3\n   Region Treatment         n\n   <chr>  <chr>         <int>\n 1 East   Alternaria       22\n 2 East   Aureobasidium    21\n 3 East   Cladosporium     19\n 4 East   Dioszegia        18\n 5 East   Fusarium         21\n 6 East   Negative         21\n 7 West   Alternaria       31\n 8 West   Aureobasidium    27\n 9 West   Cladosporium     29\n10 West   Dioszegia        31\n11 West   Fusarium         29\n12 West   Negative         29\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  count(Region, Timepoint)\n\n\n# A tibble: 4 × 3\n  Region Timepoint     n\n  <chr>  <fct>     <int>\n1 East   1           102\n2 East   2           101\n3 West   1           146\n4 West   2           147\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  with_groups(Genotype, summarize, n1 = sum(Timepoint == 1), n2 = sum(Timepoint == 2), tot = n())\n\n\n# A tibble: 12 × 4\n   Genotype    n1    n2   tot\n   <chr>    <int> <int> <int>\n 1 East-1      20    20    40\n 2 East-2      16    17    33\n 3 East-3      19    18    37\n 4 East-4      25    25    50\n 5 East-5      22    21    43\n 6 West-1      22    21    43\n 7 West-2      22    24    46\n 8 West-3      23    23    46\n 9 West-4      23    23    46\n10 West-5      18    17    35\n11 West-6      20    19    39\n12 West-7      18    20    38\n\nThe “Negative” treatment was not inoculated with commensals; let’s drop that from the analysis. Note that there are 2 more West genotypes adn thus more West than East samples.\nTime point\nAsks, how did taxa vary in proportion with the addition of Mel? Note, we expect the commensal taxa to typically decrease given that Mel successfully infects most plants.\nWant to do linear regression on the timepoint.\nstarting point - observed and calibrated proportions in the experiment samples; SME in the experiment samples\n\n\nps1.obs <- ps.pseudo %>%\n  subset_samples(Samp_type == \"Experiment\" & Treatment != \"Negative\") %>%\n  prune_taxa(mock_taxa, .) %>%\n  orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nps1.cal <- ps1.obs %>% calibrate(bias)\nsam1 <- sample_data(ps1.obs) %>% as(\"data.frame\")\nsme1 <- sme %>% filter(Sample %in% sample_names(ps1.obs)) %>% rename(Mean_efficiency = SMRE)\n\n\n\nNote the different numbers of samples at each timepoint Should consider more sophisticated resgression models.\n\n\nfit.obs <- lm(log2(otu_table(ps1.obs)) ~ Timepoint, data = sam1)\nfit.cal <- lm(log2(otu_table(ps1.cal)) ~ Timepoint, data = sam1)\nfit.sme <- lm(log2(Mean_efficiency) ~ Timepoint, data = sme1)\n\n\n\nCheck that the observed changes - the calibrated changes are off by the expected constant shift,\n\n\nt(coef(fit.obs) - coef(fit.cal))\n\n\n              (Intercept) Timepoint2\nMelampsora     2.60208447  -1.991951\nAureobasidium -0.96511376  -1.991951\nTrichoderma   -1.31867681  -1.991951\nFusarium       1.08940455  -1.991951\nPenicillium   -2.68941450  -1.991951\nAlternaria     0.02685515  -1.991951\nCladosporium  -0.68076501  -1.991951\nDioszegia     -2.28952043  -1.991951\nEpicoccum     -0.51768451  -1.991951\n\ncoef(fit.sme)\n\n\n(Intercept)  Timepoint2 \n  0.5269812   1.9919505 \n\n\n\ncoef(fit.obs) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -10.9999195  10.702851\nAureobasidium  -7.9294352  -3.681906\nTrichoderma    -9.4061811  -3.872543\nFusarium       -2.1926596  -5.089495\nPenicillium   -10.8867241  -2.555602\nAlternaria     -0.9593701  -4.074728\nCladosporium   -6.0294424  -3.585850\nDioszegia      -7.7191545  -5.463284\nEpicoccum      -2.3532764  -4.745944\n\ncoef(fit.cal) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -13.6020039 12.6948011\nAureobasidium  -6.9643215 -1.6899556\nTrichoderma    -8.0875043 -1.8805929\nFusarium       -3.2820642 -3.0975448\nPenicillium    -8.1973096 -0.5636511\nAlternaria     -0.9862252 -2.0827775\nCladosporium   -5.3486773 -1.5938999\nDioszegia      -5.4296340 -3.4713339\nEpicoccum      -1.8355919 -2.7539932\n\nThe effect of bias is significant; e.g. Aureobasidium and Trichoderma appear to decrease in proportion by 16X but actually decrease by 4X, and Penicillium appears to decrease by 5.9X but only decreases by 1.5X.\nCould use the case of Penicillium as our example.\n\n\n# Check expected relationship between coefficients on intercept and slope\nall.equal(\n  coef(fit.obs)[,\"Penicillium\"],\n  coef(fit.cal)[,\"Penicillium\"] + c(log2(bias[\"Penicillium\"]), 0) - coef(fit.sme)\n)\n\n\n[1] TRUE\n\n\n\ntb <- bind_rows(\n  Observed = psmelt(ps1.obs),\n  Calibrated = psmelt(ps1.cal),\n  .id = \"Type\"\n) %>%\n  mutate(across(Type, fct_relevel, \"Calibrated\")) %>%\n  rename(Proportion = Abundance)\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8) +\n  scale_color_brewer(type = \"qual\", palette = 6)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\nTODO: Add a panel with the sample mean efficiency\n\n\nsme1 %>%\n  ggplot(aes(y = log2(Mean_efficiency), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n\n\n\n\nQuestion: For the purposes of illustration, might we want to find the host region or host genotype with the largest change in SME? Ok as long as we’re clear what we’re doing. Reducing the number of data points and biological variation might actually make things cleaner as well (or could use boxplots), since the point is not to dwell on all the variation, but rather just the average effect.\nfor paper, might be clearer to call “Corrected” instead of “Calibrated”.\nCan easily split graph by region or host genotype:\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Region)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\") +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_grid(Region~Type)\n\n\n\n\nNote that the 95% CIs are small and hard to see.\nWant to plot the sme’s with the change in proportion; make sure the y-axes have the same scale. One way to simplify this is to show the mean efficiency relative to the taxon in question; then it will give the difference between calibrated and observed.\n\n\nsme2 <- sme1 %>%\n  mutate(Mean_relative_efficiency = Mean_efficiency / bias[\"Penicillium\"]) %>%\n  rename(Proportion = Mean_relative_efficiency) %>%\n  mutate(Type = \"Mean relative efficiency\")\ntb1 <- tb %>%\n  filter(OTU == \"Penicillium\") %>%\n  bind_rows(sme2) %>%\n  mutate(across(Type, fct_relevel, c(\"Calibrated\", \"Observed\", \"Mean relative efficiency\")))\n\n\n\n\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n)\ntb1 %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  lyrs +\n  facet_grid(Region~Type)\n\n\n\n\n\n\ntb1 %>%\n  mutate(across(Type, fct_reorder, Proportion)) %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.3) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_grid(.~Region) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = 5,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"Pathogen growth causes\\nmean efficiency to increase,\",\n  ) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = -10,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"which leads to larger-than-\\nactual decreases in the\\nfocal taxon Penicillium.\",\n  ) +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  theme(\n    legend.position = \"top\",\n    plot.margin = margin(r = 2.5, unit = \"in\"),\n  ) +\n  plot_annotation(\n    title = \"Effect of bias on Penicillium differential abundance\"\n  )\n\n\n\n\nSummary:\nRegression of log2(Proportion) of the fungus Penicillium versus timepoint; timepoints 1 and 2 are pre- and post- challenge with the pathogen Melampsora. Data is split by the region the host plants are derived from.\nCalibrated proportions = Observed proportions in the real, experimental samples after adjustment for the bias measured in mock communities\nMean efficiency of each community is inferred by treating the calibrated proportions as the truth, and multiplying by efficiencies estimated from the mocks\nThe pathogen Melampsora has a high measurement efficiency; thus once it infects the plants, the mean efficiency of the sample increases (purple points). Efficiency is here taken as relative to the focal taxon Penicillium.\nWest plants tend to be more resistant to the pathogen, which likely explains why the mean efficiency doesn’t increase as much in the West plants\nPenicillium is observed to decrease in log proportion, in both the East and West plants. But the calibrated measurements show that it actually slightly increases in the East plants, and has a lesser decrease in the West plants than what was observed before bias correction.\nThe difference between the Calibrated and Observed data points and regression lines equals the regression line of the mean efficiency: Orange = Green + Purple; Green = Orange - Purple\nThe absolute error in regression coeffiecients is the same for all taxa. I picked Penicillium for illustration since it has the smallest observed decrease, which makes the error due to bias have a particularly significant impact. \n\n\n\nAlt. plot\n\n\ntb2 <- tb1 %>%\n  mutate(\n    log2_proportion = log2(Proportion),\n    across(Type, fct_relevel, c(\"Observed\", \"Calibrated\", \"Mean relative efficiency\")),\n    #> across(Type, fct_recode, Corrected = \"Calibrated\", Uncorrected = \"Observed\")\n  )\n\n\n\nLet’s show the calibrated, observed, and mean efficiency side by side, similar to my initial explanatory plot.\nQuestion: How to get the same y-axis range in each facet? We need to determine what we want the min and max y values for each facet to be. Choose so that the range in each panel equals the max data range for any one panel, and center the data range of each panel within the plot range.\n\n\nyr <- tb2 %>%\n  with_groups(c(Region, Type), summarize, \n    across(log2_proportion, c(min = min, max = max), .names =  \"data_{.fn}\")\n ) %>%\n  mutate(\n    data_range = data_max - data_min,\n    data_mid = (data_max + data_min) / 2,\n    y_min = data_mid - max(data_range) / 2,\n    y_max = data_mid + max(data_range) / 2\n  ) %>%\n  print\n\n\n# A tibble: 6 × 8\n  Region Type      data_min data_max data_range data_mid   y_min y_max\n  <chr>  <fct>        <dbl>    <dbl>      <dbl>    <dbl>   <dbl> <dbl>\n1 East   Observed    -14.9     -8.66       6.26   -11.8  -16.2   -7.41\n2 East   Calibrat…   -12.2     -5.96       6.22    -9.07 -13.5   -4.69\n3 East   Mean rel…     2.48     5.27       2.79     3.87  -0.510  8.26\n4 West   Observed    -14.9     -6.16       8.77   -10.5  -14.9   -6.16\n5 West   Calibrat…   -11.3     -3.58       7.76    -7.46 -11.8   -3.07\n6 West   Mean rel…     2.47     5.26       2.79     3.87  -0.515  8.25\n\nstopifnot(yr %>% {sd((.$y_max - .$y_min))} < 1e-14)\nyr.long <- yr %>%\n  pivot_longer(c(y_min, y_max))\n\n\n\n\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  geom_blank(data = yr.long, aes(y = value, x = 1)) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_wrap(Region~Type, scales = \"free_y\") +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)) +\n  labs(y = \"log2(Proportion)\")\n\n\n\n\n\n\ntext_tb <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\n#> Label \"Calibrated\" as \"Actual\" for purposes of illustration?\nlblr <- function(labels) {\n  labels %>% pull(1) %>% fct_recode(Actual = \"Calibrated\") %>% as.character %>% list\n}\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    #> arrow = grid::arrow(length = unit(0.15, \"inches\")),\n    size = 0.9, color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  facet_wrap(~Type, scales = \"free_y\", labeller = lblr),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  theme(\n    plot.title = element_text(face = \"plain\"),\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\")\n  ),\n  labs(y = \"log2(Proportion)\"),\n  # Corrected = Observed - Mean relative efficiency\n  coord_cartesian(xlim = c(1, 2), clip = \"off\")\n)\np1 <- tb2 %>%\n  filter(Region == \"East\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"East\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Eastern genotypes: Bias causes sign error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"East\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\np2 <- tb2 %>%\n  filter(Region == \"West\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"West\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Western genotypes: Bias causes magnitude error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"West\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\n\n\n\n\n\np1 / p2 + \n  plot_annotation(\n    #> title = \"Effect of bias on Penicillium differential abundance\",\n    tag_levels = \"A\"\n  )\n\n\n\n\nThis ^ is my favorite so far\n\n\n\nTODO:\nChange y label to log2(value) and adding “proportion” to the two proportion facets\nChange back to “Calibrated proportion” and “Observed proportion”?\nSlightly increase spacing between patchwork panels (rows)\nSwap positions of calibrated and uncalibrated so that the equation is correct: Observed = Actual - Mean efficiency\nalternate approach using 2-d facet wrap:\n\n\nsymbol_labels <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n      #> Type == \"Mean relative efficiency\" & Region == \"East\" ~ \"Eastern\\ngenotypes\",\n      #> Type == \"Mean relative efficiency\" & Region == \"West\" ~ \"Western\\ngenotypes\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\nregion_labels <- yr %>%\n  filter(Type == \"Mean relative efficiency\") %>%\n  mutate(\n    text = case_when(\n      Region == \"East\" ~ \"Eastern genotypes\\n\\nBias causes\\nsign error\",\n      Region == \"West\" ~ \"Western genotypes\\n\\nBias causes\\nmagnitude error\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> geom_blank(data = yr, aes(y = y_min, x = factor(1))),\n  #> geom_blank(data = yr, aes(y = y_max, x = factor(1))),\n  geom_blank(data = yr.long, aes(y = value, x = 1)),\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  #> facet_wrap(~Type, scales = \"free_y\"),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  labs(y = \"log2(Proportion)\"),\n  # Calibrated = Observed - Mean relative efficiency\n  geom_text(\n    data = symbol_labels,\n    aes(y = y, label = text),\n    x = 2.9, color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  ),\n  geom_text(\n    data = region_labels,\n    aes(y = y, label = text),\n    x = 2.8, color = \"black\", size = 4.8, hjust = 0, vjust = 0.5,\n  ),\n  coord_cartesian(xlim = c(1, 2), clip = \"off\"),\n  theme(\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\"),\n    plot.margin = margin(r = 1.75, unit = \"in\")\n  )\n)\n\n# labeller assuming first col is region, second is type\nlblr <- function(labels) {\n  labels %>% pull(2) %>% as.character %>% list\n}\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  facet_wrap(Region~Type, scales = \"free_y\", \n    labeller = lblr\n    #> labeller = labeller(Region = NULL, .multi_line = FALSE),\n    #> strip.position = \"right\"\n  )\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.0 (2021-05-18)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-07-28                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.0     2021-05-19 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n broom            * 0.7.8      2021-06-24 [1] CRAN (R 4.1.0)                   \n bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n checkmate          2.0.0      2020-02-06 [1] CRAN (R 4.0.2)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.0)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.0)                   \n colorspace         2.0-2      2021-06-24 [1] CRAN (R 4.1.0)                   \n cowplot          * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n foreign            0.8-81     2020-12-22 [2] CRAN (R 4.1.0)                   \n Formula            1.2-4      2020-10-16 [1] CRAN (R 4.0.3)                   \n fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n GenomeInfoDb       1.28.0     2021-05-19 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.1      2021-04-23 [1] CRAN (R 4.1.0)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n Hmisc              4.5-0      2021-02-28 [1] CRAN (R 4.0.4)                   \n hms                1.1.0      2021-05-17 [1] CRAN (R 4.1.0)                   \n htmlTable          2.2.1      2021-05-18 [1] CRAN (R 4.1.0)                   \n htmltools          0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n htmlwidgets        1.5.3      2020-12-10 [1] CRAN (R 4.0.3)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jpeg               0.1-9      2021-07-24 [1] CRAN (R 4.1.0)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.33       2021-04-24 [1] CRAN (R 4.1.0)                   \n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.0)                   \n latticeExtra       0.6-29     2019-12-19 [1] CRAN (R 4.0.0)                   \n lifecycle          1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.0)                   \n Matrix             1.3-3      2021-05-04 [2] CRAN (R 4.1.0)                   \n metacal          * 0.2.0.9001 2021-07-16 [1] Github (mikemc/metacal@a7a87a1)  \n mgcv               1.8-35     2021-04-18 [2] CRAN (R 4.1.0)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.0)                   \n nnet               7.3-16     2021-05-03 [2] CRAN (R 4.1.0)                   \n nvimcom          * 0.9-102    2021-07-17 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.1      2021-05-16 [1] CRAN (R 4.1.0)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n png                0.1-7      2013-12-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                   \n readr            * 2.0.0      2021-07-20 [1] CRAN (R 4.1.0)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.0     2021-05-19 [1] Bioconductor                     \n rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                   \n rmarkdown        * 2.9        2021-06-15 [1] CRAN (R 4.1.0)                   \n rpart              4.1-15     2019-04-12 [2] CRAN (R 4.1.0)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.3      2021-07-16 [1] CRAN (R 4.1.0)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.0)                   \n tibble           * 3.1.3      2021-07-23 [1] CRAN (R 4.1.0)                   \n tidyr            * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.24       2021-06-15 [1] CRAN (R 4.1.0)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/index_files/figure-html5/unnamed-chunk-2-1.svg",
    "last_modified": "2021-10-25T15:24:55-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-11-12-leopold2020host-bias-sensitivity/",
    "title": "Exploring the effect of bias in Leopold and Busby (2020)\n",
    "description": {},
    "author": [
      {
        "name": "Michael McLaren",
        "url": {}
      }
    ],
    "date": "2020-11-10",
    "categories": [
      "bias sensitivity",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nSetup\nSample mean efficiency across samples\nAlt plot\nCheck errors in FCs\nmock samples\nExperiment samples\n\n\nSession info\n\nAnalysis of bias in Leopold and Busby (2020).\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9009'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 × 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.74   1.06\n2 Dioszegia        0.295   0.294  1.10\n3 Epicoccum        1.01    1.01   1.49\n4 Fusarium         3.07    3.08   1.13\n5 Penicillium      0.223   0.224  1.09\n6 Cladosporium     0.899   0.901  1.13\n7 Trichoderma      0.578   0.577  1.09\n8 Alternaria       1.47    1.47   1.08\n9 Aureobasidium    0.738   0.732  1.13\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 17 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\n\n\nrange(sme$SMRE)\n\n\n[1] 0.2236076 8.7034225\n\nrange(bias)\n\n\n[1] 0.2233792 8.7486819\n\n\n\np1 <- ggplot(sme, aes(SMRE, fill = Samp_type)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = \"Sample type\"\n  )\np1 +\n  plot_annotation(\n    title = \"Distribution of sample mean relative efficiencies\",\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nIn this case, the bimodal distribution is likely driven by the high proportion of Melampsora (pathogen) in ~half the samples.\nTODO: check this hypothesis. by making a histogram of melampspora %, and a scatterplot of the melamspora vs. SMRE. Can do with facet matrix from ggforce\n\n\nmel <- otu %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  psmelt %>%\n  select(-OTU, Melampsora = Abundance)\nsme0 <- left_join(sme, mel, by = \"Sample\")\n\n\n\n\n\n# p2 <- ggplot(sme0, aes(SMRE, fill = Melampsora)) +\np2 <- ggplot(sme0, aes(y = Melampsora, x = SMRE, color = Samp_type)) +\n  geom_point() +\n  # annotate(\"point\", y = 1, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  expand_limits(x = range(bias)) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\",\n    color = \"Sample type\"\n  )\np2\n\n\n\n\n\n\n(p1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.pdf\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\n\n\n\nNote, the high-Mel samples are the timepoint 2 samples, and were not used for some (all?) of his analysis due to the dominance of Mel. Let’s check this out,\n\n\nsme %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  ) %>%\n  # filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Treatment)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Region)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nCan see that Eastern genotypes more susceptible (more Mel and higher SME)\nAre some western genotypes less susceptible?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"West\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nEastern?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"East\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nAlt plot\nMight be better to just focus on the treated experimental samples; can note that the bimodal distribution in SMRE is due to the presence of Mel in the timepoint 2, and thus we’d mess up our AA inferences if we tried to infer the change in AA after Mel introduction. We might also (if were were analyzing timepoint 2 samples)\nActually, including the bias values serves the important purpose of showing how the SME varies less than the efficiencies. For that reason it could even be worth having the single-isolate samples, though seems unneeded.\nPoints\nSME varies less across samples than efficiencies vary across taxa\nSME much greater after rusting (timepoint 2) -> it will look like the growth of the pathogen suppressed the proportion and absolute abundance of the colonizers 5-6X more than it actually did\nThe Mel prop and hence the SME varies significantly in the timepoint 2 samples. This may lead to systematic errors in certain inferences. E.g., if host genotype affects Mel and another taxon, that other taxon’s value will be distorted (and, I think, the effect on Mel will be inflated).\nAs an example, think through the case of more resistant host genotypes\nMight also consider the taxa found to suppress Mel; see paper\n\n\n\np1.1 <- sme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\np2.1 <- sme0 %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(y = Melampsora, x = SMRE, color = Timepoint)) +\n  geom_point() +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    x = \"Mean efficiency\"\n  )\n\n\n\n\n\n(p1.1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2.1 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nTODO: Still need to determien if the y axis is accurate on histogram; I think its off when using pseudo-log. But perhaps can get away with linear?\nCheck errors in FCs\nWe can use this distribution to pick examples of samples where bias approximately cancels in the FC estimates (because their SMRE’s are similar), and samples where bias does not approximately cancel (because their SMRE’s are very different). Could do for mock samples (using the ground truth) or for natural samples (using the calibrated composition). Might as well do it both ways; not sure which would be best for a paper. The mocks have the benefit of knowing the ground truth, while the natural samples demonstrate practical significance. Also, we can give nice intuitive description of what we’re doing in the natural samples by saying that we’re comparing samples w/ low-low, high-high, or low-high pathogen %.\nTODO ^^\nmock samples\nTo pick from the mock samples:\n\n\nsme0 %>%\n  filter(Samp_type == \"Mock\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 10 × 5\n   Sample   SMRE Melampsora log10_SMRE     diff\n   <chr>   <dbl>      <dbl>      <dbl>    <dbl>\n 1 Mock.3  0.541    0.00782   -0.267   NA      \n 2 Mock.7  0.970    0.00761   -0.0132   0.254  \n 3 Mock.9  0.981    0.0116    -0.00824  0.00492\n 4 Mock.2  1.16     0.0524     0.0628   0.0711 \n 5 Mock.6  1.24     0.0435     0.0931   0.0303 \n 6 Mock.10 1.82     0.0948     0.261    0.168  \n 7 Mock.1  2.00     0.0540     0.301    0.0400 \n 8 Mock.4  2.12     0.164      0.327    0.0256 \n 9 Mock.8  2.20     0.134      0.343    0.0161 \n10 Mock.5  2.96     0.179      0.472    0.129  \n\nMock.3 -> Mock.5 have the biggest difference in SMRE. Notably, its still only a factor of 5.5 difference.\nMock.7 -> Mock.9 have the smallest log difference.\nNext: Compute the actual and observed FC in proportions, for each of these pairs of communities. Perhaps define a function to spit out the relevant data frame, given any pair of samples, the phyloseq object (or calibrated phyloseq object?), and the bias vector? Actually, for the mocks, should use the “actual” table instead of calibrated.\nUse these objects,\n\n\nmock_actual\n\n\nOTU Table:          [ 9 taxa and 10 samples ]:\nTaxa are columns\n           Melampsora Dioszegia Epicoccum Fusarium Penicillium\n 1 Mock.1      0.0538    0.0108    0.0108   0.269       0.0108\n 2 Mock.2      0.0538    0.269     0.269    0.0108      0.0108\n 3 Mock.3      0.0108    0.269     0.0538   0.0108      0.269 \n 4 Mock.4      0.269     0.0538    0.0108   0.0538      0.269 \n 5 Mock.5      0.269     0.0108    0.0108   0.269       0.0538\n 6 Mock.6      0.0538    0.0538    0.0538   0.0108      0.0108\n 7 Mock.7      0.0108    0.269     0.0538   0.269       0.269 \n 8 Mock.8      0.269     0.0108    0.269    0.0538      0.0538\n 9 Mock.9      0.0108    0.0538    0.269    0.0538      0.0538\n10 Mock.10     0.111     0.111     0.111    0.111       0.111 \n# … with 4 more taxa (columns)\n\nps.mock.pseudo\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 10 samples ]:\nsample_data() Sample Data:        [ 10 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nWe can use metacal::pairwise_ratios() to compute the FCs in abundances between all samples + for all taxa, given a phyloseq object.\n\n\nfcs <- list(Actual = mock_actual, Observed = ps.mock.pseudo) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = \"samples\", filter = FALSE) %>%\n  map_dfr(psmelt, .id = \"Type\") %>%\n  # redo sample.1 and sample.2 since missing for the mock\n  select(-sample.1, -sample.2) %>%\n  rename(Pair = Sample, Fold_change = Abundance) %>%\n  separate(Pair, str_c(\"Sample.\", 1:2), sep = \":\", remove = FALSE) %>%\n  mutate(across(OTU, factor, levels = bias %>% sort %>% names)) %>%\n  left_join(sme0 %>% select(Sample.1 = Sample, SMRE, Melampsora), \n    by = \"Sample.1\") %>%\n  left_join(sme0 %>% select(Sample.2 = Sample, SMRE, Melampsora), \n    by = \"Sample.2\", suffix = c(\".1\", \".2\"))\n\n\n\n\n\nfcs %>%\n  filter(Pair %in% c(\"Mock.5:Mock.3\", \"Mock.9:Mock.7\")) %>%\n  ggplot(aes(y = OTU, x = Fold_change, shape = Type, color = Type)) +\n  facet_grid(. ~ Pair) +\n  scale_shape_manual(values = c(Actual = 3, Observed = 1)) +\n  scale_color_brewer(type = \"qual\", palette = 6) +\n  geom_vline(xintercept = 1, color = \"black\", size = 0.2) +\n  geom_point(size = 2) +\n  theme_minimal_hgrid() +\n  scale_x_log10(limits = c(3e-3, 1e2), oob = scales::squish) +\n  labs(x = \"Fold change in proportion\") +\n  plot_annotation(\n    title = \"Actual and observed fold changes between pairs of mocks\"\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020-fc-mock-examples.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nCan see that on the left, the error is positive for all taxa, and of a similar magnitude (on the order of ~6X, as predicted) for all taxa except for Epicoccum, which dropped out during sequencing in Mock.5; and on the right, the error is smaller and not consistently positive or negative. Sign errors correspond to the observed and actual fold changes being on opposing sides of the vertical red line at 1.\ntodo: add the SMRE changes to the facet labels, and perhaps mark the expected\nWhat other types of plots, which might use all pairs of samples?\nwe could plot the observed vs. predicted error\nwe could check that the error really is taxon independent; one way to do this is to calc the correlation in LFC between observed and actual\n\n\nlvls <- sme0 %>% arrange(SMRE) %>% pull(Sample)\nfcs0 <- fcs %>%\n  # filter(Sample.1 < Sample.2) %>%\n  select(Type:Fold_change, SMRE.1:Melampsora.2) %>%\n  pivot_wider(names_from = Type, values_from = Fold_change) %>%\n  mutate(across(c(Sample.1, Sample.2), factor, levels = lvls))\n\n\n\n\n\nfcs0 %>%\n  filter(as.integer(Sample.1) < as.integer(Sample.2)) %>%\n  ggplot(aes(Actual, Observed, color = OTU)) +\n  geom_abline(color = \"grey\") +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_log10() +\n  facet_grid(Sample.1 ~ Sample.2) +\n  scale_color_brewer(type = \"qual\", palette = 3)\n\n\n\n\nNote how (especially) for Mock 1 and 6, the points follow a straight line with a greater slope than predicted. This seems likely related to the systematic deviation from the model that I observed.\nCheck that there is indeed very high correlations; remove the Epicoccum Mock-5 dropout first to avoid major distortions just from that.\n\n\ncorrs <- fcs0 %>%\n  filter(\n    Sample.1 != Sample.2,\n    !((Sample.1 == \"Mock.5\" | Sample.2 == \"Mock.5\") & OTU == \"Epicoccum\")\n  ) %>%\n  mutate(across(c(Actual, Observed), log10)) %>%\n  group_by(Pair) %>%\n  summarize(correlation = cor(Actual, Observed, method = \"pearson\"))\ncorrs %>% pull(correlation) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.9637  0.9827  0.9894  0.9874  0.9929  0.9989 \n\n# qplot(corrs$correlation)\n\n\n\nExperiment samples\nWe could just try picking a high and low Melampsora sample - perhaps from the mode of the peaks, rather than the extreme.\n\n\nsme0 %>%\n  filter(Samp_type == \"Experiment\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 548 × 5\n   Sample         SMRE Melampsora log10_SMRE       diff\n   <chr>         <dbl>      <dbl>      <dbl>      <dbl>\n 1 G12.T6.R4.TP1 0.996  0.00182     -0.00185 NA        \n 2 G1.T5.R2.TP1  1.24   0.0000218    0.0939   0.0958   \n 3 G11.T2.R4.TP1 1.24   0.0000836    0.0951   0.00114  \n 4 G12.T1.R2.TP1 1.28   0.0000166    0.108    0.0128   \n 5 G12.T2.R4.TP1 1.28   0.0000309    0.108    0.000619 \n 6 G11.T3.R3.TP1 1.29   0.000253     0.110    0.00119  \n 7 G2.T2.R4.TP1  1.29   0.0000220    0.110    0.000570 \n 8 G8.T4.R1.TP1  1.29   0.0000132    0.110    0.0000354\n 9 G9.T5.R3.TP1  1.29   0.0000714    0.110    0.000185 \n10 G4.T6.R3.TP1  1.29   0.000197     0.112    0.00139  \n# … with 538 more rows\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ───────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       Arch Linux\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-02-07\n pandoc   2.14.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────\n package          * version    date (UTC) lib source\n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)\n ape                5.6-1      2022-01-07 [1] CRAN (R 4.1.2)\n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)\n backports          1.4.1      2021-12-13 [1] CRAN (R 4.1.2)\n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)\n Biobase            2.52.0     2021-05-19 [1] Bioconductor\n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor\n biomformat         1.20.0     2021-05-19 [1] Bioconductor\n Biostrings         2.60.2     2021-08-05 [1] Bioconductor\n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)\n broom            * 0.7.11     2022-01-03 [1] CRAN (R 4.1.2)\n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)\n cachem             1.0.6      2021-08-19 [1] CRAN (R 4.1.1)\n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)\n cli                3.1.1      2022-01-20 [1] CRAN (R 4.1.2)\n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.2)\n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.2)\n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)\n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.2      2021-10-29 [1] CRAN (R 4.1.1)\n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI                1.1.2      2021-12-20 [1] CRAN (R 4.1.2)\n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)\n digest             0.6.29     2021-12-01 [1] CRAN (R 4.1.2)\n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)\n downlit            0.4.0      2021-10-29 [1] CRAN (R 4.1.2)\n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)\n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)\n fansi              1.0.2      2022-01-14 [1] CRAN (R 4.1.2)\n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)\n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)\n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)\n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)\n fs                 1.5.2      2021-12-08 [1] CRAN (R 4.1.2)\n generics           0.1.2      2022-01-31 [1] CRAN (R 4.1.2)\n GenomeInfoDb       1.28.4     2021-09-05 [1] Bioconductor\n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor\n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)\n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)\n glue               1.6.1      2022-01-22 [1] CRAN (R 4.1.2)\n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)\n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)\n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)\n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)\n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)\n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)\n igraph             1.2.11     2022-01-04 [1] CRAN (R 4.1.2)\n IRanges            2.26.0     2021-05-19 [1] Bioconductor\n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)\n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)\n jsonlite           1.7.3      2022-01-17 [1] CRAN (R 4.1.2)\n knitr              1.37       2021-12-16 [1] CRAN (R 4.1.2)\n lattice            0.20-45    2021-09-22 [2] CRAN (R 4.1.2)\n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)\n magrittr           2.0.2      2022-01-26 [1] CRAN (R 4.1.2)\n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.2)\n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.2)\n memoise            2.0.1      2021-11-26 [1] CRAN (R 4.1.2)\n metacal          * 0.2.0.9009 2022-01-30 [1] Github (mikemc/metacal@5154eeb)\n mgcv               1.8-38     2021-10-06 [2] CRAN (R 4.1.2)\n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)\n multtest           2.48.0     2021-05-19 [1] Bioconductor\n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)\n nlme               3.1-153    2021-09-07 [2] CRAN (R 4.1.2)\n nvimcom          * 0.9-102    2021-11-12 [1] local\n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)\n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)\n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor\n pillar             1.6.5      2022-01-25 [1] CRAN (R 4.1.2)\n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)\n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)\n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)\n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n ragg               1.2.1      2021-12-06 [1] CRAN (R 4.1.2)\n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)\n Rcpp               1.0.8      2022-01-13 [1] CRAN (R 4.1.2)\n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)\n readr            * 2.1.1      2021-11-30 [1] CRAN (R 4.1.2)\n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)\n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)\n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)\n rhdf5              2.36.0     2021-05-19 [1] Bioconductor\n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor\n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor\n rlang              1.0.1      2022-02-03 [1] CRAN (R 4.1.2)\n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)\n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)\n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)\n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)\n S4Vectors          0.30.2     2021-10-03 [1] Bioconductor\n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)\n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)\n sessioninfo        1.2.2      2021-12-06 [1] CRAN (R 4.1.2)\n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.6      2021-11-29 [1] CRAN (R 4.1.2)\n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)\n survival           3.2-13     2021-08-24 [2] CRAN (R 4.1.2)\n systemfonts        1.0.3      2021-10-13 [1] CRAN (R 4.1.1)\n textshaping        0.3.6      2021-10-13 [1] CRAN (R 4.1.1)\n tibble           * 3.1.6      2021-11-07 [1] CRAN (R 4.1.2)\n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)\n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)\n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)\n tzdb               0.2.0      2021-10-27 [1] CRAN (R 4.1.2)\n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)\n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)\n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)\n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)\n withr              2.4.3      2021-11-30 [1] CRAN (R 4.1.2)\n xfun               0.29       2021-12-14 [1] CRAN (R 4.1.2)\n xml2               1.3.3      2021-11-30 [1] CRAN (R 4.1.2)\n XVector            0.32.0     2021-05-19 [1] Bioconductor\n yaml               2.2.2      2022-01-25 [1] CRAN (R 4.1.2)\n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor\n\n [1] /home/michael/.local/lib/R/library\n [2] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2020-11-12-leopold2020host-bias-sensitivity/index_files/figure-html5/unnamed-chunk-3-1.svg",
    "last_modified": "2022-02-08T08:58:02-05:00",
    "input_file": {}
  }
]
