[
  {
    "path": "posts/2021-10-27-illustrate-the-problem/",
    "title": "Illustrate the basic problem",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-27",
    "categories": [
      "ref:brooks2015thet",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nR setup\nBrooks et al\nSetup\nPlots\n\nLeopold and Busby 2020\nSetup\nPlots\n\nSession info\n\nR setup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\nBrooks et al\nSetup\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\nLoad data from the cellular mock communities of Brooks et al 2015 from metacal,\n\n\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n\n\nNote that the single-species samples present.\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nPlots\nIdea is to focus on a single species and show that the error in log proportions is inconsistent, and therefore there is error in the fold changes. L. crispatus is a species MM and BC commonly use to illustrate the inconsistent error, as since it has an intermediate efficiency, we see its error varying in sign/direction. However, the errors in fold changes don’t depend on this aspect, but only the variation in mean efficiency, and is therefore the same for all species.\nData frame for comparing measured and actual proportions:\n\n\nbrooks_prop <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nbrooks_fc <- list(\n  Actual = actual, \n  Measured = observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\n\n\nset.seed(42)\nspecies <- 'Lactobacillus_crispatus'\n\nsamples <- actual %>%\n  as_tibble %>%\n  filter(.otu == species, .abundance > 0) %>%\n  pull(.sample)\n\np1 <- brooks_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- brooks_fc %>%\n  filter(.otu == species, sample1 %in% samples, sample2 %in% samples) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n# p2\n\n\n\n\n\n(p1 + labs(x = 'Actual', y = 'Measured', title = 'Proportion')) + \n  (p2 + labs(x = 'Actual', y = 'Measured', title = 'Fold change')) + \n  plot_annotation(tag_levels = 'A')\n\n\n\n\nLeopold and Busby 2020\nThis dataset is for DNA mocks rather than cellular mocks; however the magnitude of bias is similar. This dataset has a couple advantages for illustration purposes:\nEach species has a wider range of actual proportions than in the Brooks dataset.\nThe ratios between species varies, whereas in the Brooks dataset it is always 1:1. \nSetup\n\n\n## From the metacal 2.0 tutorial\n# Download data from https://zenodo.org/record/3872145\ndata_path <- here::here(\"notebook/_data\", \"leopold2020host\")\n# To use a temporary directory:\n# data_path <- file.path(tempdir(), \"leopold2020\")\nif (!dir.exists(data_path)) {\n  dir.create(data_path, recursive = TRUE)\n  download.file(\n    \"https://zenodo.org/record/3872145/files/dleopold/Populus_priorityEffects-v1.2.zip\",\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\")\n  )\n  unzip(\n    file.path(data_path, \"Populus_priorityEffects-v1.2.zip\"), \n    exdir = data_path\n  )\n}\n#> The microbiome data is stored in a phyloseq object,\nps <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/output/compiled/phy.rds\") %>%\n  readRDS\n\nsample_data(ps) <- sample_data(ps) %>%\n  transform(\n    Timepoint = factor(Timepoint)\n  )\n\nmock_actual <- file.path(data_path, \n  \"dleopold-Populus_priorityEffects-8594f7c/data/MockCommunities.csv\") %>%\n  read.csv(row.names = 1) %>%\n  select(-Sym4) %>%\n  as(\"matrix\") %>%\n  otu_table(taxa_are_rows = FALSE) %>%\n  transform_sample_counts(function(x) close_elts(1 / x))\nmock_taxa <- taxa_names(mock_actual)\nsam <- sample_data(ps) %>% as(\"data.frame\") %>% as_tibble(rownames = \"Sample\")\ntax <- tax_table(ps) %>% as(\"matrix\") %>% as_tibble(rownames = \"Taxon\")\nps.mock <- ps %>% \n  subset_samples(Samp_type == \"Mock\") %>%\n  prune_taxa(mock_taxa, .)\nleopold_actual <- mock_actual\nleopold_observed <- ps.mock %>% otu_table\nrm(mock_actual, mock_taxa, sam, tax, ps.mock)\n\n\n\nPlots\n\n\nleopold_prop <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance)\n\nleopold_fc <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2)\n\n\n\nNote, in this case all species are (nominally) in all samples, but that Epicoccum is observed in 0 reads in one sample.\n\n\nspecies <- 'Cladosporium'\n# species <- 'Alternaria'\n# species <- 'Trichoderma'\n\np1 <- leopold_prop %>%\n  filter(.otu == species, Actual > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual proportion', y = 'Measured proportion', color = 'Species') +\n  theme(legend.position = 'none')\np2 <- leopold_fc %>%\n  filter(.otu == species) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\np1 + p2\n\n\n\n\nSame but for the ratios between two species:\n\n\nx <- list(\n  Actual = leopold_actual, \n  Measured = leopold_observed\n) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = 'taxa', filter = FALSE)\n\nleopold_ratio <- x %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  filter(otu1 != otu2)\n\nleopold_ratio_fc <- x %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type') %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  separate(.otu, c('otu1', 'otu2'), sep = ':') %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(otu1 != otu2, sample1 != sample2)\n\n\n\n\n\nspecies1 <- 'Cladosporium'\nspecies2 <- 'Fusarium'\n# species2 <- 'Melampsora'\n# species <- 'Trichoderma'\n\np3 <- leopold_ratio %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  expand_limits(x = 0.1, y = 0.1) +\n  labs(x = 'Actual ratio', y = 'Measured ratio', color = 'Species') +\n  theme(legend.position = 'none')\np4 <- leopold_ratio_fc %>%\n  filter(otu1 == species1, otu2 == species2) %>%\n  ggplot(aes(Actual, Measured)) +\n  # scale_color_manual(values = colors_brooks) +\n  scale_x_log10() +\n  # scale_y_custom +\n  scale_y_log10() +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(width = 0.02, height = 0.02), alpha = 0.5) +\n  # geom_quasirandom() +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'none')\n\n\n\n\n\n(p1 + p2) / (p3 + p4)\n\n\n\n\nNote, the ratio-view isn’t always obviously better; e.g. when Mel is involved; perhaps because of noise?\nTo make things more directly comparable, it might be best to use faceting and to fix the axes to have the same span.\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.1 (2021-08-10)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-10-27                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-18     2021-09-16 [1] CRAN (R 4.1.1)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.1     2021-06-06 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n bookdown           0.24       2021-09-02 [1] CRAN (R 4.1.1)                   \n broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                   \n bslib              0.3.1      2021-10-06 [1] CRAN (R 4.1.1)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                   \n colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                \n cowplot          * 1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)\n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                   \n distill            1.3        2021-10-13 [1] CRAN (R 4.1.1)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs               * 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.1      2021-10-25 [1] CRAN (R 4.1.1)                   \n GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                   \n htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.7      2021-10-15 [1] CRAN (R 4.1.1)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                   \n lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                   \n lubridate          1.8.0      2021-10-07 [1] CRAN (R 4.1.1)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                   \n Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                   \n metacal          * 0.2.0.9005 2021-10-04 [1] Github (mikemc/metacal@773cbf3)  \n mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                   \n nvimcom          * 0.9-102    2021-10-25 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.4      2021-10-18 [1] CRAN (R 4.1.1)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.5   2021-09-17 [1] CRAN (R 4.1.1)                   \n readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                     \n rlang              0.4.12     2021-10-18 [1] CRAN (R 4.1.1)                   \n rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.2      2021-10-16 [1] CRAN (R 4.1.1)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales           * 1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                   \n tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                   \n tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.27       2021-10-18 [1] CRAN (R 4.1.1)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-10-27-illustrate-the-problem/illustrate-the-problem_files/figure-html5/brooks_lcrisp_prop_and_fc-1.svg",
    "last_modified": "2021-10-27T09:28:34-04:00",
    "input_file": "illustrate-the-problem.knit.md"
  },
  {
    "path": "posts/2021-10-25-brooks2015thet-calibration/",
    "title": "Illustrate calibration types in the mock communities from Brooks et al (2015)",
    "description": {},
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-10-25",
    "categories": [
      "ref:brooks2015thet"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\nlibrary(fs)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\nlibrary(scales)\ntheme_set(theme_cowplot())\n# stats helpers\n# library(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9005'\n\n\n\ncolors_brooks <- c(\n  \"Atopobium_vaginae\" = \"#009E73\",\n  \"Gardnerella_vaginalis\" = \"#56B4E9\",\n  \"Lactobacillus_crispatus\" = \"#D55E00\",\n  \"Lactobacillus_iners\" = \"#505050\",\n  \"Prevotella_bivia\" = \"#0072B2\",\n  \"Sneathia_amnii\" = \"#CC79A7\",\n  \"Streptococcus_agalactiae\" = \"#E69F00\")\n\nscale_y_custom <- scale_y_continuous(\n    trans = 'log10',\n    breaks = trans_breaks('log10', function(x) 10^x),\n    labels = trans_format('log10', math_format(10^.x))\n  )\n\n\n\n\n\n# Load data from the cellular mock communities of Brooks et al 2015\ndr <- system.file(\"extdata\", package = \"metacal\")\nlist.files(dr)\n\n\n[1] \"brooks2015-actual.csv\"      \"brooks2015-observed.csv\"   \n[3] \"brooks2015-sample-data.csv\"\n\nactual <- file.path(dr, \"brooks2015-actual.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  otu_table(taxa_are_rows = FALSE)\nobserved <- file.path(dr, \"brooks2015-observed.csv\") |>\n  read.csv(row.names = \"Sample\") |>\n  subset(select = - Other) |>\n  otu_table(taxa_are_rows = FALSE)\n\n# Estimate bias with bootstrapping for error estimation\nmc_fit <- estimate_bias(observed, actual, boot = TRUE)\ncontrol_species <- mc_fit %>% coef %>% names\nsummary(mc_fit)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 7 × 4\n  taxon                    estimate gm_mean gm_se\n  <chr>                       <dbl>   <dbl> <dbl>\n1 Atopobium_vaginae           0.285   0.285  1.04\n2 Gardnerella_vaginalis       0.160   0.160  1.05\n3 Lactobacillus_crispatus     2.29    2.29   1.03\n4 Lactobacillus_iners         4.68    4.69   1.02\n5 Prevotella_bivia            1.79    1.78   1.04\n6 Sneathia_amnii              4.59    4.59   1.04\n7 Streptococcus_agalactiae    0.250   0.250  1.03\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\nare the single-species samples present?\n\n\nactual %>% \n  as_tibble %>%\n  filter(.abundance == 1) %>%\n  count(.otu)\n\n\n# A tibble: 7 × 2\n  .otu                         n\n  <chr>                    <int>\n1 Atopobium_vaginae            2\n2 Gardnerella_vaginalis        1\n3 Lactobacillus_crispatus      1\n4 Lactobacillus_iners          1\n5 Prevotella_bivia             1\n6 Sneathia_amnii               1\n7 Streptococcus_agalactiae     2\n\nYes.\nCalibration\nCalibration from community control\nDemonstrate that calibration using a single mock community can create a substantial improvement.\n\n\nsmpls <- actual %>%\n  as_tibble %>%\n  with_groups(.sample, summarize, n_species = sum(.abundance > 0)) %>%\n  filter(n_species == 7) %>%\n  pull(.sample)\n\n\n\n\n\ncontrol_samples <- smpls[1]\nbias_from_control <- estimate_bias(\n  observed %>% prune_samples(control_samples, .),\n  actual %>% prune_samples(control_samples, .),\n  ) %>%\n  coef\ncalibrated <- calibrate(observed, bias_from_control)\n\n\n\nCalibration using a reference species\nOne way to do this is to get the correction for each pair of samples, then join it with the table from previous. Another is to make the calibrated OTU table, then redo the pairwise ratio stuff.\nBasic Idea: Multiply the ratio of focal to ref species by the true proportion of the ref. One way to achieve this with phyloseq objects is to construct the correction matrix, then multiply this by the observed proportions\n\n\nref_species <- 'Lactobacillus_crispatus'\n\nref_actual <- actual %>% prune_taxa(ref_species, .) %>% c\nref_observed <- observed %>% prune_taxa(ref_species, .) %>% c\n\ncorrection_matrix <- matrix(\n  ref_actual / ref_observed, \n  nrow = nsamples(observed), ncol= ntaxa(observed),\n  byrow = FALSE\n)\n\ncalibrated_ref <- otu_table(observed * correction_matrix, taxa_are_rows = FALSE)\n\n\n\nPlot comparing calibrated and uncalibrated fold changes\n\n\nx <- list(\n  Actual = actual, \n  Uncalibrated = observed %>% transform_sample_counts(close_elts),\n  Calibrated_community = calibrated,\n  Calibrated_reference = calibrated_ref\n  ) %>%\n  map(pairwise_ratios, margin = 'samples', filter = FALSE) %>%\n  map_dfr(as_tibble, .id = 'type')\n\n\n\n\n\nlvls <- mc_fit %>% coef %>% sort %>% names\n\nbrooks2015_fcs <- x %>%\n  pivot_wider(names_from = type, values_from = .abundance) %>%\n  pivot_longer(contains('calibrated'), \n    names_to = 'type', values_to = 'Measured'\n  ) %>%\n  separate(.sample, c('sample1', 'sample2'), sep = ':') %>%\n  # Filter to remove cases where Actual is 0 in one or both samples, or where\n  # the numerator and denominator sample are equal\n  filter(is.finite(Actual), Actual != 0, sample1 != sample2) %>%\n  mutate(\n    across(type, fct_relevel, 'Uncalibrated'),\n    across(\n      type, fct_recode,\n      'Calibrated (community)' = 'Calibrated_community',\n      'Calibrated (reference)' = 'Calibrated_reference'\n      ),\n    across(.otu, factor, levels = rev(lvls)),\n    # across(.otu, fct_relabel, adjust_species_names)\n  )\n\n\n\nCheck on number of rows in these data frames,\n\n\n# expected in 'x'\nn1 <- observed %>% nsamples %>% print\n\n\n[1] 80\n\nn2 <- observed %>% ntaxa\nall.equal(n1 * n1 * n2 * 4, x %>% nrow)\n\n\n[1] TRUE\n\nx %>% nrow\n\n\n[1] 179200\n\nbrooks2015_fcs %>% nrow\n\n\n[1] 17586\n\nLet’s plot just the sample-pairs with L. crispatus present, so that the same samples are shown in all panels.\n\n\n# Find subset of pairs to plot\nsample_pairs <- brooks2015_fcs %>%\n  filter(is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  select(sample1, sample2) %>%\n  unite(pair, sample1, sample2) %>%\n  distinct %>%\n  pull(pair)\n\n# Species labels\nspecies_label <- function(species) {\n  species %>%\n    str_replace('(?<=^[A-Z])[a-z]+_', '. ')\n}\nspecies_label(lvls)\n\n\n[1] \"G. vaginalis\"  \"S. agalactiae\" \"A. vaginae\"    \"P. bivia\"     \n[5] \"L. crispatus\"  \"S. amnii\"      \"L. iners\"     \n\np <- brooks2015_fcs %>%\n  unite(pair, sample1, sample2) %>%\n  filter(pair %in% sample_pairs, is.finite(Actual), Actual > 0, is.finite(Measured), Measured > 0) %>%\n  ggplot(aes(Actual, Measured, color = .otu)) +\n  scale_color_manual(\n    values = colors_brooks, \n    labels = species_label(colors_brooks %>% names)\n  ) +\n  facet_wrap(~type) +\n  scale_x_log10() +\n  scale_y_custom +\n  geom_abline(color = 'grey', size = 1) +\n  geom_point(position = position_jitter(), alpha = 0.5) +\n  coord_fixed() +\n  labs(x = 'Actual fold change', y = 'Measured fold change', color = 'Species') +\n  theme(legend.position = 'bottom')\np\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-10-25-brooks2015thet-calibration/brooks2015thet-calibration_files/figure-html5/brooks2015thet_fc_calibration-1.png",
    "last_modified": "2021-10-25T19:29:51-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-18-evaluate-robustness-example/",
    "title": "Evaluate robustness example",
    "description": "Evaluate the robustness of an estimate and inference to bias.",
    "author": [
      {
        "name": "Amy D. Willis",
        "url": {}
      }
    ],
    "date": "2021-10-18",
    "categories": [
      "bias sensitivity",
      "ref:callahan2017repl"
    ],
    "contents": "\n\nContents\nRobustness of an analysis to bias\nExample: relative abundance of Gardnerella\n\nData setup\nSession info\n\nRobustness of an analysis to bias\nWe can investigate the sensitivity of any analysis to taxonomic bias by simulating possible efficiency vectors, calibrating our observed MGS measurements by these efficiencies, and rerunning our analysis on the simulated and calibrated data. Specifically, we can take the observed proportion of each species in our dataset \\(\\hat{\\text{prop}}_{i}(a)\\), and “undo” the efficiencies to obtain the calibrated proportions \\[\\begin{align}\n  \\text{calibrated prop}_{i}(a)\n  &= \\left( \\frac{\\hat{\\text{prop}}_{i}(a)}{\\text{efficiency}_{i}} \\right) \\bigg / \\sum_{i'} \\left( \\frac{\\hat{\\text{prop}}_{i'}(a)}{\\text{efficiency}_{i'}} \\right),\n\\end{align}\\] and the calibrated read counts \\[\\begin{align}\n  \\text{reads}_{i}(a)\n  &= \\text{total reads}(a) \\times \\text{calibrated prop}_{i}(a).\n\\end{align}\\] We can then rerun our data analysis using the calibrated read counts in place of our original data. If we do this repeatedly, each time using different realizations of the efficiency vector, we can investigate how the results of our analysis change. If the change is minimal, this suggests that our results are robust to unequal detection efficiencies in the different species. The converse would suggest that we need to be careful interpreting our results.\nExample: relative abundance of Gardnerella\nWe illustrate this method using vaginal microbiome data from pregnant women published in a study by Callahan et al. (2017) seeking to replicate associations of specific genera (Lactobacillus, Gardnerella, and Ureaplasma) with preterm birth in two cohorts. For example, suppose we are interested in investigating if the genus Gardnerella is more abundant in the vaginal microbiome of women who give birth preterm, and we investigate this model by running corncob using preterm birth as a covariate in the mean and dispersion model. We could investigate the robustness of our findings using the following structure:\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n\nIn brief, this approach uses the library simulator to generate random efficiencies and “undo” them as described above, then runs corncob on these generated datasets before finally obtaining the estimated coefficients on preterm birth and the p-value for the hypothesis test that the coefficient on preterm birth is zero. Let’s take a look at the components of the code.\nFirst, we load the relevant libraries and our data (see Data setup),\n\n\n# library(here)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(speedyseq)\nlibrary(corncob)\n# devtools::install_github(\"jacobbien/simulator\")\nlibrary(simulator)\ncal <- readRDS(\n  here::here(\"notebook/_data\", \"callahan2017repl\", \"callahan2017repl_phyloseq_clean.rds\")\n)\n\n\n\nThen we can create the function that generates random efficiencies and accordingly alters the observed counts:\n\n\nundo_efficiencies <- function(ps, sig_sq_e) {\n\n  ps_ms <- ps %>% group_by(.sample) %>% mutate(mm = sum(.abundance)) %>% ungroup\n  ps_tax <- ps %>% select(`.otu`, `kingdom`:`species`) %>% distinct %>% tax_table\n  ps_sample <- ps %>% select(`.sample`, `subject_id`:`outcome`) %>% distinct %>% sample_data\n\n  new_model(name = \"eff_undo\", label = sprintf(\"sig_sq_e = %s\", sig_sq_e),\n            params = list(ps_ms = ps_ms, ps_tax = ps_tax, ps_sample = ps_sample, sig_sq_e = sig_sq_e),\n            simulate = function(ps_ms, ps_tax, ps_sample, sig_sq_e, nsim) {\n              replicate(nsim,\n                        {\n                          effs_tib <- ps_ms %>%\n                            select(genus) %>% distinct %>%\n                            mutate(\"efficiency\" = rnorm(nrow(.), mean = 0, sd = sqrt(sig_sq_e)) %>% exp)\n\n                          ps_tib <- ps_ms %>%\n                            full_join(effs_tib) %>%\n                            group_by(.sample) %>%\n                            mutate(p_ijs = (.abundance / efficiency) / sum(.abundance / efficiency)) %>%\n                            mutate(w_ij = round(mm * p_ijs)) %>%\n                            ungroup\n\n                          phyloseq(ps_tib %>%\n                                     select(`.otu`, `.sample`, `w_ij`) %>%\n                                     pivot_wider(names_from=`.otu`, values_from=`w_ij`) %>%\n                                     otu_table(taxa_are_rows = F),\n                                   ps_tax,\n                                   ps_sample) %>%\n                            tax_glom(\"genus\")\n                        },\n                        simplify=F)\n            })\n}\n\n\n\nNext, we specify how we use our data to construct our estimates. We are using bbdml from the library corncob to model the relative abundance of ASV 8 (Gardnerella) using preterm birth as a covariate to model the mean and dispersion, but this is only one type of analysis that we might be interested in.\n\n\ncorncob_Gardnerella <- new_method(\"corncob\", \"Corncob\",\n                               method = function(model, draw) {\n\n                                 fit <- bbdml(formula = ASV8 ~ preterm,\n                                              formula_null= ~1,\n                                              phi.formula= ~ preterm,\n                                              phi.formula_null= ~1,\n                                              data = draw %>%\n                                                merge_samples2(\"subject_id\", fun_otu = sum))\n\n                                 list(fit = fit,\n                                      summary = summary(fit))\n                               })\n\n\n\nFinally, we construct methods to obtain the estimated coefficient on preterm birth in the mean relative abundance model, and its p-value.\n\n\nbetahat_fit <- new_metric(\"betahat\", \"beta-hat\",\n metric = function(model, out) {\n   out$summary$coefficients[2,1]\n })\npvalue_fit <- new_metric(\"pvalue\", \"p-value\",\n                         metric = function(model, out) {\n                           out$summary$coefficients[2,4]\n                         })\n\n\n\nNow that we have all of the pieces, we can run them together as follows. The below code runs 100 simulations split across 4 cores; for testing, the commented code runs just 4 iterations.\n\n\nour_sim <- new_simulation(\"UndoGardnerella\", \"Undo Gardnerella relative abundance\") %>%\n  generate_model(undo_efficiencies,\n                 ps = cal %>%\n                   filter_sample_data(cohort == \"Stanford\") %>%\n                   tax_glom(\"genus\") %>%\n                   as_tibble,\n                 sig_sq_e = as.list(seq(0, 5, length.out = 6)),\n                 vary_along = \"sig_sq_e\") %>%\n  # simulate_from_model(nsim = 4, index = 1) %>%\n  # run_method(list(corncob_Gardnerella)) %>%\n  simulate_from_model(nsim = 25, index = 1:4) %>%\n  run_method(list(corncob_Gardnerella),\n             parallel = list(socket_names = 4, libraries = c(\"corncob\", \"speedyseq\"))) %>%\n  evaluate(list(betahat_fit, pvalue_fit))\n\n\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/model.Rdata\n#> ..Created model and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/model.Rdata\n#> ..Simulated 25 draws in 6.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r1.Rdata\n#> ..Simulated 25 draws in 5.37 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r2.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r3.Rdata\n#> ..Simulated 25 draws in 5.73 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0/r4.Rdata\n#> ..Simulated 25 draws in 8.59 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r1.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r2.Rdata\n#> ..Simulated 25 draws in 6.43 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r3.Rdata\n#> ..Simulated 25 draws in 6.47 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1/r4.Rdata\n#> ..Simulated 25 draws in 7.25 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r1.Rdata\n#> ..Simulated 25 draws in 6.77 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r2.Rdata\n#> ..Simulated 25 draws in 5.97 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r3.Rdata\n#> ..Simulated 25 draws in 6.62 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2/r4.Rdata\n#> ..Simulated 25 draws in 7.09 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r1.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r2.Rdata\n#> ..Simulated 25 draws in 6.12 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r3.Rdata\n#> ..Simulated 25 draws in 5.89 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3/r4.Rdata\n#> ..Simulated 25 draws in 5.66 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r1.Rdata\n#> ..Simulated 25 draws in 5.49 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r2.Rdata\n#> ..Simulated 25 draws in 5.31 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r3.Rdata\n#> ..Simulated 25 draws in 5.28 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4/r4.Rdata\n#> ..Simulated 25 draws in 5.67 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r1.Rdata\n#> ..Simulated 25 draws in 6.16 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r2.Rdata\n#> ..Simulated 25 draws in 5.3 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r3.Rdata\n#> ..Simulated 25 draws in 5.54 sec and saved in eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5/r4.Rdata\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_0\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_1\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_2\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_3\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_4\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Performed Corncob in 0.15 seconds (on average over 25 sims)\n#> ..Created \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 1, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 2, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 3, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> new(\"OutputRef\", dir = \"/home/michael/research/differential-abundance-theory/notebook/_posts/2021-10-18-evaluate-robustness-example\", model_name = \"eff_undo/ps_63d55ce90e7c2b5932d2349d0790c865933f3e0d/sig_sq_e_5\", index = 4, method_name = \"corncob\", out_loc = \"out\", simulator.files = \"files\") \n#> in parallel.\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n#> ..Evaluated Corncob in terms of \n#> beta-hat, p-value, Computing time (sec)\n\nHere’s how the estimated coefficient on preterm birth changes under different draws from a distribution given by \\(\\text{efficiency}_{i} \\overset{iid}{\\sim} \\text{LogNormal}(0, \\sigma^2_e)\\), and how the p-value for testing the null hypothesis that the coefficient on preterm birth is zero:\n\n\nev_df <- our_sim %>% evals %>% as.data.frame\nmodel_df <- our_sim %>% model %>% as.data.frame\nev_with_model_params <- dplyr::right_join(model_df, ev_df, by = c(\"name\" = \"Model\")) %>% tibble\nf_names <- list('p-value' = \"p-value\",\n                'beta-hat' = expression(hat(beta)))\nf_labeller <- function(variable, value){return(f_names[value])}\n\n\n\n\n\nev_with_model_params %>%\n  pivot_longer(cols = betahat:pvalue, names_to=\"eval\") %>%\n  mutate(eval = ifelse(eval == \"pvalue\", \"p-value\", \"beta-hat\")) %>%\n  ggplot(aes(x = sig_sq_e, group = sig_sq_e, y = value)) +\n  geom_boxplot() +\n  geom_abline(aes(slope = slope, intercept = intercept), color = \"blue\",\n              tibble(eval = c(\"p-value\", \"beta-hat\"), slope = c(0,0), intercept = c(0.05, 0))) +\n  xlab(expression(sigma[e]^2)) +\n  # ggtitle(\"Corncob results for testing\\nH0: Mean Gardnerella relative abundance is equal for preterm & full-term\") +\n  facet_wrap(~eval, scales=\"free_y\", nrow = 2, labeller = f_labeller) +\n  ylab(\"\") +\n  cowplot::theme_cowplot()\n\n\n\n\nWhile the estimate of the coefficient does not change on average, we see more variation in its estimate as the variation in the efficiencies increases. For some realizations from a model with large variation in the efficiencies, we even see a change in the sign of \\(\\hat{\\beta}\\) from positive to negative. Furthermore, we see a corresponding increase in the range of p-values, suggesting that more variation in the efficiencies can lead to either deattenuated estimates (larger p-values) or more precise non-zero estimates (smaller p-values).\nA major advantage of this approach is that any distribution of efficiency vectors can be investigated. For example, we could specifically investigate how Gardnerella being low- or high-efficiency impacts our results. We could also investigate more sophisticated distributions for the efficiencies, such as correlated efficiencies across phylogeny.\nData setup\nThe following code was used to download and prepare the data from Callahan et al. (2017) for analysis; it is not evaluated when this document is knit. The first code chunk downloads the ASV abundance matrix, sample metadata, and taxonomy assignments for the vaginal samples.\n\n\nlibrary(tidyverse)\nlibrary(speedyseq)\n\n# Download --------------------------------------------------------------------\ndl_path <- here::here(\"notebook/_data\", \"callahan2017repl\")\nlink <- \"https://stacks.stanford.edu/file/druid:yb681vm1809/RepRefine_Scripts.tar.gz\"\nif (!dir.exists(dl_path)) {\n  dir.create(dl_path)\n  download.file(link, file.path(dl_path, basename(link)))\n  system2(\"tar\", args = c(\"-xvf\", file.path(dl_path, basename(link)), \"-C\", dl_path))\n}\nload(file.path(dl_path, \"RepRefine_Scripts\", \"input\", \"processed.rda\"))\n# This loads:\n# df: the sample metadata\n# st: the sequence table (in counts)\n# ft: the sequence table normalized to frequencies / proportions\n# tax: taxonomy assignment matrix\n# \n# To confirm relationship between ft and st, run \n# all.equal(ft, st %>% apply(1, function(x) x / sum(x)) %>% t)\n# \n# The taxonomy matrix has an extra column with a duplicate name of \"Species\"\n# that is all NAs, so let's remove that\ntax <- tax[, -8]\n# Import into phyloseq --------------------------------------------------------\nsam <- sample_data(df)\nst <- otu_table(st, taxa_are_rows = FALSE)\ntax <- tax_table(tax)\nps <- phyloseq(sam, st, tax)\n# Check that all samples and taxa made it into the phyloseq object\nstopifnot(all.equal(colnames(st), taxa_names(ps)))\nstopifnot(all.equal(rownames(sam), sample_names(ps)))\n# Add ASV sequences to the refseq() slot\nseqs <- taxa_names(ps) %>% rlang::set_names() %>% Biostrings::DNAStringSet()\nps <- merge_phyloseq(ps, seqs)\n# Rename the ASVs to simpler names (ASV1, ASV2, ...). The full sequences remain\n# in `refseq(ps)`.\ntaxa_names(ps) <- paste0(\"ASV\", seq(ntaxa(ps)))\n# Clean up objects\nrm(tax, df, sam, st, ft, seqs)\n\n\n\nNext, we use munging functions from janitor and speedyseq to select the metadata of primary interest, standardize format of column names, and convert categorical variables to factors.\n\n\nps1 <- ps %>% \n  select_sample_data(SubjectID, Cohort, Race, preterm, Outcome) %>%\n  rename_with_sample_data(janitor::make_clean_names) %>%\n  rename_with_tax_table(janitor::make_clean_names) %>%\n  mutate_sample_data(\n    across(c(subject_id, cohort, race, outcome), factor),\n  )\n\n\n\nFinally, we save the phyloseq object for use in the analysis.\n\n\nsaveRDS(ps1, file.path(dl_path, \"callahan2017repl_phyloseq_clean.rds\"))\nrm(ps, ps1)\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.1 (2021-08-10)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-10-25                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package          * version    date       lib source                              \n#>  ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                      \n#>  ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                      \n#>  assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                      \n#>  backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  Biobase            2.52.0     2021-05-19 [1] Bioconductor                        \n#>  BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                        \n#>  biomformat         1.20.0     2021-05-19 [1] Bioconductor                        \n#>  Biostrings         2.60.1     2021-06-06 [1] Bioconductor                        \n#>  bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                      \n#>  bookdown           0.22       2021-04-22 [1] CRAN (R 4.1.0)                      \n#>  broom              0.7.9      2021-07-27 [1] CRAN (R 4.1.0)                      \n#>  bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                      \n#>  cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                      \n#>  cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                      \n#>  cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.1)                      \n#>  codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.1)                      \n#>  colorspace         2.0-2      2021-08-11 [1] R-Forge (R 4.1.1)                   \n#>  corncob          * 0.2.0      2021-03-11 [1] CRAN (R 4.0.5)                      \n#>  cowplot            1.1.1      2021-08-27 [1] Github (wilkelab/cowplot@555c9ae)   \n#>  crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                      \n#>  data.table         1.14.2     2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                      \n#>  dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                      \n#>  digest             0.6.28     2021-09-23 [1] CRAN (R 4.1.1)                      \n#>  distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                      \n#>  downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                      \n#>  dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                      \n#>  ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                      \n#>  fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                      \n#>  farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                      \n#>  fastmap            1.1.0      2021-01-25 [1] CRAN (R 4.0.4)                      \n#>  forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                      \n#>  foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                      \n#>  generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                      \n#>  GenomeInfoDb       1.28.1     2021-07-01 [1] Bioconductor                        \n#>  GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                        \n#>  ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                      \n#>  glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                      \n#>  gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                      \n#>  haven              2.4.3      2021-08-04 [1] CRAN (R 4.1.1)                      \n#>  here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                      \n#>  highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                      \n#>  hms                1.1.1      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  htmltools          0.5.2      2021-08-25 [1] CRAN (R 4.1.1)                      \n#>  httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                      \n#>  igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                      \n#>  IRanges            2.26.0     2021-05-19 [1] Bioconductor                        \n#>  iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                      \n#>  jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                      \n#>  jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                      \n#>  knitr              1.36       2021-09-29 [1] CRAN (R 4.1.1)                      \n#>  labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                      \n#>  lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.1)                      \n#>  lifecycle          1.0.1      2021-09-24 [1] CRAN (R 4.1.1)                      \n#>  lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                      \n#>  magrittr         * 2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                      \n#>  MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.1)                      \n#>  Matrix             1.3-4      2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  mgcv               1.8-36     2021-06-01 [2] CRAN (R 4.1.1)                      \n#>  modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                      \n#>  multtest           2.48.0     2021-05-19 [1] Bioconductor                        \n#>  munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                      \n#>  nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.1)                      \n#>  nvimcom          * 0.9-102    2021-10-25 [1] local                               \n#>  permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                      \n#>  phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                        \n#>  pillar             1.6.3      2021-09-26 [1] CRAN (R 4.1.1)                      \n#>  pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                      \n#>  plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                      \n#>  purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                      \n#>  R6                 2.5.1      2021-08-19 [1] CRAN (R 4.1.1)                      \n#>  Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                      \n#>  RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                      \n#>  readr            * 2.0.2      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                      \n#>  reprex             2.0.1      2021-08-05 [1] CRAN (R 4.1.1)                      \n#>  reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                      \n#>  rhdf5              2.36.0     2021-05-19 [1] Bioconductor                        \n#>  rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                        \n#>  Rhdf5lib           1.14.2     2021-07-06 [1] Bioconductor                        \n#>  rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  rmarkdown        * 2.11       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                      \n#>  rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                      \n#>  rvest              1.0.1      2021-07-26 [1] CRAN (R 4.1.0)                      \n#>  S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                        \n#>  sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                      \n#>  scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                      \n#>  sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                      \n#>  simulator        * 0.2.3      2021-10-25 [1] Github (jacobbien/simulator@aef35ab)\n#>  speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)   \n#>  stringi            1.7.5      2021-10-04 [1] CRAN (R 4.1.1)                      \n#>  stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                      \n#>  survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.1)                      \n#>  tibble           * 3.1.5      2021-09-30 [1] CRAN (R 4.1.1)                      \n#>  tidyr            * 1.1.4      2021-09-27 [1] CRAN (R 4.1.1)                      \n#>  tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                      \n#>  tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                      \n#>  tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                      \n#>  utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                      \n#>  vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                      \n#>  vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                      \n#>  withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                      \n#>  xfun               0.26       2021-09-14 [1] CRAN (R 4.1.1)                      \n#>  xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                      \n#>  XVector            0.32.0     2021-05-19 [1] Bioconductor                        \n#>  yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                      \n#>  zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                        \n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\nCallahan, Benjamin J, Daniel B DiGiulio, Daniela S Aliaga Goltsman, Christine L Sun, Elizabeth K Costello, Pratheepa Jeganathan, Joseph R Biggio, et al. 2017. “Replication and refinement of a vaginal microbial signature of preterm birth in two racially distinct cohorts of US women.” Proc. Natl. Acad. Sci. U. S. A. 114 (37): 9966–71. https://doi.org/10.1073/pnas.1705899114.\n\n\n\n\n",
    "preview": "posts/2021-10-18-evaluate-robustness-example/evaluate-robustness-example_files/figure-html5/summary_plot-1.svg",
    "last_modified": "2021-10-25T19:17:34-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-03-simulate-regression-example/",
    "title": "Simulate regression example",
    "description": "Simulate an example of how bias impacts a regression analysis.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-08-03",
    "categories": [],
    "contents": "\n\nContents\nSimulate data\nActual densities\nTaxonomic bias and measured densities\nCompute mean efficiencies\n\nPlots\nEstimated and actual densities\nRegression coefficients\nManuscript figure\n\n\n\n\n# library(here)\nlibrary(tidyverse)\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nlibrary(ggdist)\nlibrary(ggbeeswarm)\n\nlibrary(speedyseq)\nlibrary(metacal)\n\nset.seed(42)\n\n\n\nSimulate data\n\n\nn_species <- 10\nn_samples <- 50\n\nspecies <- str_c(\"Species \", seq(n_species))\n\n\n\nActual densities\nLog abundances are independent and follow a simple linear model,\nlog density = a_0 + a_1 * X + epsilon\n\n\nn_samples <- 50\nx <- c(\n  rep(0, n_samples / 2),\n  rep(1, n_samples / 2)\n)\nX <- rbind(1, x)\n\nSigma <- diag(1, nrow = n_species)\nrownames(Sigma) <- colnames(Sigma) <- species\na_0 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na_1 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na <- cbind(a_0, a_1)\nnames(a_0) <- names(a_1) <- rownames(a) <- species\n\nepsilon <- MASS::mvrnorm(\n  n = n_samples,\n  mu = rep(0, n_species), \n  Sigma = diag(0.5, nrow = n_species)\n) %>%\n  t\n\ny <- a %*% X + epsilon\ncolnames(y) <- str_glue(\"sa{1:n_samples}\")\n\n\n\nFor the data frame of true coefficients, convert from log-e to log-2.\n\n\ntrue_coeffs <- list('(Intercept)' = a_0, x1 = a_1) %>%\n  map_dfr(enframe, \".otu\", \"truth\", .id = \"term\") %>%\n  mutate(across(truth, ~ . / log(2))) %>%\n  print\n\n\n#> # A tibble: 20 × 3\n#>    term        .otu         truth\n#>    <chr>       <chr>        <dbl>\n#>  1 (Intercept) Species 1  -0.0905\n#>  2 (Intercept) Species 2   2.91  \n#>  3 (Intercept) Species 3  -0.137 \n#>  4 (Intercept) Species 4   2.18  \n#>  5 (Intercept) Species 5  -0.153 \n#>  6 (Intercept) Species 6   0.583 \n#>  7 (Intercept) Species 7   0.913 \n#>  8 (Intercept) Species 8   0.524 \n#>  9 (Intercept) Species 9  -0.815 \n#> 10 (Intercept) Species 10  1.98  \n#> 11 x1          Species 1   1.90  \n#> 12 x1          Species 2  -3.52  \n#> 13 x1          Species 3  -3.83  \n#> 14 x1          Species 4  -0.410 \n#> 15 x1          Species 5   0.917 \n#> 16 x1          Species 6  -0.192 \n#> 17 x1          Species 7  -0.402 \n#> 18 x1          Species 8  -2.00  \n#> 19 x1          Species 9   3.30  \n#> 20 x1          Species 10  1.88\n\n\n\nsam <- tibble(.sample = colnames(y), x) %>%\n  mutate(across(x, factor))\nactual_dens <- phyloseq(\n  otu_table(y, taxa_are_rows = TRUE) %>% transform_sample_counts(exp),\n  sample_data(sam)\n)\n\n\n\n\n\nactual_dens %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance, fill = x)) +\n  scale_x_log10() +\n  stat_dots()\n\n\n\n\nTaxonomic bias and measured densities\nDraw efficiencies from a log normal distribution; set relative to the geometric mean efficiency.\n\n\nlog_efficiency <- MASS::mvrnorm(\n  mu = rep(0, n_species),\n  Sigma = diag(3, nrow = n_species)\n) %>%\n  # {. - min(.)}\n  {. - mean(.)}\nefficiency <- exp(log_efficiency)\n# names(efficiency) <- species\n\n\n\n\n\nlog_efficiency %>% summary\n\n\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#> -3.7952 -1.4314  0.0123  0.0000  0.9551  5.0904\n\nmax(efficiency) / min(efficiency)\n\n\n#> [1] 7226.731\n\nefficiency %>% qplot + scale_x_log10()\n\n\n\n\nTo create an association of log mean efficiency and the covariate, I will set set it so that the species with the largest slope coefficient also has the largest efficiency. This scenario is inspired by the leopold2020host and brooks2015thet experiments.\n\n\nidx_slope <- which.max(a_1)\nidx_eff <- which.max(efficiency)\nnames(efficiency) <- species\nnames(efficiency)[idx_eff] <- species[idx_slope]\nnames(efficiency)[idx_slope] <- species[idx_eff]\n\n\n\nData frame with all species parameters,\n\n\nspecies_params <- true_coeffs %>%\n  pivot_wider(names_from = term, values_from = truth) %>%\n  rename(intercept = '(Intercept)') %>%\n  left_join(efficiency %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  mutate(log2_efficiency = log2(efficiency)) %>%\n  print\n\n\n#> # A tibble: 10 × 5\n#>    .otu       intercept     x1 efficiency log2_efficiency\n#>    <chr>          <dbl>  <dbl>      <dbl>           <dbl>\n#>  1 Species 1    -0.0905  1.90      0.0225          -5.48 \n#>  2 Species 2     2.91   -3.52      1.15             0.200\n#>  3 Species 3    -0.137  -3.83      0.213           -2.23 \n#>  4 Species 4     2.18   -0.410     0.0748          -3.74 \n#>  5 Species 5    -0.153   0.917     2.98             1.58 \n#>  6 Species 6     0.583  -0.192     0.339           -1.56 \n#>  7 Species 7     0.913  -0.402     0.892           -0.165\n#>  8 Species 8     0.524  -2.00      1.73             0.787\n#>  9 Species 9    -0.815   3.30    162.               7.34 \n#> 10 Species 10    1.98    1.88      9.62             3.27\n\n\n\nspecies_params %>%\n  ggplot(aes(x1, log2_efficiency)) +\n  geom_text(aes(label = str_extract(.otu, '[0-9]+')))\n\n\n\n\nQuestion: Is it true that the first species is driving the association?\nThe measured (i.e. estimated) proportions and densities are given by perturbing the actual densties by the efficiencies, and normalizing to proportions or to the original (correct) total.\n\n\nmeasured_prop <- actual_dens %>% perturb(efficiency)\nmeasured_dens <- actual_dens %>% perturb(efficiency, norm = \"keep\")\n\n\n\nCompute mean efficiencies\n\n\nmean_eff <- actual_dens %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(efficiency, norm = \"none\") %>%\n  sample_sums %>%\n  enframe(\".sample\", \"mean_efficiency\") %>%\n  left_join(sam, by = \".sample\")\n\n\n\n\n\nmean_eff %>%\n  ggplot(aes(y = as.factor(x), x = mean_efficiency)) +\n  scale_x_log10() +\n  stat_dotsinterval()\n\n\n\n\nPlots\nEstimated and actual densities\n\n\nlvls <- a_1 %>% sort(decreasing = TRUE) %>% names\n\ndens <- bind_rows(\n  Actual = actual_dens %>% as_tibble,\n  Measured = measured_dens %>% as_tibble,\n  .id = 'type'\n) %>%\n  rename(density = .abundance) %>%\n  mutate(\n    log2_density = log2(density),\n    across(.otu, factor, levels = lvls)\n  )\n\n\n\n\n\np_species_all <- dens %>%\n  ggplot(aes(x, log2_density, color = type)) +\n  labs(y = \"Log density \") +\n  facet_grid(.otu~type, scales = \"fixed\") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, fill = 'grey', se = FALSE\n  ) +\n  theme(legend.position = \"none\")\np_species_all \n\n\n\n\n\n\np_mean_eff <- mean_eff %>%\n  ggplot(aes(x, log2(mean_efficiency))) +\n  labs(y = \"Log efficiency \") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, color = 'black', fill = 'grey', se = FALSE\n  )\np_mean_eff \n\n\n\n\n\n\np_mean_eff + p_species_all +\n  plot_layout(ncol = 1, heights = c(0.2, 1)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nRegression coefficients\n\n\nlm_results_mean_eff <- mean_eff %>%\n  {lm(log2(mean_efficiency) ~ 1 + x, .)} %>%\n  broom::tidy(conf.int = TRUE)\n\n\n\n\n\nlm_results <- dens %>%\n  group_by(.otu, type) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log2_density ~ 1 + x, .)),\n    fit = map(fit, broom::tidy, conf.int = TRUE),\n  ) %>%\n  select(-data) %>%\n  unnest(fit) %>%\n  ungroup %>%\n  left_join(true_coeffs, by = c(\".otu\", \"term\"))\n\nlm_results_slope <- lm_results %>%\n  filter(term == \"x1\") %>%\n  mutate(\n    across(.otu, fct_reorder, estimate)\n  ) %>%\n  arrange(.otu)\n\n\n\n\n\n# params for arrows showing error\ndelta <- lm_results_mean_eff %>% filter(term == \"x1\") %>% pull(estimate)\nstart <- lm_results_slope %>% filter(type == 'Actual', .otu == 'Species 9') %>%\n  pull(estimate)\n\np_coef_ci <- lm_results_slope %>% \n  ggplot(aes(y = .otu, x = estimate, color = type)) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_pointinterval(aes(xmin = conf.low, xmax = conf.high)) +\n  theme(legend.position = 'top') +\n  guides(color = guide_legend(reverse = TRUE)) +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = start, xend = start - delta, \n    y = 10.5, yend = 10.5\n  ) +\n  coord_cartesian(clip = 'off')\n\np_coef_ci_with_true_coef <- p_coef_ci +\n  geom_point(data = ~filter(., type == \"Actual\"),\n    aes(x = truth),\n    color = 'black', shape = '+', size = 4)\n\np_coef_ci_mean_eff <- lm_results_mean_eff %>% \n  filter(term == \"x1\") %>%\n  ggplot(aes(y = \"Mean efficiency\", x = estimate)) +\n  expand_limits(\n    x = c(\n      min(lm_results_slope$conf.low), \n      max(lm_results_slope$conf.high)\n  )) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_point() +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = 0, xend = delta, \n    y = 1.0, yend = 1.0\n  )\n\np_coef_dot <- lm_results_slope %>% \n  ggplot(aes(y = type, x = estimate, fill = type)) +\n  labs(x = \"Log fold change\", y = \"Type\") +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  stat_dots()\n\np_coef_ci_mean_eff / p_coef_ci_with_true_coef / p_coef_dot + \n  plot_layout(heights = c(0.2, 1, 0.3)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nThe true coefficients fall within the ‘Actual’ CIs, confirming that our simulations worked. For the manuscript figure, we won’t include the true data-generating coefficients, since our aim is to illustrate the relationship between coefficients estimated on the ‘Actual’ and ‘Measured’ measurements.\nManuscript figure\nChose species that show the full range of qualitative behaviors in terms of the effect of taxonomic bias on the estimated slope coefficient.\nSpecies 9: Bias causes a substantial decrease in the magnitude of the slope\nSpecies 10: Bias causes a substantial decrease in the magnitude of the slope, such that the estimate is no longer distinguishable from zero.\nSpecies 5: Bias causes a sign error\nSpecies 7: Bias cases a small negative slope that would not have been distinguishable from zero to become significantly (in a biological and statistical sense) negative\nSpecies 2: Bias cases a substantially negative slope to become more negative (increased magnitude)\n\n\nspecies_to_plot <- str_c(\"Species \", c('9', '10', '5', '7', '2'))\np_species_focal <- p_species_all\np_species_focal$data <- p_species_focal$data %>% \n  filter(.otu %in% species_to_plot)\n\n# Bold these species in coeffcient CI plot\np_coef_ci1 <- p_coef_ci +\n  theme(\n    axis.text.y = element_text(\n      face = ifelse(levels(p_coef_ci$data$.otu) %in% species_to_plot, \n        \"bold\", \"plain\")\n    )\n  )\n\n# Set range of mean eff panel to match\nrng <- p_species_focal$data %>%\n  pull(log2_density) %>%\n  {max(.) - min(.)}\nm <- p_mean_eff$data %>% pull(mean_efficiency) %>% log2 %>% mean\np_mean_eff1 <- p_mean_eff + \n  expand_limits(y = c(m - rng/2, m + rng/2))\n\n\n\n\n\n(p_mean_eff1 + ggtitle(\"Mean efficiency\")) +\n  (p_coef_ci_mean_eff + ggtitle(\"LFC in mean efficiency\")) + \n  (p_species_focal + ggtitle(\"Actual and measured densities\\nof select species\")) + \n  (p_coef_ci1 + ggtitle(\"Estimated LFCs of all species\") +\n    theme(legend.box.margin = margin(b = -15))\n  ) + \n  plot_layout(ncol = 2, heights = c(0.2, 1)) +\n  plot_annotation(tag_levels = 'A') &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto() &\n  theme(\n    plot.title = element_text(face = \"plain\")\n  )\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-08-03-simulate-regression-example/simulate-regression-example_files/figure-html5/unnamed-chunk-6-1.svg",
    "last_modified": "2021-10-25T15:24:55-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-10-vaginal-microbiome-example/",
    "title": "Hypothetical example of spurious fold changes in proportions in the vaginal microbiome",
    "description": "This doc develops a hypothetical example in which bias leads to a spurious differential abundance result. It is based on a real case of bias measured among three species of vaginally-associated bacteria.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-05-10",
    "categories": [],
    "contents": "\n\nContents\nSetup\nSimulate data\nPlots\nSession info\n\n\nChangelog\n2021-07-17: Cleaned up the doc and updated to use the cleaner code and include the caption from /article.Rmd\nSetup\n\n\nset.seed(42)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE,\n  cache = FALSE,\n  echo = TRUE\n)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nclose_elts <- function(x) x / sum(x)\n\n\n\nSimulate data\n\n\nbias <- tibble(taxon = c(\"Lactobacillus\", \"Gardnerella\", \"Atopobium\", \"Spike-in\"),\n  efficiency = c(4.68, 0.16, 0.285, 1)) %>%\n  mutate(across(efficiency, ~. / min(.)))\n# efficiency associated with the targeted measurement of Lactobacillus\ntargeted_efficiency <- 2\na0 <- tribble(\n  ~taxon, ~timepoint, ~abundance,\n  \"Lactobacillus\", \"T1\", 5,\n  \"Lactobacillus\", \"T2\", 0.5,\n  \"Gardnerella\", \"T1\", 2,\n  \"Gardnerella\", \"T2\", 8,\n  \"Atopobium\", \"T1\", 3,\n  \"Atopobium\", \"T2\", 1.5,\n) %>%\n  # Shrink abundance to have similar scale as proportions\n  mutate(across(abundance, ~ . / max(.))) %>%\n  left_join(bias, by = \"taxon\") %>%\n  with_groups(timepoint, mutate,\n    total_abundance = sum(abundance),\n    proportion = close_elts(abundance),\n    biased_abundance = efficiency * abundance,\n    biased_proportion = close_elts(biased_abundance),\n    biased_count = biased_proportion * 1e3,\n    abundance_estimate_bulk = biased_proportion * total_abundance,\n    #> abundance_estimate_spikein = biased_count / biased_count[taxon == \"Spike-in\"],\n    abundance_estimate_targeted = biased_count * targeted_efficiency *\n      abundance[taxon == \"Lactobacillus\"] / biased_count[taxon == \"Lactobacillus\"],\n  )\na1 <- a0 %>%\n  select(-total_abundance) %>%\n  pivot_longer(-c(taxon, efficiency, timepoint), names_to = \"type\")\n# data frame for plots\nptb <- a1 %>%\n  filter(\n    type %in% c(\"proportion\", \"biased_proportion\"),\n  ) %>%\n  mutate(\n    across(type, fct_relevel, \"proportion\", \"biased_proportion\"),\n    across(type, fct_recode,\n      \"Actual\" = \"proportion\",\n      \"Observed\" = \"biased_proportion\"),\n  )\n\n\n\nPlots\nPanels showing the error in measurement and in differential abundance\n\n\nshared_layers <- list(\n  geom_path(aes(group = taxon),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))),\n  geom_point(size = 2),\n  scale_color_brewer(type = \"qual\", palette = 1, guide = \"none\"),\n  labs(y = \"Proportion\", color = \"Taxon\"),\n  scale_y_log10(),\n  coord_cartesian(clip = \"off\"),\n  # scale_y_log10(breaks = c(1e-2, 3e-2, 1e-1, 3e-1, 1)) +\n  expand_limits(y = 1e-2),\n  theme(plot.margin = unit(c(0, 1.3, 0, 0), units = \"in\"))\n)\n# How much to nudge the taxon labels and proportions\nnudge.taxon <- 0.48\nnudge.prop <- 0.24\n# In future iterations, consider labelling the taxa in both facets\np.meas <- ptb %>%\n  ggplot(aes(type, value, color = taxon)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  shared_layers +\n  geom_text(data = ~filter(., type == \"Actual\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., type == \"Observed\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Type\",\n    title = \"Measurement error at each time point\"\n  )\np.fc <- ptb %>%\n  ggplot(aes(timepoint, value, color = taxon)) +\n  facet_wrap(~type, nrow = 1, scales = \"fixed\") +\n  shared_layers +\n  geom_text(data = ~filter(., timepoint == \"T1\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Time point\",\n    title = \"Actual and observed fold changes\"\n  )\n\n\n\nPanel showing the efficiencies of individual taxa and the sample means\n\n\n# First, compute the mean efficiency, then join with the taxon efficiencies in\n# a table for plotting.\nsme <- a0 %>%\n  with_groups(timepoint, summarize, mean_efficiency = sum(proportion * efficiency))\nsme0 <- sme %>%\n  mutate(label = str_glue(\"mean ({timepoint})\")) %>%\n  select(label, efficiency = mean_efficiency)\nsme1 <- sme %>%\n  mutate(taxon = \"Mean\", type = \"Mean\") %>%\n  select(taxon, efficiency = mean_efficiency, timepoint, type)\nbias1 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(type = \"Taxon\")\nlvls = c(\"Atopobium\", \"Gardnerella\", \"Lactobacillus\", \"Mean\")\netb1 <- bind_rows(bias1, sme1) %>%\n  mutate(across(taxon, factor, levels = lvls))\n\nlvls = c(\"Gardnerella\", \"Atopobium\", \"Lactobacillus\")\nbias2 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(\n    type = \"Taxon\",\n    across(taxon, factor, levels = lvls),\n    x = as.integer(taxon)\n  ) %>%\n  left_join(sme, by = \"timepoint\")\n\nclrs <- c(RColorBrewer::brewer.pal(n = 3, \"Accent\"), rep(\"#585858\", 2))\np.eff <- bias2 %>%\n  ggplot(aes(x = x, y = efficiency, color = taxon)) +\n  geom_point(size = 2) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = taxon), x = 3.3, hjust = 0) +\n  geom_segment(aes(xend = x, yend  = efficiency, y = mean_efficiency),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))) +\n  geom_segment(data = sme,\n    aes(x = 1, xend = 3, y = mean_efficiency, yend = mean_efficiency),\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  geom_text(data = sme0 %>% mutate(timepoint = \"T2\"),\n    aes(label = label, y = efficiency), x = 3.3, hjust = 0,\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  scale_color_manual(values = clrs) +\n  labs(y = \"Relative efficiency\", x = NULL, color = \"Taxon\",\n    title = \"Taxonomic bias of protocol\"\n  ) +\n  # Set the vertical span to match the other plots\n  scale_y_log10(limits = c(1, 100) / 2,\n    breaks = etb1$efficiency,\n    labels = signif(etb1$efficiency, 2)\n  ) +\n  xlim(c(0.0, 4)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  coord_cartesian(clip = \"off\") +\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.title.x = element_blank(),\n    legend.position = \"none\",\n    plot.margin = unit(c(0, 1.0, 0, 0), units = \"in\")\n  )\n\n\n\nPlot as a multi-panel figure\n\n\np.meas + p.eff + p.fc + plot_spacer() + \n  plot_layout(byrow = TRUE, ncol = 2, widths = c(1, 0.6)) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nCaption (copied from main article version 47ce39c): Taxonomic bias can distort differential abundance results even when it is consistent for each taxon across samples. Panel A shows the actual and observed proportions for hypothetical community samples from two time points, which differ in their relative abundance of three taxa. Panel B shows taxonomic bias in terms of the relative efficiencies of the three taxa against the mean efficiency of each sample; the difference between the taxon’s efficiency and the sample’s mean (vertical arrows) determines the fold error seen in Panel A. Panel C rearranges the plot from Panel A to show the actual and observed fold changes between time points. The efficiencies of individual taxa were estimated by @mclaren2019cons from mock community data from @brooks2015thet. The abundances are hypothetical but inspired by observations from the human vaginal microbiome; see main text.\nSome ideas for improvement:\nExperiment with ways to make the connections even clearer between the efficiency differences and the error.\nTry making the arrows vertical, so that they are directly connected to the fold changes in proportion and in efficiency.\nCan also split the third plot into T1 and T2.\nMight consider changing “Time point T1” to “Sample S1”, to fit the primary language of the text.\nCan mention in the text that these could be samples from different women, or the same woman at different times.\nalso use a shape scale for the taxa, to give a second way besides color to distinguish them\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.0 (2021-05-18)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-07-17                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package      * version date       lib source        \n#>  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n#>  backports      1.2.1   2020-12-09 [1] CRAN (R 4.0.3)\n#>  base64enc      0.1-3   2015-07-28 [1] CRAN (R 4.0.0)\n#>  bookdown       0.22    2021-04-22 [1] CRAN (R 4.1.0)\n#>  broom          0.7.6   2021-04-05 [1] CRAN (R 4.0.5)\n#>  bslib          0.2.5.1 2021-05-18 [1] CRAN (R 4.1.0)\n#>  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n#>  cli            3.0.0   2021-06-30 [1] CRAN (R 4.1.0)\n#>  colorspace     2.0-2   2021-06-24 [1] CRAN (R 4.1.0)\n#>  cowplot      * 1.1.1   2020-12-30 [1] CRAN (R 4.0.4)\n#>  crayon         1.4.1   2021-02-08 [1] CRAN (R 4.0.4)\n#>  DBI            1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n#>  dbplyr         2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n#>  digest         0.6.27  2020-10-24 [1] CRAN (R 4.0.3)\n#>  distill        1.2     2021-01-13 [1] CRAN (R 4.1.0)\n#>  downlit        0.2.1   2020-11-04 [1] CRAN (R 4.0.3)\n#>  dplyr        * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n#>  ellipsis       0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n#>  evaluate       0.14    2019-05-28 [1] CRAN (R 4.0.0)\n#>  fansi          0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n#>  farver         2.1.0   2021-02-28 [1] CRAN (R 4.0.4)\n#>  forcats      * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n#>  fs             1.5.0   2020-07-31 [1] CRAN (R 4.0.2)\n#>  generics       0.1.0   2020-10-31 [1] CRAN (R 4.0.3)\n#>  ggplot2      * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n#>  glue           1.4.2   2020-08-27 [1] CRAN (R 4.0.2)\n#>  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n#>  haven          2.4.1   2021-04-23 [1] CRAN (R 4.1.0)\n#>  here         * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n#>  highr          0.9     2021-04-16 [1] CRAN (R 4.1.0)\n#>  hms            1.1.0   2021-05-17 [1] CRAN (R 4.1.0)\n#>  htmltools      0.5.1.1 2021-01-22 [1] CRAN (R 4.0.3)\n#>  httr           1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n#>  jquerylib      0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n#>  jsonlite       1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n#>  knitr          1.33    2021-04-24 [1] CRAN (R 4.1.0)\n#>  labeling       0.4.2   2020-10-20 [1] CRAN (R 4.0.3)\n#>  lifecycle      1.0.0   2021-02-15 [1] CRAN (R 4.0.4)\n#>  lubridate      1.7.10  2021-02-26 [1] CRAN (R 4.0.4)\n#>  magrittr       2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n#>  modelr         0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n#>  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n#>  nvimcom      * 0.9-102 2021-07-17 [1] local         \n#>  patchwork    * 1.1.1   2020-12-17 [1] CRAN (R 4.0.3)\n#>  pillar         1.6.1   2021-05-16 [1] CRAN (R 4.1.0)\n#>  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n#>  purrr        * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n#>  R6             2.5.0   2020-10-28 [1] CRAN (R 4.0.3)\n#>  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 4.0.0)\n#>  Rcpp           1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n#>  readr        * 1.4.0   2020-10-05 [1] CRAN (R 4.0.3)\n#>  readxl         1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n#>  reprex         2.0.0   2021-04-02 [1] CRAN (R 4.0.5)\n#>  rlang          0.4.11  2021-04-30 [1] CRAN (R 4.1.0)\n#>  rmarkdown    * 2.8     2021-05-07 [1] CRAN (R 4.1.0)\n#>  rprojroot      2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n#>  rstudioapi     0.13    2020-11-12 [1] CRAN (R 4.0.3)\n#>  rvest          1.0.0   2021-03-09 [1] CRAN (R 4.0.5)\n#>  sass           0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n#>  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n#>  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.0)\n#>  stringi        1.6.2   2021-05-17 [1] CRAN (R 4.1.0)\n#>  stringr      * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n#>  tibble       * 3.1.2   2021-05-16 [1] CRAN (R 4.1.0)\n#>  tidyr        * 1.1.3   2021-03-03 [1] CRAN (R 4.0.4)\n#>  tidyselect     1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n#>  tidyverse    * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n#>  utf8           1.2.1   2021-03-12 [1] CRAN (R 4.0.5)\n#>  vctrs          0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n#>  withr          2.4.2   2021-04-18 [1] CRAN (R 4.0.5)\n#>  xfun           0.23    2021-05-15 [1] CRAN (R 4.1.0)\n#>  xml2           1.3.2   2020-04-23 [1] CRAN (R 4.0.0)\n#>  yaml           2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-05-10-vaginal-microbiome-example/vaginal-microbiome-example_files/figure-html5/vaginal-example-proportions-timepoints-1.svg",
    "last_modified": "2021-08-12T12:56:57-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/",
    "title": "Illustration of a spurious differential abundance result due to bias",
    "description": "Create illustration of a spurious differential abundance using the Leopold and Busby (2020) dataset.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-04-26",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9001'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 × 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.77   1.06\n2 Dioszegia        0.295   0.294  1.10\n3 Epicoccum        1.01    1.01   1.50\n4 Fusarium         3.07    3.06   1.14\n5 Penicillium      0.223   0.223  1.09\n6 Cladosporium     0.899   0.898  1.13\n7 Trichoderma      0.578   0.578  1.09\n8 Alternaria       1.47    1.47   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\nRegression analysis\nFirst let’s pick a subset of samples to work with.\n\n\nsam %>%\n  count(Samp_type, Timepoint)\n\n\n# A tibble: 4 × 3\n  Samp_type  Timepoint     n\n  <chr>      <fct>     <int>\n1 Experiment 1           250\n2 Experiment 2           298\n3 Mock       <NA>         10\n4 Single     <NA>          9\n\nsam %>%\n  filter(Samp_type == \"Experiment\") %>%\n  count(Treatment, Timepoint)\n\n\n# A tibble: 12 × 3\n   Treatment     Timepoint     n\n   <chr>         <fct>     <int>\n 1 Alternaria    1            52\n 2 Alternaria    2            53\n 3 Aureobasidium 1            50\n 4 Aureobasidium 2            48\n 5 Cladosporium  1            49\n 6 Cladosporium  2            48\n 7 Dioszegia     1            48\n 8 Dioszegia     2            49\n 9 Fusarium      1            49\n10 Fusarium      2            50\n11 Negative      1             2\n12 Negative      2            50\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Timepoint == 2) %>%\n  count(Region, Treatment)\n\n\n# A tibble: 12 × 3\n   Region Treatment         n\n   <chr>  <chr>         <int>\n 1 East   Alternaria       22\n 2 East   Aureobasidium    21\n 3 East   Cladosporium     19\n 4 East   Dioszegia        18\n 5 East   Fusarium         21\n 6 East   Negative         21\n 7 West   Alternaria       31\n 8 West   Aureobasidium    27\n 9 West   Cladosporium     29\n10 West   Dioszegia        31\n11 West   Fusarium         29\n12 West   Negative         29\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  count(Region, Timepoint)\n\n\n# A tibble: 4 × 3\n  Region Timepoint     n\n  <chr>  <fct>     <int>\n1 East   1           102\n2 East   2           101\n3 West   1           146\n4 West   2           147\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  with_groups(Genotype, summarize, n1 = sum(Timepoint == 1), n2 = sum(Timepoint == 2), tot = n())\n\n\n# A tibble: 12 × 4\n   Genotype    n1    n2   tot\n   <chr>    <int> <int> <int>\n 1 East-1      20    20    40\n 2 East-2      16    17    33\n 3 East-3      19    18    37\n 4 East-4      25    25    50\n 5 East-5      22    21    43\n 6 West-1      22    21    43\n 7 West-2      22    24    46\n 8 West-3      23    23    46\n 9 West-4      23    23    46\n10 West-5      18    17    35\n11 West-6      20    19    39\n12 West-7      18    20    38\n\nThe “Negative” treatment was not inoculated with commensals; let’s drop that from the analysis. Note that there are 2 more West genotypes adn thus more West than East samples.\nTime point\nAsks, how did taxa vary in proportion with the addition of Mel? Note, we expect the commensal taxa to typically decrease given that Mel successfully infects most plants.\nWant to do linear regression on the timepoint.\nstarting point - observed and calibrated proportions in the experiment samples; SME in the experiment samples\n\n\nps1.obs <- ps.pseudo %>%\n  subset_samples(Samp_type == \"Experiment\" & Treatment != \"Negative\") %>%\n  prune_taxa(mock_taxa, .) %>%\n  orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nps1.cal <- ps1.obs %>% calibrate(bias)\nsam1 <- sample_data(ps1.obs) %>% as(\"data.frame\")\nsme1 <- sme %>% filter(Sample %in% sample_names(ps1.obs)) %>% rename(Mean_efficiency = SMRE)\n\n\n\nNote the different numbers of samples at each timepoint Should consider more sophisticated resgression models.\n\n\nfit.obs <- lm(log2(otu_table(ps1.obs)) ~ Timepoint, data = sam1)\nfit.cal <- lm(log2(otu_table(ps1.cal)) ~ Timepoint, data = sam1)\nfit.sme <- lm(log2(Mean_efficiency) ~ Timepoint, data = sme1)\n\n\n\nCheck that the observed changes - the calibrated changes are off by the expected constant shift,\n\n\nt(coef(fit.obs) - coef(fit.cal))\n\n\n              (Intercept) Timepoint2\nMelampsora     2.60208447  -1.991951\nAureobasidium -0.96511376  -1.991951\nTrichoderma   -1.31867681  -1.991951\nFusarium       1.08940455  -1.991951\nPenicillium   -2.68941450  -1.991951\nAlternaria     0.02685515  -1.991951\nCladosporium  -0.68076501  -1.991951\nDioszegia     -2.28952043  -1.991951\nEpicoccum     -0.51768451  -1.991951\n\ncoef(fit.sme)\n\n\n(Intercept)  Timepoint2 \n  0.5269812   1.9919505 \n\n\n\ncoef(fit.obs) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -10.9999195  10.702851\nAureobasidium  -7.9294352  -3.681906\nTrichoderma    -9.4061811  -3.872543\nFusarium       -2.1926596  -5.089495\nPenicillium   -10.8867241  -2.555602\nAlternaria     -0.9593701  -4.074728\nCladosporium   -6.0294424  -3.585850\nDioszegia      -7.7191545  -5.463284\nEpicoccum      -2.3532764  -4.745944\n\ncoef(fit.cal) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -13.6020039 12.6948011\nAureobasidium  -6.9643215 -1.6899556\nTrichoderma    -8.0875043 -1.8805929\nFusarium       -3.2820642 -3.0975448\nPenicillium    -8.1973096 -0.5636511\nAlternaria     -0.9862252 -2.0827775\nCladosporium   -5.3486773 -1.5938999\nDioszegia      -5.4296340 -3.4713339\nEpicoccum      -1.8355919 -2.7539932\n\nThe effect of bias is significant; e.g. Aureobasidium and Trichoderma appear to decrease in proportion by 16X but actually decrease by 4X, and Penicillium appears to decrease by 5.9X but only decreases by 1.5X.\nCould use the case of Penicillium as our example.\n\n\n# Check expected relationship between coefficients on intercept and slope\nall.equal(\n  coef(fit.obs)[,\"Penicillium\"],\n  coef(fit.cal)[,\"Penicillium\"] + c(log2(bias[\"Penicillium\"]), 0) - coef(fit.sme)\n)\n\n\n[1] TRUE\n\n\n\ntb <- bind_rows(\n  Observed = psmelt(ps1.obs),\n  Calibrated = psmelt(ps1.cal),\n  .id = \"Type\"\n) %>%\n  mutate(across(Type, fct_relevel, \"Calibrated\")) %>%\n  rename(Proportion = Abundance)\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8) +\n  scale_color_brewer(type = \"qual\", palette = 6)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\nTODO: Add a panel with the sample mean efficiency\n\n\nsme1 %>%\n  ggplot(aes(y = log2(Mean_efficiency), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n\n\n\n\nQuestion: For the purposes of illustration, might we want to find the host region or host genotype with the largest change in SME? Ok as long as we’re clear what we’re doing. Reducing the number of data points and biological variation might actually make things cleaner as well (or could use boxplots), since the point is not to dwell on all the variation, but rather just the average effect.\nfor paper, might be clearer to call “Corrected” instead of “Calibrated”.\nCan easily split graph by region or host genotype:\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Region)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\") +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_grid(Region~Type)\n\n\n\n\nNote that the 95% CIs are small and hard to see.\nWant to plot the sme’s with the change in proportion; make sure the y-axes have the same scale. One way to simplify this is to show the mean efficiency relative to the taxon in question; then it will give the difference between calibrated and observed.\n\n\nsme2 <- sme1 %>%\n  mutate(Mean_relative_efficiency = Mean_efficiency / bias[\"Penicillium\"]) %>%\n  rename(Proportion = Mean_relative_efficiency) %>%\n  mutate(Type = \"Mean relative efficiency\")\ntb1 <- tb %>%\n  filter(OTU == \"Penicillium\") %>%\n  bind_rows(sme2) %>%\n  mutate(across(Type, fct_relevel, c(\"Calibrated\", \"Observed\", \"Mean relative efficiency\")))\n\n\n\n\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n)\ntb1 %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  lyrs +\n  facet_grid(Region~Type)\n\n\n\n\n\n\ntb1 %>%\n  mutate(across(Type, fct_reorder, Proportion)) %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.3) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_grid(.~Region) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = 5,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"Pathogen growth causes\\nmean efficiency to increase,\",\n  ) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = -10,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"which leads to larger-than-\\nactual decreases in the\\nfocal taxon Penicillium.\",\n  ) +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  theme(\n    legend.position = \"top\",\n    plot.margin = margin(r = 2.5, unit = \"in\"),\n  ) +\n  plot_annotation(\n    title = \"Effect of bias on Penicillium differential abundance\"\n  )\n\n\n\n\nSummary:\nRegression of log2(Proportion) of the fungus Penicillium versus timepoint; timepoints 1 and 2 are pre- and post- challenge with the pathogen Melampsora. Data is split by the region the host plants are derived from.\nCalibrated proportions = Observed proportions in the real, experimental samples after adjustment for the bias measured in mock communities\nMean efficiency of each community is inferred by treating the calibrated proportions as the truth, and multiplying by efficiencies estimated from the mocks\nThe pathogen Melampsora has a high measurement efficiency; thus once it infects the plants, the mean efficiency of the sample increases (purple points). Efficiency is here taken as relative to the focal taxon Penicillium.\nWest plants tend to be more resistant to the pathogen, which likely explains why the mean efficiency doesn’t increase as much in the West plants\nPenicillium is observed to decrease in log proportion, in both the East and West plants. But the calibrated measurements show that it actually slightly increases in the East plants, and has a lesser decrease in the West plants than what was observed before bias correction.\nThe difference between the Calibrated and Observed data points and regression lines equals the regression line of the mean efficiency: Orange = Green + Purple; Green = Orange - Purple\nThe absolute error in regression coeffiecients is the same for all taxa. I picked Penicillium for illustration since it has the smallest observed decrease, which makes the error due to bias have a particularly significant impact. \n\n\n\nAlt. plot\n\n\ntb2 <- tb1 %>%\n  mutate(\n    log2_proportion = log2(Proportion),\n    across(Type, fct_relevel, c(\"Observed\", \"Calibrated\", \"Mean relative efficiency\")),\n    #> across(Type, fct_recode, Corrected = \"Calibrated\", Uncorrected = \"Observed\")\n  )\n\n\n\nLet’s show the calibrated, observed, and mean efficiency side by side, similar to my initial explanatory plot.\nQuestion: How to get the same y-axis range in each facet? We need to determine what we want the min and max y values for each facet to be. Choose so that the range in each panel equals the max data range for any one panel, and center the data range of each panel within the plot range.\n\n\nyr <- tb2 %>%\n  with_groups(c(Region, Type), summarize, \n    across(log2_proportion, c(min = min, max = max), .names =  \"data_{.fn}\")\n ) %>%\n  mutate(\n    data_range = data_max - data_min,\n    data_mid = (data_max + data_min) / 2,\n    y_min = data_mid - max(data_range) / 2,\n    y_max = data_mid + max(data_range) / 2\n  ) %>%\n  print\n\n\n# A tibble: 6 × 8\n  Region Type      data_min data_max data_range data_mid   y_min y_max\n  <chr>  <fct>        <dbl>    <dbl>      <dbl>    <dbl>   <dbl> <dbl>\n1 East   Observed    -14.9     -8.66       6.26   -11.8  -16.2   -7.41\n2 East   Calibrat…   -12.2     -5.96       6.22    -9.07 -13.5   -4.69\n3 East   Mean rel…     2.48     5.27       2.79     3.87  -0.510  8.26\n4 West   Observed    -14.9     -6.16       8.77   -10.5  -14.9   -6.16\n5 West   Calibrat…   -11.3     -3.58       7.76    -7.46 -11.8   -3.07\n6 West   Mean rel…     2.47     5.26       2.79     3.87  -0.515  8.25\n\nstopifnot(yr %>% {sd((.$y_max - .$y_min))} < 1e-14)\nyr.long <- yr %>%\n  pivot_longer(c(y_min, y_max))\n\n\n\n\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  geom_blank(data = yr.long, aes(y = value, x = 1)) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_wrap(Region~Type, scales = \"free_y\") +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)) +\n  labs(y = \"log2(Proportion)\")\n\n\n\n\n\n\ntext_tb <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\n#> Label \"Calibrated\" as \"Actual\" for purposes of illustration?\nlblr <- function(labels) {\n  labels %>% pull(1) %>% fct_recode(Actual = \"Calibrated\") %>% as.character %>% list\n}\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    #> arrow = grid::arrow(length = unit(0.15, \"inches\")),\n    size = 0.9, color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  facet_wrap(~Type, scales = \"free_y\", labeller = lblr),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  theme(\n    plot.title = element_text(face = \"plain\"),\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\")\n  ),\n  labs(y = \"log2(Proportion)\"),\n  # Corrected = Observed - Mean relative efficiency\n  coord_cartesian(xlim = c(1, 2), clip = \"off\")\n)\np1 <- tb2 %>%\n  filter(Region == \"East\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"East\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Eastern genotypes: Bias causes sign error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"East\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\np2 <- tb2 %>%\n  filter(Region == \"West\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"West\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Western genotypes: Bias causes magnitude error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"West\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\n\n\n\n\n\np1 / p2 + \n  plot_annotation(\n    #> title = \"Effect of bias on Penicillium differential abundance\",\n    tag_levels = \"A\"\n  )\n\n\n\n\nThis ^ is my favorite so far\n\n\n\nTODO:\nChange y label to log2(value) and adding “proportion” to the two proportion facets\nChange back to “Calibrated proportion” and “Observed proportion”?\nSlightly increase spacing between patchwork panels (rows)\nSwap positions of calibrated and uncalibrated so that the equation is correct: Observed = Actual - Mean efficiency\nalternate approach using 2-d facet wrap:\n\n\nsymbol_labels <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n      #> Type == \"Mean relative efficiency\" & Region == \"East\" ~ \"Eastern\\ngenotypes\",\n      #> Type == \"Mean relative efficiency\" & Region == \"West\" ~ \"Western\\ngenotypes\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\nregion_labels <- yr %>%\n  filter(Type == \"Mean relative efficiency\") %>%\n  mutate(\n    text = case_when(\n      Region == \"East\" ~ \"Eastern genotypes\\n\\nBias causes\\nsign error\",\n      Region == \"West\" ~ \"Western genotypes\\n\\nBias causes\\nmagnitude error\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> geom_blank(data = yr, aes(y = y_min, x = factor(1))),\n  #> geom_blank(data = yr, aes(y = y_max, x = factor(1))),\n  geom_blank(data = yr.long, aes(y = value, x = 1)),\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  #> facet_wrap(~Type, scales = \"free_y\"),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  labs(y = \"log2(Proportion)\"),\n  # Calibrated = Observed - Mean relative efficiency\n  geom_text(\n    data = symbol_labels,\n    aes(y = y, label = text),\n    x = 2.9, color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  ),\n  geom_text(\n    data = region_labels,\n    aes(y = y, label = text),\n    x = 2.8, color = \"black\", size = 4.8, hjust = 0, vjust = 0.5,\n  ),\n  coord_cartesian(xlim = c(1, 2), clip = \"off\"),\n  theme(\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\"),\n    plot.margin = margin(r = 1.75, unit = \"in\")\n  )\n)\n\n# labeller assuming first col is region, second is type\nlblr <- function(labels) {\n  labels %>% pull(2) %>% as.character %>% list\n}\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  facet_wrap(Region~Type, scales = \"free_y\", \n    labeller = lblr\n    #> labeller = labeller(Region = NULL, .multi_line = FALSE),\n    #> strip.position = \"right\"\n  )\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.0 (2021-05-18)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-07-28                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.0     2021-05-19 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n broom            * 0.7.8      2021-06-24 [1] CRAN (R 4.1.0)                   \n bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n checkmate          2.0.0      2020-02-06 [1] CRAN (R 4.0.2)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.0)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.0)                   \n colorspace         2.0-2      2021-06-24 [1] CRAN (R 4.1.0)                   \n cowplot          * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n foreign            0.8-81     2020-12-22 [2] CRAN (R 4.1.0)                   \n Formula            1.2-4      2020-10-16 [1] CRAN (R 4.0.3)                   \n fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n GenomeInfoDb       1.28.0     2021-05-19 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.1      2021-04-23 [1] CRAN (R 4.1.0)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n Hmisc              4.5-0      2021-02-28 [1] CRAN (R 4.0.4)                   \n hms                1.1.0      2021-05-17 [1] CRAN (R 4.1.0)                   \n htmlTable          2.2.1      2021-05-18 [1] CRAN (R 4.1.0)                   \n htmltools          0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n htmlwidgets        1.5.3      2020-12-10 [1] CRAN (R 4.0.3)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jpeg               0.1-9      2021-07-24 [1] CRAN (R 4.1.0)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.33       2021-04-24 [1] CRAN (R 4.1.0)                   \n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.0)                   \n latticeExtra       0.6-29     2019-12-19 [1] CRAN (R 4.0.0)                   \n lifecycle          1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.0)                   \n Matrix             1.3-3      2021-05-04 [2] CRAN (R 4.1.0)                   \n metacal          * 0.2.0.9001 2021-07-16 [1] Github (mikemc/metacal@a7a87a1)  \n mgcv               1.8-35     2021-04-18 [2] CRAN (R 4.1.0)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.0)                   \n nnet               7.3-16     2021-05-03 [2] CRAN (R 4.1.0)                   \n nvimcom          * 0.9-102    2021-07-17 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.1      2021-05-16 [1] CRAN (R 4.1.0)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n png                0.1-7      2013-12-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                   \n readr            * 2.0.0      2021-07-20 [1] CRAN (R 4.1.0)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.0     2021-05-19 [1] Bioconductor                     \n rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                   \n rmarkdown        * 2.9        2021-06-15 [1] CRAN (R 4.1.0)                   \n rpart              4.1-15     2019-04-12 [2] CRAN (R 4.1.0)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.3      2021-07-16 [1] CRAN (R 4.1.0)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.0)                   \n tibble           * 3.1.3      2021-07-23 [1] CRAN (R 4.1.0)                   \n tidyr            * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.24       2021-06-15 [1] CRAN (R 4.1.0)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/index_files/figure-html5/unnamed-chunk-2-1.svg",
    "last_modified": "2021-10-25T15:24:55-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-11-12-leopold2020host-bias-sensitivity/",
    "title": "Exploring the effect of bias in Leopold and Busby (2020)\n",
    "description": {},
    "author": [
      {
        "name": "Michael McLaren",
        "url": {}
      }
    ],
    "date": "2019-10-21",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nSetup\nSample mean efficiency across samples\nAlt plot\nCheck errors in FCs\nmock samples\nExperiment samples\n\n\nSession info\n\nAnalysis of bias in Leopold and Busby (2020).\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 x 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.76   1.06\n2 Dioszegia        0.295   0.295  1.10\n3 Epicoccum        1.01    0.995  1.50\n4 Fusarium         3.07    3.08   1.14\n5 Penicillium      0.223   0.224  1.09\n6 Cladosporium     0.899   0.903  1.13\n7 Trichoderma      0.578   0.579  1.09\n8 Alternaria       1.47    1.46   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\n\n\nrange(sme$SMRE)\n\n\n[1] 0.2236076 8.7034225\n\nrange(bias)\n\n\n[1] 0.2233792 8.7486819\n\n\n\np1 <- ggplot(sme, aes(SMRE, fill = Samp_type)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = \"Sample type\"\n  )\np1 +\n  plot_annotation(\n    title = \"Distribution of sample mean relative efficiencies\",\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nIn this case, the bimodal distribution is likely driven by the high proportion of Melampsora (pathogen) in ~half the samples.\nTODO: check this hypothesis. by making a histogram of melampspora %, and a scatterplot of the melamspora vs. SMRE. Can do with facet matrix from ggforce\n\n\nmel <- otu %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  psmelt %>%\n  select(-OTU, Melampsora = Abundance)\nsme0 <- left_join(sme, mel, by = \"Sample\")\n\n\n\n\n\n# p2 <- ggplot(sme0, aes(SMRE, fill = Melampsora)) +\np2 <- ggplot(sme0, aes(y = Melampsora, x = SMRE, color = Samp_type)) +\n  geom_point() +\n  # annotate(\"point\", y = 1, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  expand_limits(x = range(bias)) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\",\n    color = \"Sample type\"\n  )\np2\n\n\n\n\n\n\n(p1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.pdf\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\n\n\n\nNote, the high-Mel samples are the timepoint 2 samples, and were not used for some (all?) of his analysis due to the dominance of Mel. Let’s check this out,\n\n\nsme %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  ) %>%\n  # filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Treatment)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Region)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nCan see that Eastern genotypes more susceptible (more Mel and higher SME)\nAre some western genotypes less susceptible?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"West\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nEastern?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"East\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nAlt plot\nMight be better to just focus on the treated experimental samples; can note that the bimodal distribution in SMRE is due to the presence of Mel in the timepoint 2, and thus we’d mess up our AA inferences if we tried to infer the change in AA after Mel introduction. We might also (if were were analyzing timepoint 2 samples)\nActually, including the bias values serves the important purpose of showing how the SME varies less than the efficiencies. For that reason it could even be worth having the single-isolate samples, though seems unneeded.\nPoints\nSME varies less across samples than efficiencies vary across taxa\nSME much greater after rusting (timepoint 2) -> it will look like the growth of the pathogen suppressed the proportion and absolute abundance of the colonizers 5-6X more than it actually did\nThe Mel prop and hence the SME varies significantly in the timepoint 2 samples. This may lead to systematic errors in certain inferences. E.g., if host genotype affects Mel and another taxon, that other taxon’s value will be distorted (and, I think, the effect on Mel will be inflated).\nAs an example, think through the case of more resistant host genotypes\nMight also consider the taxa found to suppress Mel; see paper\n\n\n\np1.1 <- sme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\np2.1 <- sme0 %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(y = Melampsora, x = SMRE, color = Timepoint)) +\n  geom_point() +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    x = \"Mean efficiency\"\n  )\n\n\n\n\n\n(p1.1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2.1 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nTODO: Still need to determien if the y axis is accurate on histogram; I think its off when using pseudo-log. But perhaps can get away with linear?\nCheck errors in FCs\nWe can use this distribution to pick examples of samples where bias approximately cancels in the FC estimates (because their SMRE’s are similar), and samples where bias does not approximately cancel (because their SMRE’s are very different). Could do for mock samples (using the ground truth) or for natural samples (using the calibrated composition). Might as well do it both ways; not sure which would be best for a paper. The mocks have the benefit of knowing the ground truth, while the natural samples demonstrate practical significance. Also, we can give nice intuitive description of what we’re doing in the natural samples by saying that we’re comparing samples w/ low-low, high-high, or low-high pathogen %.\nTODO ^^\nmock samples\nTo pick from the mock samples:\n\n\nsme0 %>%\n  filter(Samp_type == \"Mock\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 10 x 5\n   Sample   SMRE Melampsora log10_SMRE     diff\n   <chr>   <dbl>      <dbl>      <dbl>    <dbl>\n 1 Mock.3  0.541    0.00782   -0.267   NA      \n 2 Mock.7  0.970    0.00761   -0.0132   0.254  \n 3 Mock.9  0.981    0.0116    -0.00824  0.00492\n 4 Mock.2  1.16     0.0524     0.0628   0.0711 \n 5 Mock.6  1.24     0.0435     0.0931   0.0303 \n 6 Mock.10 1.82     0.0948     0.261    0.168  \n 7 Mock.1  2.00     0.0540     0.301    0.0400 \n 8 Mock.4  2.12     0.164      0.327    0.0256 \n 9 Mock.8  2.20     0.134      0.343    0.0161 \n10 Mock.5  2.96     0.179      0.472    0.129  \n\nMock.3 -> Mock.5 have the biggest difference in SMRE. Notably, its still only a factor of 5.5 difference.\nMock.7 -> Mock.9 have the smallest log difference.\nNext: Compute the actual and observed FC in proportions, for each of these pairs of communities. Perhaps define a function to spit out the relevant data frame, given any pair of samples, the phyloseq object (or calibrated phyloseq object?), and the bias vector? Actually, for the mocks, should use the “actual” table instead of calibrated.\nUse these objects,\n\n\nmock_actual\n\n\nOTU Table:          [ 9 taxa and 10 samples ]:\nTaxa are columns\n        Melampsora Dioszegia Epicoccum Fusarium Penicillium\nMock.1      0.0538    0.0108    0.0108   0.269       0.0108\nMock.2      0.0538    0.269     0.269    0.0108      0.0108\nMock.3      0.0108    0.269     0.0538   0.0108      0.269 \nMock.4      0.269     0.0538    0.0108   0.0538      0.269 \nMock.5      0.269     0.0108    0.0108   0.269       0.0538\nMock.6      0.0538    0.0538    0.0538   0.0108      0.0108\nMock.7      0.0108    0.269     0.0538   0.269       0.269 \nMock.8      0.269     0.0108    0.269    0.0538      0.0538\nMock.9      0.0108    0.0538    0.269    0.0538      0.0538\nMock.10     0.111     0.111     0.111    0.111       0.111 \n# … with 4 more taxa (columns)\n\nps.mock.pseudo\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 10 samples ]:\nsample_data() Sample Data:        [ 10 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nWe can use metacal::pairwise_ratios() to compute the FCs in abundances between all samples + for all taxa, given a phyloseq object.\n\n\nfcs <- list(Actual = mock_actual, Observed = ps.mock.pseudo) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = \"samples\", filter = FALSE) %>%\n  map_dfr(psmelt, .id = \"Type\") %>%\n  # redo sample.1 and sample.2 since missing for the mock\n  select(-sample.1, -sample.2) %>%\n  rename(Pair = Sample, Fold_change = Abundance) %>%\n  separate(Pair, str_c(\"Sample.\", 1:2), sep = \":\", remove = FALSE) %>%\n  mutate(across(OTU, factor, levels = bias %>% sort %>% names)) %>%\n  left_join(sme0 %>% select(Sample.1 = Sample, SMRE, Melampsora), \n    by = \"Sample.1\") %>%\n  left_join(sme0 %>% select(Sample.2 = Sample, SMRE, Melampsora), \n    by = \"Sample.2\", suffix = c(\".1\", \".2\"))\n\n\n\n\n\nfcs %>%\n  filter(Pair %in% c(\"Mock.5:Mock.3\", \"Mock.9:Mock.7\")) %>%\n  ggplot(aes(y = OTU, x = Fold_change, shape = Type, color = Type)) +\n  facet_grid(. ~ Pair) +\n  scale_shape_manual(values = c(Actual = 3, Observed = 1)) +\n  scale_color_brewer(type = \"qual\", palette = 6) +\n  geom_vline(xintercept = 1, color = \"black\", size = 0.2) +\n  geom_point(size = 2) +\n  theme_minimal_hgrid() +\n  scale_x_log10(limits = c(3e-3, 1e2), oob = scales::squish) +\n  labs(x = \"Fold change in proportion\") +\n  plot_annotation(\n    title = \"Actual and observed fold changes between pairs of mocks\"\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020-fc-mock-examples.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nCan see that on the left, the error is positive for all taxa, and of a similar magnitude (on the order of ~6X, as predicted) for all taxa except for Epicoccum, which dropped out during sequencing in Mock.5; and on the right, the error is smaller and not consistently positive or negative. Sign errors correspond to the observed and actual fold changes being on opposing sides of the vertical red line at 1.\ntodo: add the SMRE changes to the facet labels, and perhaps mark the expected\nWhat other types of plots, which might use all pairs of samples?\nwe could plot the observed vs. predicted error\nwe could check that the error really is taxon independent; one way to do this is to calc the correlation in LFC between observed and actual\n\n\nlvls <- sme0 %>% arrange(SMRE) %>% pull(Sample)\nfcs0 <- fcs %>%\n  # filter(Sample.1 < Sample.2) %>%\n  select(Type:Fold_change, SMRE.1:Melampsora.2) %>%\n  pivot_wider(names_from = Type, values_from = Fold_change) %>%\n  mutate(across(c(Sample.1, Sample.2), factor, levels = lvls))\n\n\n\n\n\nfcs0 %>%\n  filter(as.integer(Sample.1) < as.integer(Sample.2)) %>%\n  ggplot(aes(Actual, Observed, color = OTU)) +\n  geom_abline(color = \"grey\") +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_log10() +\n  facet_grid(Sample.1 ~ Sample.2) +\n  scale_color_brewer(type = \"qual\", palette = 3)\n\n\n\n\nNote how (especially) for Mock 1 and 6, the points follow a straight line with a greater slope than predicted. This seems likely related to the systematic deviation from the model that I observed.\nCheck that there is indeed very high correlations; remove the Epicoccum Mock-5 dropout first to avoid major distortions just from that.\n\n\ncorrs <- fcs0 %>%\n  filter(\n    Sample.1 != Sample.2,\n    !((Sample.1 == \"Mock.5\" | Sample.2 == \"Mock.5\") & OTU == \"Epicoccum\")\n  ) %>%\n  mutate(across(c(Actual, Observed), log10)) %>%\n  group_by(Pair) %>%\n  summarize(correlation = cor(Actual, Observed, method = \"pearson\"))\ncorrs %>% pull(correlation) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.9637  0.9827  0.9894  0.9874  0.9929  0.9989 \n\n# qplot(corrs$correlation)\n\n\n\nExperiment samples\nWe could just try picking a high and low Melampsora sample - perhaps from the mode of the peaks, rather than the extreme.\n\n\nsme0 %>%\n  filter(Samp_type == \"Experiment\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 548 x 5\n   Sample         SMRE Melampsora log10_SMRE       diff\n   <chr>         <dbl>      <dbl>      <dbl>      <dbl>\n 1 G12.T6.R4.TP1 0.996  0.00182     -0.00185 NA        \n 2 G1.T5.R2.TP1  1.24   0.0000218    0.0939   0.0958   \n 3 G11.T2.R4.TP1 1.24   0.0000836    0.0951   0.00114  \n 4 G12.T1.R2.TP1 1.28   0.0000166    0.108    0.0128   \n 5 G12.T2.R4.TP1 1.28   0.0000309    0.108    0.000619 \n 6 G11.T3.R3.TP1 1.29   0.000253     0.110    0.00119  \n 7 G2.T2.R4.TP1  1.29   0.0000220    0.110    0.000570 \n 8 G8.T4.R1.TP1  1.29   0.0000132    0.110    0.0000354\n 9 G9.T5.R3.TP1  1.29   0.0000714    0.110    0.000185 \n10 G4.T6.R3.TP1  1.29   0.000197     0.112    0.00139  \n# … with 538 more rows\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.0.5 (2021-03-31)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-04-21                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package      * version    date       lib source                           \n ade4           1.7-16     2020-10-28 [1] CRAN (R 4.0.3)                   \n ape            5.4-1      2020-08-13 [1] CRAN (R 4.0.2)                   \n assertthat     0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports      1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm       0.3.1      2021-03-07 [1] CRAN (R 4.0.5)                   \n Biobase        2.50.0     2020-10-27 [1] Bioconductor                     \n BiocGenerics   0.36.0     2020-10-27 [1] Bioconductor                     \n biomformat     1.18.0     2020-10-27 [1] Bioconductor                     \n Biostrings     2.58.0     2020-10-27 [1] Bioconductor                     \n broom          0.7.6      2021-04-05 [1] CRAN (R 4.0.5)                   \n bslib          0.2.4      2021-01-25 [1] CRAN (R 4.0.4)                   \n cellranger     1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli            2.4.0      2021-04-05 [1] CRAN (R 4.0.5)                   \n cluster        2.1.1      2021-02-14 [2] CRAN (R 4.0.5)                   \n codetools      0.2-18     2020-11-04 [2] CRAN (R 4.0.5)                   \n colorspace     2.0-0      2020-11-11 [1] CRAN (R 4.0.3)                   \n cowplot      * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon         1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table     1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI            1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr         2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest         0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill        1.2.4      2021-04-05 [1] Github (rstudio/distill@3ec93f1) \n downlit        0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr        * 1.0.5      2021-03-05 [1] CRAN (R 4.0.4)                   \n ellipsis       0.3.1      2020-05-15 [1] CRAN (R 4.0.0)                   \n evaluate       0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi          0.4.2      2021-01-15 [1] CRAN (R 4.0.3)                   \n farver         2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats      * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach        1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs             1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics       0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n ggbeeswarm   * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2      * 3.3.3      2020-12-30 [1] CRAN (R 4.0.4)                   \n glue           1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable         0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven          2.3.1      2020-06-01 [1] CRAN (R 4.0.1)                   \n here           1.0.1      2020-12-13 [1] CRAN (R 4.0.3)                   \n highr          0.8        2019-03-20 [1] CRAN (R 4.0.0)                   \n hms            1.0.0      2021-01-13 [1] CRAN (R 4.0.4)                   \n htmltools      0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n httr           1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph         1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges        2.24.1     2020-12-12 [1] Bioconductor                     \n iterators      1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib      0.1.3      2020-12-17 [1] CRAN (R 4.0.4)                   \n jsonlite       1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr          1.31       2021-01-27 [1] CRAN (R 4.0.3)                   \n lattice        0.20-41    2020-04-02 [2] CRAN (R 4.0.5)                   \n lifecycle      1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate      1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr       2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS           7.3-53.1   2021-02-12 [2] CRAN (R 4.0.5)                   \n Matrix         1.3-2      2021-01-06 [2] CRAN (R 4.0.5)                   \n metacal      * 0.2.0      2021-04-21 [1] Github (mikemc/metacal@cf3a3c7)  \n mgcv           1.8-34     2021-02-16 [2] CRAN (R 4.0.5)                   \n modelr         0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest       2.46.0     2020-10-27 [1] Bioconductor                     \n munsell        0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme           3.1-152    2021-02-04 [2] CRAN (R 4.0.5)                   \n nvimcom      * 0.9-102    2021-04-05 [1] local                            \n patchwork    * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute        0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq     * 1.34.0     2020-10-27 [1] Bioconductor                     \n pillar         1.6.0      2021-04-13 [1] CRAN (R 4.0.5)                   \n pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr           1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n prettyunits    1.1.1      2020-01-24 [1] CRAN (R 4.0.0)                   \n progress       1.2.2      2019-05-16 [1] CRAN (R 4.0.2)                   \n ps             1.6.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n purrr        * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6             2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer   1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp           1.0.6      2021-01-15 [1] CRAN (R 4.0.3)                   \n readr        * 1.4.0      2020-10-05 [1] CRAN (R 4.0.3)                   \n readxl         1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex         2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2       1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5          2.34.0     2020-10-27 [1] Bioconductor                     \n rhdf5filters   1.2.0      2020-10-27 [1] Bioconductor                     \n Rhdf5lib       1.12.1     2021-01-26 [1] Bioconductor                     \n rlang          0.4.10     2020-12-30 [1] CRAN (R 4.0.3)                   \n rmarkdown    * 2.7        2021-02-19 [1] CRAN (R 4.0.4)                   \n rprojroot      2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi     0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest          1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors      0.28.1     2020-12-09 [1] Bioconductor                     \n sass           0.3.1      2021-01-24 [1] CRAN (R 4.0.4)                   \n scales         1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo    1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq    * 0.5.3.9001 2020-10-06 [1] Github (mikemc/speedyseq@8daed32)\n stringi        1.5.3      2020-09-09 [1] CRAN (R 4.0.3)                   \n stringr      * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival       3.2-10     2021-03-16 [2] CRAN (R 4.0.5)                   \n tibble       * 3.1.1      2021-04-18 [1] CRAN (R 4.0.5)                   \n tidyr        * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect     1.1.0      2020-05-11 [1] CRAN (R 4.0.0)                   \n tidyverse    * 1.3.0      2019-11-21 [1] CRAN (R 4.0.0)                   \n useful         1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8           1.2.1      2021-03-12 [1] CRAN (R 4.0.5)                   \n vctrs          0.3.7      2021-03-29 [1] CRAN (R 4.0.5)                   \n vegan          2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor          0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr          2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun           0.22       2021-03-11 [1] CRAN (R 4.0.5)                   \n xml2           1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector        0.30.0     2020-10-27 [1] Bioconductor                     \n yaml           2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc       1.36.0     2020-10-27 [1] Bioconductor                     \n\n[1] /home/michael/R/x86_64-pc-linux-gnu-library/4.0\n[2] /usr/lib/R/library\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2020-11-12-leopold2020host-bias-sensitivity/index_files/figure-html5/unnamed-chunk-3-1.svg",
    "last_modified": "2021-10-25T15:24:55-04:00",
    "input_file": {}
  }
]
